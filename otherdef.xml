<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2018.1.7 (Build 721U)" ts="2025-08-07 11:56:40">
<Class name="%Library.PackageDefinition">
<Description><![CDATA[
This class represents a specific <i>package</i> description contained within the 
<i>Cach&eacute; Dictionary.</i>]]></Description>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>

<Property name="Name">
<Description>
A string containing the name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientName">
<Description>
A string containing the client name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Description">
<Description>
A string containing the description of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GlobalPrefix">
<Description>
A string containing the global prefix of the package, used for data, id, and index locations.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OwnerName">
<Description>
A string containing the Owner's name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnPrefix">
<Description>
A string containing the routine prefix of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SQLName">
<Description>
A string containing the SQL name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="list">
<Type>%ListOfDataTypes</Type>
<Transient>1</Transient>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue="" q $$$ERROR($$$PackageNameRequired)
 s i%Name=initvalue
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 #define LOADVSTRING(%ivar,%global) s %ivar=$g(%global)
 n name
 s i%Name=id
 $$$LOADVSTRING(name,$$$PACKAGEname(i%Name)) i name'="" s i%Name=name
 $$$LOADVSTRING(i%ClientName,$$$PACKAGEclientname(i%Name))
 $$$LOADVSTRING(i%Description,$$$PACKAGEdescription(i%Name))
 $$$LOADVSTRING(i%GlobalPrefix,$$$PACKAGEglobalprefix(i%Name))
 $$$LOADVSTRING(i%OwnerName,$$$PACKAGEownername(i%Name))
 $$$LOADVSTRING(i%RtnPrefix,$$$PACKAGErtnprefix(i%Name))
 $$$LOADVSTRING(i%SQLName,$$$PACKAGEsqlname(i%Name))
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 #define SAVEOPTIONAL(%global,%ivar) s %global=%ivar k:%ivar="" %global
 i i%Name="" q $$$ERROR($$$PackageNameRequired)
 i id="" n sc s sc=..%IdSet(i%Name) i $$$ISERR(sc) q sc
 $$$SAVEOPTIONAL($$$PACKAGEname(i%Name),i%Name)
 $$$SAVEOPTIONAL($$$PACKAGEclientname(i%Name),i%ClientName)
 $$$SAVEOPTIONAL($$$PACKAGEdescription(i%Name),i%Description)
 $$$SAVEOPTIONAL($$$PACKAGEglobalprefix(i%Name),i%GlobalPrefix)
 $$$SAVEOPTIONAL($$$PACKAGEownername(i%Name),i%OwnerName)
 $$$SAVEOPTIONAL($$$PACKAGErtnprefix(i%Name),i%RtnPrefix)
 $$$SAVEOPTIONAL($$$PACKAGEsqlname(i%Name),i%SQLName)
 #; the top node is for system code to query
 s $$$PACKAGE(i%Name)=i%RtnPrefix
 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i id="" q $$$ERROR($$$PackageNameRequired)
 QUIT $$DeletePackageDefinition^%apiOBJ(id,"-d")
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%Name="" q $$$ERROR($$$PackageNameRequired)
 i $l(i%GlobalPrefix)>31 q $$$ERROR($$$PackageGlobalPrefixTooLong)
 q $$$OK
]]></Implementation>
</Method>

<Method name="GetPackageList">
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
 n package,packagelist,data
 i ..list=$$$NULLOREF s ..list=##class(%ListOfDataTypes).%New()
 d ..list.Clear()
 If $Get(^rINDEXCLASS)="" Do RebuildIndex^%R()
 s class="" 
 f  s class=$o(^rINDEXCLASS(class)) q:class=""  s package=$$$ClassPackageName(class) s:package'="" packagelist(package)=""
 s package="" f  s package=$$$PACKAGEnext(package) q:package=""  s packagelist($zcvt(package,"u"))=""
 s package="" f  s package=$o(packagelist(package)) q:package=""  d ..list.Insert(package)
 q ..list
]]></Implementation>
</Method>

<Query name="SubPackage">
<Description><![CDATA[
The <b>SumPackage</b> query provides a list of sub-package names.
This query works in a hierarchical way, 
it returns only one level of sub-package under a specified <var>SuperPackage</var> name.]]></Description>
<Type>%Query</Type>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SubPackageExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,SuperPackage:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set QHandle=$lb($g(SuperPackage),$zcvt($g(SuperPackage),"u"))
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubPackageFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..SubPackageFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="SubPackageFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set supername=$list(QHandle,1)
 Set superlength=$l(supername)
 Set subpiece=$s(supername="":1,1:$l(supername,".")+1)
 If '$get(FetchCount) Set FetchCount=10000
 If $get(AtEnd) Set QHandle="" Quit $$$OK
 Set AtEnd=0
 Set RowSet=""
 Set ReturnCount=0
 i $g(^%mo("break")) break
 Set class=$list(QHandle,2) For  {
 Set class=$o(^rINDEXCLASS(class))
 Set package=$$$ClassPackageName($li(^rINDEXCLASS(class),2))
 If class="" Set AtEnd=1 Quit
 If $e(package,1,superlength)'=supername Set AtEnd=1 Quit
 If superlength,$l(package)>superlength,$e(package,superlength+1)'="." Set AtEnd=1 Quit
 Set subpackage=$p(package,".",subpiece)
 If subpackage'="" {
 Set RowSet=RowSet_$lb(subpackage)
 Set ReturnCount=ReturnCount+1
 Set header=$p($li(^rINDEXCLASS(class),2),".",1,subpiece)
 For  {
 Set next=$o(^rINDEXCLASS(class))
 If next="" Set AtEnd=1,class="" Quit
 If $p($li(^rINDEXCLASS(next),2),".",1,subpiece)'=header Quit
 Set class=next
 }
 If ReturnCount'<FetchCount Quit
 If $length(RowSet)>10000 Quit
 }
 }
 Set QHandle=$lb(supername,class)
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubPackageClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set QHandle=""
 Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.PackageDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.ParameterDefinition">
<Description><![CDATA[
<b>
Note: The class definition classes in the %Library package have been superceded
by those in the %Dictionary package.</b>
<p>
This class represents a specific <i>class parameter</i> description for a class contained 
within the <i>Cach&eacute; Dictionary.</i>

<p>For more information on class definition classes, refer to
<link href=/AboutClassDefinition.html>About Class Definition Classes</link>.]]></Description>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>

<Property name="ClassName">
<Description>
A string containing the name of the class the method belongs to.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
A string containing the name of the class parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Default">
<Description>
A string containing the default value for the class parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Description">
<Description>
A string containing the description for the class parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
A flag indicating whether the class parameter is final (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
A flag indicating whether the class parameter is internal (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Flags">
<Description>
This is for internal use only.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Constraint">
<Description>
This is for internal use only.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
This is for internal use only.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
Sequence number used to determine order of this item in Studio editor and in XML export format.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%Name=$p(initvalue,":",2)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 s i%ClassName=$$$NormalizeClassname(i%ClassName)
 i i%Name="" q $$$ERROR($$$ParameterNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$ParameterNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,paramname
 i id[":"
 i  s classname=$p(id,":",1),paramname=$p(id,":",2)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-1),paramname=$p(id,".",len)
 s i%ClassName=classname
 s i%Name=paramname
 ;
 s i%Default=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMdefault)
 s i%Description=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMdescription)
 s i%Final=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMfinal)
 s i%Flags=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMflags)
 s i%Internal=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMinternal)
 s i%Constraint=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMconstraint)
 s i%Type=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMtype)
 s i%SequenceNumber=$$$defMemberKeyGet(classname,$$$cCLASSparameter,paramname,$$$cPARAMsequencenumber)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$ParameterNameRequired)
 ;
 n classname,paramname
 s classname=i%ClassName
 s paramname=i%Name
 ;
 i id="" n sc s sc=..%IdSet(classname_":"_paramname) i $$$ISERR(sc) QUIT sc
 ;
 #define SAVEstring(%class,%kind,%member,%keyword,%value) i %value'=$$$tableDefaultGet(%kind,%keyword) { $$$defMemberKeySet(%class,%kind,%member,%keyword,%value) } else { $$$defMemberKeyKill(%class,%kind,%member,%keyword) }
 #define SAVEnumber(%class,%kind,%member,%keyword,%value) i +%value'=$$$tableDefaultGet(%kind,%keyword) { $$$defMemberKeySet(%class,%kind,%member,%keyword,+%value) } else { $$$defMemberKeyKill(%class,%kind,%member,%keyword) }
 ;
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMdefault,i%Default)
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMdescription,i%Description)
 $$$SAVEnumber(classname,$$$cCLASSparameter,paramname,$$$cPARAMfinal,i%Final)
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMflags,i%Flags)
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMinternal,i%Internal)
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMconstraint,i%Constraint)
 $$$SAVEstring(classname,$$$cCLASSparameter,paramname,$$$cPARAMtype,i%Type)
 $$$SAVEnumber(classname,$$$cCLASSparameter,paramname,$$$cPARAMsequencenumber,i%SequenceNumber)
 ;
 $$$defMemberSet(classname,$$$cCLASSparameter,paramname,"")
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,paramname
 s classname=$p(id,":",1)
 s paramname=$p(id,":",2)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i paramname="" q $$$ERROR($$$ParameterNameRequired)
 $$$defMemberKill(classname,$$$cCLASSparameter,paramname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.ParameterDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.Persistent">
<Description><![CDATA[
The <CLASS>%Persistent</CLASS> class provides the basic mechanism by 
which objects are stored to and retrieved from a database. ]]></Description>
<Abstract>1</Abstract>
<ClassType>persistent</ClassType>
<PropertyClass>%Library.PersistentProperty</PropertyClass>
<Super>%SwizzleObject</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>
<NoExtent>1</NoExtent>

<Parameter name="DEFAULTGLOBAL">
<Description><![CDATA[
<p>If a persistent class uses %Library.CacheStorage then the <var>DEFAULTGLOBAL</var> parameter is used as the
default global root for the values of the storage keywords COUNTERLOCATION, DATALOCATION, IDLOCATION,
INDEXLOCATION and STREAMLOCATION in the active storage definition. <var>DEFAULTGLOBAL</var> is only used
to generate location keyword values that are not already defined. The location value is constructed by adding
a location type to the end of <var>DEFAULTGLOBAL</var>. For example, if <var>DEFAULTGLOBAL</var> = "^GL.Account"
the compiler will generate <var>DATALOCATION</var> = ^GL.AccountD.</p>
<p>
If <parameter>USEEXTENTSET</parameter> is true, then DEFAULTGLOBAL is used as the default extent location. 
</p>
<br>
The location types are:
<table>
<tr><th align="left">Location</th><th align="left">Type</th>
<tr><td>COUNTERLOCATION</td><td align="center">C</td></tr>
<tr><td>DATALOCATION</td><td align="center">D</td></tr>
<tr><td>IDLOCATION</td><td align="center">D</td></tr>
<tr><td>INDEXLOCATION</td><td align="center">I</td></tr>
<tr><td>STREAMLOCATION</td><td align="center">S</td></tr>
</table>]]></Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="DSTIME">
<Description><![CDATA[
If the <var>DSTIME</var> parameter is set to AUTO then the most recent filing operation in the current DSTIME value 
for each object will be recorded in a global, ^OBJ.DSTIME: 
<br>
	^OBJ.DSTIME(<var>ExtentName</var>,<var>DSTIME</var>,<var>objectID</var>) = <var>filing operation</var> 
<br>
For DSTIME=AUTO the DSTIME value is recorded in ^OBJ.DSTIME and is set by the consumer of DSTIME data.
<br>
Refer to %DeepSee documentation for more information on how DSTIME is used by %DeepSee. 
<br>
The filing operations are:
<table>
<tr><th align="left">Code</th><th align="left">Operation</th>
<tr><td>0</td><td align="center">Update</td></tr>
<tr><td>1</td><td align="center">Insert</td></tr>
<tr><td>2</td><td align="center">Delete</td></tr>
</table>
<br>
If the <var>DSTIME</var> parameter is set to MANUAL then the user is responsible for journaling object filing operations.]]></Description>
<Type>STRING</Type>
<Constraint>,AUTO,MANUAL</Constraint>
<Flags>ENUM</Flags>
</Parameter>

<Parameter name="DSINTERVAL">
<Description><![CDATA[
DSINTERVAL is the number of seconds between one DSTIME value and the next. The DSTIME value for DSINTERVAL > 0 is computed from $ZTIMESTAMP
and is the number of seconds from day 0, time 0 to the nearest interval, rounded down. Using an interval has the effect of grouping
all DSTIME entries for the class in some number of seconds.]]></Description>
<Type>INTEGER</Type>
</Parameter>

<Parameter name="EXTENTQUERYSPEC">
<Description><![CDATA[
The <var>EXTENTQUERYSPEC</var> parameter defines the properties to be retrieved in 
addition to the IDKEY value for the built-in <b>Extent</b> query.
<p>Persistent classes should define a value of for <var>EXTENTQUERYSPEC</var> if they 
wish to include additional properties in their built-in <b>Extent</b> query.
<p>For example:
<EXAMPLE LANGUAGE=NONE>
parameter EXTENTQUERYSPEC = "Name,SSN,Age";
</EXAMPLE>]]></Description>
<Type>ROWSPEC</Type>
<Flags>LIST</Flags>
</Parameter>

<Parameter name="EXTENTSIZE">
<Description><![CDATA[
The <var>EXTENTSIZE</var> parameter is used to inform the <i>Cach&eacute; SQL Query Optimizer</i> 
of the approximate number of instances in the extent containing instances of this class.

<p>For example, a class that expects to have about 1,000,000 instances should define:
<EXAMPLE LANGUAGE=NONE>
parameter EXTENTSIZE = 1000000;
</EXAMPLE>]]></Description>
<Type>INTEGER</Type>
<Default>100000</Default>
</Parameter>

<Parameter name="GUIDENABLED">
<Description>
If this parameter is set to 1 then a GUID will be assigned (to the %GUID property) to each new object.
When the object is saved for the first time this GUID value will be recorded in a namespace
index which will allow GUID to be resolved to OIDs.</Description>
<Default>0</Default>
</Parameter>

<Parameter name="IDENTIFIEDBY">
<Description><![CDATA[
The <var>IDENTIFIEDBY</var> parameter can optionally be set to the name 
of a required property whose type is a reference to another class (not a literal). 
This property's IDKEY is then used as the prefix for the IDKEY of this class.]]></Description>
</Parameter>

<Parameter name="MANAGEDEXTENT">
<Description><![CDATA[
The <var>MANAGEDEXTENT</var> parameter can be set to 0 (zero) to cause the Extent Manager
to ignore this class. If set to 1 then the Extent Manager will register globals used by
the class and detect collisions. Unmanaged extents (MANAGEDEXTENT = 0) are not checked.
Currently, only classes using default storage (%Library.CacheStorage) can be managed.]]></Description>
<Type>INTEGER</Type>
<Constraint>0,1</Constraint>
<Default>1</Default>
<Flags>ENUM</Flags>
</Parameter>

<Parameter name="READONLY">
<Description>
READONLY = 1 means that objects can be created, opened but not saved or deleted.
Tables are projected to SQL as READONLY.</Description>
<Default>0</Default>
</Parameter>

<Parameter name="ROWLEVELSECURITY">
<Description><![CDATA[
ROWLEVELSECURITY = 1 | &lt;property&gt; means that row level security is active and the list
of users/roles for a given instance/row is contained in a generated property. If
the value of this parameter is a valid property name then that property will be
used as the reader list and only generated if not already defined.]]></Description>
</Parameter>

<Parameter name="SQLPREVENTFULLSCAN">
<Description>
SQLPREVENTFULLSCAN = 1 means an attempt to prepare a query that will result in a full scan 
of the data map will result in an error.  This applies only to queries that result in a 
master map scan (not indexes), with no subscript-limiting conditions on %ID or any of its components, 
including queries with aggregates, and including UPDATE/DELETE.</Description>
<Default>0</Default>
</Parameter>

<Parameter name="USEEXTENTSET">
<Description><![CDATA[
<p>If a persistent class uses %Library.CacheStorage then the <var>USEEXTENTSET</var> parameter is used to 
specify the global naming strategy used by the default storage class (<class>%Library.CacheStorage</class>). 
If TRUE, then global names are generated for each index that is not already allocated a LOCATION in the active 
storage definition. 
</p>
<p>
If the storage definition specifies EXTENTLOCATION then that value is used as the base reference for all globals 
assigned to indices that do not have an explicit LOCATION assigned. 
</p>
<p>
The global name generator for <var>USEEXTENTSET</var> = TRUE honors the package prefix defined 
in the Package Definition. If none is defined then the package prefix is generated using a based-62 encoded integer 
produced from CRC32 of the package name. The specific class identifier is generated from the unqualified class name using 
the same hash (class->crc32->base62) to form EXTENTLOCATION. Specific index suffixes are produced using a generated 
offset that is local to the first persistent class with an enumerated extent in which the index appears (either defined or inherited). 
</p>
<p>
There are several factors that influence the generation of EXTENTLOCATION:
<ol type="1">
<li>If the EXTENTLOCATION keyword is defined then its value is used,</li>
<li>If the DEFAULTGLOBAL class parameter is defined then its value is used,</li>
<li>otherwise, the value is generated as two dot delimited segments. The first segment is either the defined package prefix retrieved from 
the package definition global or, if none is defined, a hash of the package name. The second segment is generated by a hash of the unqualified 
class name. The hash used is a base 62 encoded CRC32 of the value. For example, Sample.Person produces ^EW3K.wPC9 if no package prefix is defined. </li>
</ol>
The EXTENTLOCATION value is used as the base for specific globals allocated to indices. Each index is assigned an offset that is incremented from 
1 by 1, offset = 1 is reserved for the IDKEY index.
</p>
<p>
EXTENTLOCATION is specific to each class. When a persistent class extends another persistent class, forming a subextent, then the subclass's EXTENTLOCATION 
is specific to that subclass. The index location for any inherited index is already defined specifically in the super class so the subclass's EXTENTLOCATION 
will only be used as the base for any index that originates in the subclass. For example, Sample.Employee extends Sample.Person. The EXTENTLOCATION generated for 
Sample.Person is ^EW3K.wPC9 and the EXTENTLOCATION for Sample.Employee is ^EW3K.D1Ex. Since Sample.Employee inherits several indices from Sample.Person, the 
global name assigned to each of those indices is already defined and inherited by Sample.Employee. However, any index defined in Sample.Employee and not 
inherited from Sample.Person will be assigned a global name based on Sample.Employee's EXTENTLOCATION, not on Sample.Person's EXTENTLOCATION. In other words, 
the EXTENTLOCATION storage keyword is not inherited. 
</p>
<p>
The following tables show the indices and locations for Sample.Person and Sample.Employee. Notice the last index in the Sample.Employee table: 
<table>
	<tr><td align="left">Class = Sample.Person</td></tr>
	<tr>
		<td>
			<table>
				<tr><th align="left">Index</th><th align="left">Location</th>
				<tr><td>IDKEY</td><td>^EW3K.wPC9.1</td></tr>
				 <tr><td>$Person</td><td>^EW3K.wPC9.2</td></tr>
				<tr><td>NameIDX</td><td>^EW3K.wPC9.3</td></tr>
				<tr><td>SSNKey</td><td>^EW3K.wPC9.4</td></tr>
				<tr><td>ZipCode</td><td>^EW3K.wPC9.5</td></tr>
			</table>
		</td>
	</tr>
	<tr></tr>
	<tr><td align="left">Class = Sample.Employee extends Sample.Person</td></tr>
	<tr>
		<td>
			<table>
				<tr><th align="left">Index</th><th align="left">Location</th>
				<tr><td>IDKEY</td><td>^EW3K.wPC9.1</td></tr>
				<tr><td>$Person</td><td>^EW3K.wPC9.2</td></tr>
				<tr><td>NameIDX</td><td>^EW3K.wPC9.3</td></tr>
				<tr><td>SSNKey</td><td>^EW3K.wPC9.4</td></tr>
				<tr><td>ZipCode</td><td>^EW3K.wPC9.5</td></tr>
				<tr><td>$Employee</td><td>^EW3K.D1Ex.2</td></tr>
			</table>
		</td>
	</tr>
</table>
<p>
Any generated global index locations and EXTENTLOCATION are updated back into the active storage definition after the class is 
compiled. 
</p>
<p>
If <var>USEEXTENTSET</var> is FALSE, then global names are generated using the package-hash.class-hashSuffix strategy. 
For example, ^Sample.PersonD and ^Sample.PersonI("SSNKey") are globals used by Sample.Person and specific index structures 
are all stored in ^Sample.PersonI with the index name used as the first subscript. 
</p>
<br>]]></Description>
<Default>0</Default>
</Parameter>

<Parameter name="VERSIONPROPERTY">
<Description><![CDATA[
VERSIONPROPERTY = &lt;property&gt; means that the &lt;property&gt; in memory will be compared to
the &lt;property&gt; on disk during an update. If different a concurrency conflict
error will be reported and the save will fail.]]></Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="VERSIONCLIENTNAME">
<Description>
VERSIONCLIENTNAME can be set to a valid CLIENTNAME (see property CLIENTNAME) value. This
value will be used for client projections of the %Version property.</Description>
</Parameter>

<Property name="%Concurrency">
<Description><![CDATA[
<p>%Concurrency holds the value of the concurrency setting for this object.
</p>
	<TABLE cols=2 border=1>
	<TR>
		<TD valign="top">0:</TD><TD CLASS=Term valign="top">None</TD>
			<TD valign="top">
			Suppress all concurrency controls for this object. No locks are used.
			</TD>
		</TR>
		<TR>
			<TD valign="top">1:</TD><TD CLASS=Term valign="top">Atomic Read</TD>
			<TD valign="top">
				When an object is loaded, <b>%LoadData</B>  will read the entire object from disk without the possibility
			that another process will write any data to this object before the read operation is
			complete. If necessary, Cache will acquire a shared lock on the object to guarantee an atomic read.
			Any locks acquired during the read operation are released after the read operation is completed.
				No locks are acquired for a new object.
			<b>%SaveData</B> will acquire an exclusive lock during the course of the save.
			</TD>
		</TR>
		<TR>
			<TD valign="top">2:</TD><TD CLASS=Term valign="top">Shared</TD>
			<TD valign="top">
				When an object is loaded, <b>%LoadData</B> will acquire a shared lock on the object and read the entire object from disk.
			The lock is released after the read operation is completed.
				No locks are acquired for a new object.
			<b>%SaveData</B> will acquire an exclusive lock during the course of the save.
			</TD>
		</TR>
		<TR>
			<TD valign="top">3:</TD><TD CLASS=Term valign="top">Shared/Retained</TD>
			<TD valign="top">
			When an object is loaded, <b>%LoadData</B> will acquire a shared lock for the object.
			The lock is released when the object is destructed (removed from memory).<br>
				No locks are initially acquired for a new object.
			<b>%SaveData</B> will acquire an exclusive lock during the course of the save.
			<b>%SaveData</B> will also acquire a shared lock when saving a new object. This lock is retained
				until the object is destructed (removed from memory).
			</TD>
		</TR>
		<TR>
			<TD valign="top">4:</TD><TD CLASS=Term valign="top">Exclusive</TD>
			<TD valign="top">
			When an object is loaded, <b>%LoadData</B> will acquire an exclusive lock for the object.
			The lock is released when the object is destructed (removed from memory).<br>
			<b>%SaveData</B> will acquire an exclusive lock when saving a new object. This lock is retained
				until the object is destructed (removed from memory).
		</TD>
	</TR>
</table>
	<p>The only difference between Shared (2) and Atomic Read (1) settings is that Shared concurrency
	triggers a shared lock to always be acquired during read while Atomic Read will only acquire a
	shared lock when required to ensure an atomic read.</p>]]></Description>
<Type>%CacheString</Type>
<Final>1</Final>
<Internal>1</Internal>
<InitialExpression>$zu(115,10)</InitialExpression>
<Transient>1</Transient>
</Property>

<Method name="%ConcurrencySet">
<Internal>1</Internal>
<FormalSpec>val:%CacheString</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%%Concurrency=val
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%Delete">
<Description><![CDATA[
Deletes the stored version of the object with OID <var>oid</var> from the database. 
It does not remove any in-memory versions of the object that may be present.

Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
on the optional <var>concurrency</var> argument.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.

<p>Internally, <METHOD>%Delete</METHOD> initiates a transaction and then invokes the storage 
interface method <METHOD>%DeleteData</METHOD>. If <METHOD>%DeleteData</METHOD> succeeds, the 
transaction is committed, otherwise it is rolled back. ]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>oid:%ObjectIdentity="",concurrency:%Integer=-1</FormalSpec>
<GenerateAfter>%OnDelete,%OnJournalObject</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	s %code=0
	Set connection=$$$comMemberKeyGet(%class,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)
	$$$comMemberKeyGetLvar(objectjournal,%class,$$$cCLASSparameter,"OBJJOURNAL",$$$cPARAMdefault)
	$$$comMemberKeyGetLvar(tDSTIME,%class,$$$cCLASSparameter,"DSTIME",$$$cPARAMdefault)
	if ($$$ucase(tDSTIME) = "AUTO") {
		$$$comMemberKeyGetLvar(tDSINTERVAL,%class,$$$cCLASSparameter,"DSINTERVAL",$$$cPARAMdefault)
		if tDSINTERVAL '> 0 { set tDSTIME = 1 } else { set tDSTIME = 2 }
	}
	else { set tDSTIME = 0 }
		#; 'filter' will be true if object journal filtering is true. If so, then the object being deleted must be instantiated and $$$txJournalObjectDelete called instead of $$$txJournalDelete
	$$$comMemberKeyGetLvar(filter,%class,$$$cCLASSmethod,"%OnJournalObject",$$$cMETHrunnable)
	Set storageclass = ""
	if objectjournal + tDSTIME {
		$$$comClassKeyGetLvar(storagename,%class,$$$cCLASSstoragestrategy)
		If storagename '= "" $$$comMemberKeyGetLvar(storageclass,%class,$$$cCLASSstorage,storagename,$$$cSDEFtype)
		if storageclass = "%Library.CacheSQLStorage" { set tDSTIME = 0 }
	}
		#; Build a list of existent dependent items, such as streams (for now, that is all...)...
	Set property = $$$comMemberNext(%class,$$$cCLASSproperty,"")
	While property '= "" {
		if $$$comMemberKeyGet(%class,$$$cCLASSproperty,property,$$$cPROPrelationship) {
			$$$comMemberKeyGetLvar(cardinality,%class,$$$cCLASSproperty,property,$$$cPROPcardinality)
			if (cardinality = $$$cPROPCARDINALITYCHILDREN) || (cardinality = $$$cPROPCARDINALITYMANY) { set ondelete(property)=$lb($$$comMemberKeyGet(%class,$$$cCLASSproperty,property,$$$cPROPtype),$$$comMemberKeyGet(%class,$$$cCLASSproperty,property,$$$cPROPinverse)) }
		} Else {
			If $$$comMemberKeyGet(%class,$$$cCLASSproperty,property,$$$cPROPstorable) {
				$$$comMemberKeyGetLvar(proptype,%class,$$$cCLASSproperty,property,$$$cPROPtype)
				Set propclasstype = $$$getClassType(proptype)
				$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,property,$$$cPROPcollection)
				If propclasstype = $$$cCLASSCLASSTYPESTREAM { if connection = "" { Set stream(property) = collection, stream(property,1) = $$$QN(proptype) } }
				ElseIf (propclasstype = $$$cCLASSCLASSTYPESERIAL) && ($$$comMemberKeyGet(proptype,$$$cCLASSmethod,"%Delete",$$$cMETHrunnable)) { Set serial(property) = collection, serial(property,1) = $$$QN(proptype) }
			}
		}
		Set property = $$$comMemberNext(%class,$$$cCLASSproperty,property)
	}
		#; Generate the method...
	$$$GENERATE("	Quit:oid="""" $$$ERROR($$$NullOid,$classname()) Set id=$$$oidPrimary(oid) Quit:id="""" $$$ERROR($$$NullId,$classname()) set traninit=0")
	$$$GENERATE("	set $ZTRAP=""%DeleteERR""")
	$$$GENERATE("	If concurrency = -1 Set concurrency="_%parameter("DEFAULTCONCURRENCY"))
	$$$GENERATE("	If (concurrency > 4) || (concurrency < 0) || (concurrency '= (concurrency\1)) Quit $$$ERROR($$$ConcurrencyValueInvalid)")
		#; get class name
	$$$GENERATE("	Set class=$$$oidClassName(oid)")
		#; if class name is not present in oid, we must call the class method %OnDetermineClass
	$$$GENERATE("	If class="""" { Set sc=..%OnDetermineClass(oid,.class) Quit:$$$ISERR(sc) sc Set oid=$$$oidInsertClassName(oid,class) } Else { Set class=$$$NormalizeClassname(class) }")
		#; See if we are the correct class. If not, dispatch polymorphically to correct %Delete()
	$$$GENERATE("	If $classname()'=class Quit $classmethod(class,""%Delete"",oid,concurrency)")
	#; If TP is turned on start a transaction...
	If 'objectjournal {	$$$GENERATE("	If $$$txNOTINTRAN { Set traninit=1 $$$txBeginTran }") }
	Else {	$$$GENERATE("	If $$$txNOTINTRAN { Set traninit=1 $$$txBeginTranJrn }") }
	#; ##BEGINEVENT: DELETEDATA
	#; TODO: INSERT EVENT PROCESSING HERE
		#; find out if there is a %OnDelete method. If there is, call it
	If $$$comMemberKeyGet(%class,$$$cCLASSmethod,"%OnDelete",$$$cMETHrunnable) {
		$$$GENERATE("	Set sc=..%OnDelete(oid) g:$$$ISERR(sc) %DeleteEnd")
	}
		#; Generate relationship referential actions
	Set relationship = $Order(ondelete(""))
	While relationship '= "" {
		Set rclass=$li(ondelete(relationship)),rinverse=$li(ondelete(relationship),2)
		$$$GENERATE("	Set sc=##class("_rclass_")."_$$$QN(rinverse_"OnDelete")_"(id,concurrency) Goto:$$$ISERR(sc) %DeleteEnd" )
		Set relationship = $Order(ondelete(relationship))
	}
	$$$comMemberKeyGetLvar(guid,%class,$$$cCLASSparameter,"GUIDENABLED",$$$cPARAMdefault)
	If guid { $$$GENERATE("	Set guid = $get(^OBJ.GUID(1,oid))") }
		#; Check for actions that require swizzling. If any, swizzle and then perform the actions
	If ($Data(serial)) || ($Data(stream)) || (((filter) || (objectjournal = 2)) && (storageclass '= "%Library.CacheSQLStorage")) {
			#; Open the object being deleted:
		$$$GENERATE("	Set oref=..%Open(oid,concurrency) If oref=$$$NULLOREF Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),$$$oidPrimary(oid)) Goto %DeleteEnd")
			#; Delete streams
		If $data(stream) {
			Set property = $Order(stream(""))
			While property '= "" {
				Set qproperty=$$$QN(property)
				if stream(property) = "" { $$$GENERATE("	Set stream=oref."_qproperty_"GetObject() If stream'="""" set ^||%isc.strd($i(^||%isc.strd))=$lb(stream,"_stream(property,1)_")") }
				ElseIf stream(property) = $$$cPROPCOLLECTIONLIST { $$$GENERATE("	Set key="""" For ptr=1:1 Set value=oref."_qproperty_".GetObjectNext(.key) Quit:key=""""  i value'="""" set ^||%isc.strd($i(^||%isc.strd))=$lb(value,"_stream(property,1)_")")
				} ElseIf stream(property) = $$$cPROPCOLLECTIONARRAY { $$$GENERATE("	Set key="""" For  Set value=oref."_qproperty_".GetObjectNext(.key) Quit:key=""""  i value'="""" set ^||%isc.strd($i(^||%isc.strd))=$lb(value,"_stream(property,1)_")") }
				Set property = $Order(stream(property))
			}
		}
		If $Data(serial) {
			Set property = $Order(serial(""))
			While property '= "" {
				Set qproperty=$$$QN(property)
				If serial(property) = "" { $$$GENERATE("	Set sc = ##class("_serial(property,1)_").%Delete(oref."_qproperty_"GetObject(0),concurrency) Goto:$$$ISERR(sc) %DeleteEnd") }
				ElseIf serial(property) = $$$cPROPCOLLECTIONLIST { $$$GENERATE("	Set key="""" For ptr=1:1 Set value=oref."_qproperty_".GetObjectNext(.key) Quit:key=""""  Set sc = ##class("_serial(property,1)_").%Delete(value,concurrency) Goto:$$$ISERR(sc) %DeleteEnd") }
				ElseIf serial(property) = $$$cPROPCOLLECTIONARRAY { $$$GENERATE("	Set key="""" For  Set value=oref."_qproperty_".GetObjectNext(.key) Quit:key=""""  Set sc = ##class("_serial(property,1)_").%Delete(value,concurrency) Goto:$$$ISERR(sc) %DeleteEnd") }
				Set property = $Order(serial(property))
			}
		}
			#; Journal the delete if journaling turned on and it isn't already journalled by SQL trigger:
		If (objectjournal) && (storageclass '= "%Library.CacheSQLStorage") {
			if objectjournal < 3 { $$$GENERATE("	$$$txJournalObjectDelete($classname(),jid,id," _ $Select('guid:"""""",1:"guid") _ ",oref,iJrnPtr)") }
			else { $$$GENERATE("	$$$txJournal($classname(),jid,id,2)") }
		}
		$$$GENERATE("	Set oref=$$$NULLOREF")
	}

		// This is where the old relationship referential action of NOACTION was generated!!

	$$$GENERATE("	$$$ActiveOidSearch(oid,oref) If $isobject(oref)=1 Do oref.%DeleteOID()")
	$$$GENERATE("	Set sc=..%DeleteData(id,concurrency)")
	If (objectjournal) && ('filter) && ( storageclass '= "%Library.CacheSQLStorage" ) {
		if objectjournal = 1 { $$$GENERATE("	If $$$ISOK(sc) { $$$txJournalDelete($classname(),jid,id," _ $Select('guid:"""""",1:"guid") _ ") }") }
		elseif objectjournal = 3 { $$$GENERATE("	If $$$ISOK(sc) { $$$txJournal($classname(),jid,id,2) }") }
	}
		#; find out if there is a %OnDelete method. If there is, call it
	If $$$comMemberKeyGet(%class,$$$cCLASSmethod,"%OnAfterDelete",$$$cMETHrunnable) { $$$GENERATE("	if $$$ISOK(sc) { set sc=..%OnAfterDelete(oid) }") }
		#; Generate the streams that were queued up before %DeleteData
	if $Data(stream) {
		$$$GENERATE($Char(9)_"if $$$ISOK(sc) {")
		$$$GENERATE($Char(9,9)_"set tPtr = """" For { set tPtr=$order(^||%isc.strd(tPtr),1,tStreamData) Quit:tPtr=""""  Set stream=$li(tStreamData,1),cls=$li(tStreamData,2),sc=$classmethod(cls,""%Delete"",stream,concurrency) If $$$ISERR(sc) Quit }")
		$$$GENERATE($Char(9,9)_"Kill ^||%isc.strd")
		$$$GENERATE($Char(9)_"}")
	}
	if tDSTIME = 1 { $$$GENERATE($Char(9)_"$$$DSTIME($classname(),id,2)") }
	elseif tDSTIME = 2 { $$$GENERATE($Char(9)_"$$$DSTIMEH($classname(),id,2,"_$Select(tDSINTERVAL:tDSINTERVAL,1:1)_",tDST,tDSS)") }
	#; ##ENDEVENT: DELETEDATA
	If objectjournal { $$$GENERATE("%DeleteEnd"_$select($Data(stream):" if $$$ISERR(sc) { kill ^||%isc.strd }",1:"")_" If traninit { If $$$ISOK(sc) { $$$txCommitJrn } Else { $$$txRollbackJrn(sc) } }") }
	Else { $$$GENERATE("%DeleteEnd"_$select($Data(stream):" if $$$ISERR(sc) { kill ^||%isc.strd }",1:"")_" If traninit { If $$$ISOK(sc) { $$$txCommit } Else { $$$txRollback(sc) } }") }
	$$$GENERATE("	Quit sc")
	$$$GENERATE("%DeleteERR	Set $ZTrap="""", sc=$$$ERROR($$$CacheError,$ZE) goto %DeleteEnd")
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteOID">
<Description>
Internal method to remove a previously assigned oid only to be used when deleting an object that is also in memory.</Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If i%%Concurrency>2 Set sc=..%ReleaseLock($select(i%%Concurrency=3:"s",1:"e"))
	Set oid=i%"%%OID"
	$$$txUnAssignOIDSaveModState($this,oid) Do $system.CLS.SetModified(1) Set i%"%%OID"="" $$$ActiveOidRemove(oid,oref)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteId">
<Description><![CDATA[
Deletes the stored version of the object with ID <var>id</var> from the database. 

<p><METHOD>%DeleteId</METHOD> is identical in operation to the <METHOD>%Delete</METHOD> method except 
that it uses an Id value instead of an OID value to find an object.

Refer to <LINK href=../docbook/AboutConcurrency.html>About Concurrency</LINK> for more details 
on the optional <var>concurrency</var> argument.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>id:%String,concurrency:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[..%Delete($$$oidForm(id),.concurrency)
]]></Implementation>
</Method>

<Method name="%DeleteExtent">
<Description><![CDATA[
Delete all instances of this class from its extent. On exit <var>instancecount</var> 
contains the original number of instances while <var>deletecount</var> contains 
the number of instances actually deleted.

<p>Internally, <METHOD>%DeleteExtent</METHOD> iterates over the set of instances in the 
collection and invokes the <METHOD>%Delete</METHOD> method.

Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
on the optional <var>concurrency</var> argument.

The option <var>pInitializeExtent</var> argument allows the user to override the default behavior
of calling <method>%KillExtent</method> when all instances are successfully deleted. <method>%KillExtent</method>
is called by default when the extent is empty so that empty globals can be killed. If <method>%KillExtent</method>
is not called then some empty globals can remain as well as the ID counter if it exists. The default value for <var>pInitializeExtent</var>
is 1. Unless the caller specifies a false value for <var>pInitializeExtent</var> the globals used by the extent will be killed. In some
cases, the globals used by the extent are not used exclusively by the extent. In those cases it is possible that some globals will still be defined
even when pInitializeExtent is true.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[concurrency:%Integer=-1,&deletecount,&instancecount,pInitializeExtent:%Integer=1,*errorLog:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	Set deletecount=0,instancecount=0,errorLog = $$$OK
	If $system.CLS.IsMthd("ExtentExecute") {
		Set sc=..ExtentExecute(.qh) If $$$ISERR(sc) Quit sc
	} Else {
		Quit $$$OK
	}
	For  Set sc=..ExtentFetch(.qh,.row,.atend) Quit:$select(row="":1,$$$ISERR(sc):1,1:0)  Set id=$listget(row) If id'="" Set sc=..%Delete($listbuild(id),concurrency) Set instancecount=instancecount+1 set:$$$ISERR(sc) errorLog=$$$ADDSC(errorLog,sc) Set:$$$ISOK(sc) deletecount=deletecount+1 Quit:atend
	Do ..ExtentClose(qh)
	If instancecount = deletecount { if pInitializeExtent { do ..%KillExtent(0) } set sc = $$$OK } else { set sc = $$$ERROR($$$DeleteExtentObjectsRemain,$$$objClass) }
	Quit sc
]]></Implementation>
</Method>

<Method name="%DowngradeConcurrency">
<Description><![CDATA[
Changes the concurrency level of an instance in memory to a lower level 
by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's 
instance. Fails if it cannot lower the concurrency level.

Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
on the <var>concurrency</var> argument.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>concurrency:%Integer(MINVAL=0,MAXVAL=4)=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	If (concurrency > 4) || (concurrency < 0) || (concurrency '= (concurrency\1)) Quit $$$ERROR($$$ConcurrencyValueInvalid)
	Set current=i%%Concurrency
	#; If the requested setting is greater or equal to the current setting, then do nothing
	If concurrency'<current Quit $$$OK
	#; Locks are not retained for any setting less than 3 and if the old and new
	#; setting are the same, nothing is to done except update the concurrency setting
	If current<3 Set modstate=$system.CLS.GetModifiedBits(),i%%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate) Quit $$$OK
	#; Get the new lock if needed
	If concurrency>2 Set sc=..%AcquireLock($select(concurrency=3:"s",1:"e")) Quit:$$$ISERR(sc) sc
	#; the following line releases the old lock which we know must be there
	#; because we process and quit above for current<3
	Do ..%ReleaseLock($select(current=3:"s",1:"e"))
	#; Update the concurrency setting:
	Set modstate=$system.CLS.GetModifiedBits(),i%%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%ExecuteBeforeTriggers">
<Description>
Returns a %Status value</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[%oper,pOid:%Library.ObjectIdentity="",&pNew:%String(MAXLEN=""),&pOld:%Library.Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	if ($$$comMemberNext(%class,$$$cCLASStrigger,"") '= "") && ($$$getClassType(%class) = $$$cCLASSCLASSTYPEPERSISTENT ) && ( '$$$comClassKeyGet(%class,$$$cCLASSnoextent) ) {
		$$$tMetadataUses("PrecompileTriggerCode^%occTrigger(%class)")
		merge %code = $$$tMetadata("c","%ExecuteBeforeTriggers")
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%ExecuteAfterTriggers">
<Description>
Returns a %Status value</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[%oper,pOid:%Library.ObjectIdentity="",&pNew:%String(MAXLEN=""),&pOld:%Library.Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	if ($$$comMemberNext(%class,$$$cCLASStrigger,"") '= "") && ($$$getClassType(%class) = $$$cCLASSCLASSTYPEPERSISTENT ) && ( '$$$comClassKeyGet(%class,$$$cCLASSnoextent) ) {
		$$$tMetadataUses("PrecompileTriggerCode^%occTrigger(%class)")
		merge %code = $$$tMetadata("c","%ExecuteAfterTriggers")
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Id">
<Description><![CDATA[
Returns the persistent object Id, if there is one, of this object. 
<p>Returns a null string if there is no object Id.]]></Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[$$$idCurrent
]]></Implementation>
</Method>

<Method name="%IdSet">
<Description><![CDATA[
Assigns a persistent object Id value for this object. 
This method fails if the object already has an Id value assigned to it.
<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
 	Set class=$classname(),class=$$$DenormalizeClassname(class),oid=$$$oidCompose(id,class)
	#; Check for previously assigned OID
	If i%"%%OID"'="",i%"%%OID"'=oid Quit $$$ERROR($$$OidPreviouslyAssigned,$classname(),id)
	#; store oid and allow lookup based on oid
	Set i%"%%OID"=oid $$$ActiveOidInsert(oid,$this)
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
 Returns the OID of this object. The force parameter determines additional actions.
 force = 0 - return the OID as is currently exists, nothing else.
         1 - perform a %Save(0) and return the OID
         2 - perform a %Save(1) and return the OID
*/
]]></Content>
</UDLText>

<Method name="%GetSwizzleObject">
<Description><![CDATA[
<METHOD>%GetSwizzleObject</METHOD> is used to obtain a state of the object that can 
later be used to restore the object. In the case of a persistent object, it returns the OID.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Final>1</Final>
<FormalSpec><![CDATA[force:%Integer=0,&oid:%ObjectIdentity]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set oid="" If force=0 Set oid=i%"%%OID" Quit $$$OK
	If force=2 Set sc=..%Save(1) Set:$$$ISOK(sc) oid=i%"%%OID" Quit sc
	Set oid=i%"%%OID" Quit:oid'="" $$$OK
	Set sc=..%Save(0) Set:$$$ISOK(sc) oid=i%"%%OID"
	Quit sc
]]></Implementation>
</Method>

<Method name="%Oid">
<Description>
Returns the OID of this object.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<ReturnType>%ObjectIdentity</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[i%"%%OID"
]]></Implementation>
</Method>

<Method name="%ComposeOid">
<Description><![CDATA[
%ComposeOid()

		This class method accepts an ID and returns a fully qualified OID, containing the most specific type class of the object identified by the
		<var>id</var> argument. If default storage is used then the %%CLASSNAME value is used to determine the most specific type class, otherwise call
		%OnDetermineClass to determine the most specific type class. If neither case is true then the current class is
		used. If there is a problem determining the most specific type class then null ("") is returned.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>id:%String(MAXLEN="")</FormalSpec>
<Implementation><![CDATA[
	if ($$$getClassType(%class) '= $$$cCLASSCLASSTYPEPERSISTENT) || ($$$comClassKeyGet(%class,$$$cCLASSnoextent)) { kill %code quit $$$OK }
	set tRoot = $$$EXTrootclass($$$pEXT,%class), package = $$$ClassPackageName(%class), tCLASSNAMEGet = $Get($$$EXTPROPondisk($$$pEXT,%class,"%%CLASSNAME"))
	If tRoot && ($$$comClassKeyGet(%class,$$$cCLASSfinal)) { $$$GENERATE("	Quit $$$oidCompose(id,$classname())") Quit $$$OK }
	if tCLASSNAMEGet '= "" {
		If tRoot { Set tRootpackage = package,tRootclass = %class }
		Else {
			Set tRootclass = $$$EXTroot($$$pEXT,%class)
			While (tRootclass '= "") && ('$$$EXTrootclass($$$pEXT,tRootclass)) {
				Set tRootclass = $Get($$$EXTroot($$$pEXT,tRootclass))
			}
				If tRootclass '= "" { Set tRootpackage = $$$ClassPackageName(tRootclass) }
		}
		$$$GENERATE("	set tCLASSNAME = "_tCLASSNAMEGet)
		if tRoot {
			$$$GENERATE("	if tCLASSNAME="""" { quit $$$oidCompose(id,"""_tRootclass_""") }")
		} else {
			$$$GENERATE("	Set tClass=$classname(),tClass=$select(($extract(tClass,1,5)=""User."")&&($length(tClass,""."")=2):$piece(tClass,""."",2),1:tClass)")
			$$$GENERATE("	if tCLASSNAME'[($extract(tCLASSNAME)_tClass_$extract(tCLASSNAME)) Quit """"")
		}
		$$$GENERATE("	set tClass=$piece(tCLASSNAME,$extract(tCLASSNAME),*-1)")
		$$$GENERATE("	set:tClass'[""."" tClass=""User.""_tClass")
		$$$GENERATE("	quit $$$oidCompose(id,tClass)")
	} else {
		$$$GENERATE("	set tSC = ..%OnDetermineClass(id,.tClass)")
		$$$GENERATE("	quit $Select($$$ISOK(tSC):$$$oidCompose(id,tClass),1:"""")")
	}
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%Open">
<Description><![CDATA[
Loads an object from the database into memory and returns an OREF referring to the object. 
<var>oid</var> is the OID value of the object to load. If <var>oid</var> is a partially-formed OID, 
that is it does not include a class name, then <METHOD>%Open</METHOD> does the following: 
a) calls the method, <METHOD>%OnDetermineClass</METHOD>, 
to determine the class name, otherwise b) it assumes the class name is 
the same as the object class on which <METHOD>%Open</METHOD> was called.
<p>If a version of the specified object is already in memory, then <METHOD>%Open</METHOD> increments 
the object's reference count and returns the OREF value referring to this version.
<METHOD>%Open</METHOD> also has an optional concurrency argument which specifies the concurrency setting 
for this object (and sets the value of the <var>%Concurrency</var> attribute). If the 
<var>concurrency</var> argument is omitted then the system default value (1: <i>Atomic</i>) is used.

Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details 
on the optional <var>concurrency</var> argument.

<p><METHOD>%Open</METHOD> returns an OREF value that refers to the in-memory object instance or 
a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[oid:%ObjectIdentity,concurrency:%Integer=-1,&sc:%Status=$$$OK]]></FormalSpec>
<ReturnType>%ObjectHandle</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	#; if not passed an initial state, quit with error
	If $$$oidPrimary($g(oid))="" Set sc = $$$ERROR($$$NullOid,$classname()) Quit $$$NULLOREF
	If concurrency = -1 Set concurrency=$select(..#DEFAULTCONCURRENCY="$zu(115,10)":$zu(115,10),1:$xecute("Quit "_..#DEFAULTCONCURRENCY))
	If (concurrency > 4) || (concurrency < 0) || (concurrency '= (concurrency\1)) Set sc = $$$ERROR($$$ConcurrencyValueInvalid) Quit $$$NULLOREF
	Set $Ztrap = "Catch"
	Set class=$$$oidClassName(oid)
	#; if class name is not present in oid, we must call the class method %OnDetermineClass
	If class="" {
		Set sc=..%OnDetermineClass(oid,.class) If $$$ISERR(sc) Goto exit
		Set oid=$$$oidInsertClassName(oid,class)
	} Else {
		Set class=$$$NormalizeClassname(class)
	}
	#; see if we should reuse an existing object
	$$$ActiveOidSearch(oid,oref)
	If $isobject(oref)=1 { If concurrency>oref.%Concurrency { If (oref.%Concurrency<3) && (concurrency > 2) { Set reload = 1 } Else { Set reload = 0 } Set sc=oref.%UpgradeConcurrency(concurrency) If (reload) && ($$$ISOK(sc)) { Set sc=oref.%Reload() } If $$$ISERR(sc) { Quit $$$NULLOREF } } Else { Set sc = $$$OK } Quit oref }
	Set oref=$$$CreateObject(class) If oref=$$$NULLOREF Set sc = $$$ERROR($$$AbstractClassNotInstantiable,class) Quit oref
	Set sc=oref.%LoadInit(oid,concurrency) If $$$ISERR(sc) Quit $$$NULLOREF
	Set sc=oref.%LoadData($$$oidPrimary(oid)) If $$$ISERR(sc) Quit $$$NULLOREF
	#; set object as not modified
	Do $system.CLS.SetModified(oref,0)
	#; find out if there is a %OnOpen method. If there is a %OnOpen, call it
	If $system.CLS.IsMthd(oref,"%OnOpen") Set sc=oref.%OnOpen() If $$$ISERR(sc) Quit $$$NULLOREF
	Quit oref
Catch	Set $ZTrap = ""
	If '$$$ISOK($Get(sc)) { Quit $$$NULLOREF }
	Set sc = $Select($Extract($ZE,1,9)="<PROTECT>":$$$ERROR($$$InsufficientPrivilegeObjectAccess,$get(class,$classname())_"::%Open"),1:$$$ERROR($$$CacheError,$ZE))
exit	Quit $$$NULLOREF
]]></Implementation>
</Method>

<Method name="%ObjectIsNull">
<Description>
Return true if pOID is a null object and false if the object is not null</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOID:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If $isobject(pOID)=1 Set pOID=pOID."%%OID"
	if pOID = $$$NULLOID quit 1
	set class = $$$oidClassName(pOID)
	if class = "" { do ..%OnDetermineClass(pOID,.class) }
	if class '= "" {
		set class=$$$NormalizeClassname(class) if $classname()'=class quit $classmethod(class,"%ObjectIsNull",pOID)
	}
	quit $$$oidPrimary(pOID)=""
]]></Implementation>
</Method>

<Method name="%LoadInit">
<Final>1</Final>
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<FormalSpec>oid:%ObjectIdentity="",concurrency:%Integer="",reset:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; We should be somewhat stable now, set the %Concurrency attribute...
	$$$GENERATE("	If concurrency'="""" Set i%%Concurrency=concurrency")
	Set ivar="" For {
		Set ivar=$$$comMemberNext(%class,$$$cCLASSinstancevar,ivar) Quit:ivar=""
		Set qivar=$$$QN(ivar)
		If $$$comMemberKeyGet(%class,$$$cCLASSproperty,ivar,$$$cPROPmultidimensional) Set kill($i(kill))="i%"_$$$QN(ivar) Continue
		If $$$comMemberKeyGet(%class,$$$cCLASSproperty,ivar,$$$cPROPtransient),ivar'="%Concurrency",ivar'="%%OID" {
			Set set($i(set))="i%"_qivar_"="_$$$comMemberKeyGet(%class,$$$cCLASSinstancevar,ivar,$$$cIVARinitialexpression)
		}
		$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,ivar,$$$cPROPcollection)
		$$$comMemberKeyGetLvar(relationship,%class,$$$cCLASSproperty,ivar,$$$cPROPrelationship)
		If 'relationship,collection=$$$cPROPCOLLECTIONARRAY||(collection=$$$cPROPCOLLECTIONLIST) {
			Set kill($i(kill))="r%"_qivar,set($i(set))="i%"_qivar_"="""""
		}
		$$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,ivar,$$$cPROPruntimetype) 
		If $$$classIsDataType(runtimetype) Continue
		Set kill($i(kill))="i%"_qivar,set($i(set))="r%"_qivar_"="""""
	}
	If $get(kill) {
		$$$GENERATE("	If reset {")
		Set kills=""
		For i=1:1:kill {
			Set kills=kills_kill(i)_","
			If i#10=0 $$$GENERATE("		Kill "_$extract(kills,1,*-1)) Set kills=""
		}
		If kills'="" $$$GENERATE("		Kill "_$extract(kills,1,*-1))
		$$$GENERATE("	}")
	}
	Set sets=""
	For i=1:1:$get(set) {
		Set sets=sets_set(i)_","
		If i#10=0 $$$GENERATE("	Set "_$extract(sets,1,*-1)) Set sets=""
	}
	If sets'="" $$$GENERATE("	Set "_$extract(sets,1,*-1))
	$$$GENERATE("	If 'reset { Set i%""%%OID""=oid If oid'="""" { $$$ActiveOidInsert(oid,$this) } }")
	$$$GENERATE("	Quit $$$OK")
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%OpenId">
<Description><![CDATA[
Loads an object from the database into memory and returns an OREF referring to the object. 
<var>id</var> is the Id (not a full OID) value of the object to load.

<p><METHOD>%OpenId</METHOD> is identical in operation to the <METHOD>%Open</METHOD> method except 
that it uses an Id value instead of an OID value to find an object instance.

Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
on the optional <var>concurrency</var> argument.

<p><METHOD>%OpenId</METHOD> returns an OREF value that refers to the in-memory object instance or 
a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[id:%String="",concurrency:%Integer=-1,&sc:%Status=$$$OK]]></FormalSpec>
<ReturnType>%ObjectHandle</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[..%Open($$$oidForm(id),.concurrency,.sc)
]]></Implementation>
</Method>

<Method name="%Reload">
<Description><![CDATA[
<p>%Reload is an instance method that re-reads an object from disk into the 
current instance. Calling %Reload is similar to calling <METHOD>%Close</METHOD> and then 
<METHOD>%Open</METHOD>, but it uses the same OREF. %Open is not called and no %Open callbacks
are called.</p>
<p>After %Reload is called, there are no swizzled references for the object, 
and <METHOD>%IsModified</METHOD> returns 0.
</p>
<p>%Reload performs the following steps. First, all swizzled objects for the 
instance are unswizzled. Then the object is reloaded from disk, using the 
<METHOD>%Id</METHOD> of the current object. Finally, the modified bit for each property is 
cleared.
<p>]]></Description>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	If $$$idCurrent="" Quit $$$ERROR($$$NullOid,$classname())
	Set cur=i%%Concurrency,i%%Concurrency=0
	Set sc=..%LoadInit(,,1) If $$$ISERR(sc) Quit sc
	Set sc=..%LoadData($$$idCurrent) Set i%%Concurrency=cur If $$$ISERR(sc) quit sc
	if $system.CLS.IsMthd($this,"%OnReload") Set sc=..%OnReload() If $$$ISERR(sc) quit sc
	#; set object as not modified
	Do $system.CLS.SetModified(0)
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
 This method restores the modified information, from an array subscripted by oref, releases any owned locks and
 invokes a user-supplied method, %OnRollBack() if it exists.
*/
]]></Content>
</UDLText>

<Method name="%RollBack">
<Description><![CDATA[
This method is called by <METHOD>%Save</METHOD> when a transaction is rolled back. 
It will invoke a user-supplied <METHOD>%OnRollBack</METHOD> method if it exists.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If $data($$$txOIDASSIGNED(+$this)) Set oid=i%"%%OID" If oid'="" $$$ActiveOidRemove(oid,$this) Set i%"%%OID"=""
	If $data($$$txOIDUNASSIGNED(+$this),oid) If oid'="" Set i%"%%OID"=oid $$$ActiveOidInsert(oid,$this)
	if $Data($$$txVERSION($this)) {
			// Rollback the version property
		if ..#VERSIONPROPERTY '[ "." {
			set $property($this,..#VERSIONPROPERTY) = $$$txVERSION($this)
		} else {
			set versionProperty = $Piece(..#VERSIONPROPERTY,".",1)
			set $property($this,versionProperty) = ""
			do $method($this,versionProperty_"SetObject",$$$txVERSION($this))
		}
	}
	If $data($$$txMODIFIED($this)) Do $system.CLS.SetModifiedBits($$$txMODIFIED($this))
	#; if a %OnRollBack() method exists, return with it's value......
	If $system.CLS.IsMthd("%OnRollBack") Quit ..%OnRollBack()
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%Save">
<Description><![CDATA[
Stores an in-memory version of an object to disk. If the object was stored 
previously (and thus, already has an OID), <METHOD>%Save</METHOD> updates the on-disk version. 
Otherwise, <METHOD>%Save</METHOD> assigns a new OID to the object and saves it.

<p>The <var>related</var> argument specifies how <METHOD>%Save</METHOD> handles references to other objects. 
It can take the following values:
<table cols=2>
<tr>
<td width="33%" valign="top">0: <i>Shallow Save</i></td>
<td valign="top">
If this object has been modified then save it. Only save related objects if they have never been saved (do not have an OID value) and must be 
saved in order to serialize this object's property values.
</td>
</tr>

<tr>
<td width="33%" valign="top">1: <i>Deep Save</i></td>
<td valign="top">
Save this object and all "related" objects that have been edited. In this case, 
"related" means any in-memory objects it refers to, and any in-memory objects 
they in turn refer to, and so on. However, only objects that have been changed 
(<METHOD>%IsModified</METHOD> returns true) will actually be saved to the database, including 
the object upon which <METHOD>%Save</METHOD> was initially called.
</td>
</tr>
</table>

<p><METHOD>%Save</METHOD> automatically detects and handles circular references between objects. 
For example, <METHOD>%Save</METHOD> will detect if object A refers to object B and object B likewise refers to object A.
In this case it will avoid falling into an infinite, recursive loop.

<p>Note that either reference attribute, A to B or B to A, can be specified as a required attribute but not both of them.
If both reference attributes are required then <METHOD>%Save</METHOD> will fail.

<p>By default <METHOD>%Save</METHOD> automatically manages transactions. You can enable and disable 
automatic transaction support using the <code>$$SetTransactionMode^%apiOBJ()</code> routine.

<p>When <METHOD>%Save</METHOD> saves an object to the database, it initiates one transaction 
(by calling TSTART) for the entire set of saves, including the original object 
and any related objects. If the save operation is successful, <METHOD>%Save</METHOD> will issue a 
TCOMMIT command to commit the transaction and write the data to the database.
If <METHOD>%Save</METHOD> encounters a problem when saving the original object or any of its 
related objects, it rolls back the entire transaction and performs the following actions:
<ul>
<li>It issues a TROLLBACK command to rollback any changes to the database that may 
have occurred. (In the case of the <CLASS>%CacheStorage</CLASS> class, changes to the on-disk 
counter value, used to determine the next available object id number, are not rolled back.)</li>
<li>It restores the in-memory state of all the objects involved in the transaction to 
their pre-transaction state. This includes restoring any modified flags, and 
restoring to null ("") any OID values that have been assigned during the course of 
the transaction. Additional property values changed during the course of the 
transaction are not restored, however.</li>
<li>It calls the <METHOD>%RollBack</METHOD> method on each object involved with the transaction. 
The order in which the <METHOD>%RollBack</METHOD> methods are called is undefined. <METHOD>%RollBack</METHOD> will 
call a user-written <METHOD>%OnRollback</METHOD> method if it is present.</li>
</ul>

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Final>1</Final>
<CodeMode>generator</CodeMode>
<FormalSpec>related:%Integer=1</FormalSpec>
<GenerateAfter>%OnBeforeSave,%OnAfterSave</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
	If $$$getClassType(%class)'=$$$cCLASSCLASSTYPEPERSISTENT Quit $$$OK
	$$$comMemberKeyGetLvar(objectjournal,%class,$$$cCLASSparameter,"OBJJOURNAL",$$$cPARAMdefault)
	$$$comMemberKeyGetLvar(tDSTIME,%class,$$$cCLASSparameter,"DSTIME",$$$cPARAMdefault)
	if ($$$ucase(tDSTIME) = "AUTO") {
		$$$comMemberKeyGetLvar(tDSINTERVAL,%class,$$$cCLASSparameter,"DSINTERVAL",$$$cPARAMdefault)
		if tDSINTERVAL '> 0 { set tDSTIME = 1 } else { set tDSTIME = 2 }
	}
	else { set tDSTIME = 0 }
	#; Look to see if we need to construct a save set
	If ($$$comMemberKeyGet(%class,$$$cCLASSmethod,"%OnAddToSaveSet",$$$cMETHrunnable)) || (objectjournal) || $$$comMemberKeyGet(%class,$$$cCLASSparameter,"GUIDENABLED",$$$cPARAMdefault) {
		Set simple=0
	} Else {
		#; Look to see this this is a 'literal' object with no references to other objects
		Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,""), simple = 1
		While prop '= "" {
			$$$comMemberKeyGetLvar(runtimetype,%class,$$$cCLASSproperty,prop,$$$cPROPruntimetype)
				#; do nothing if property is a datatype or isn't storable
			If ($$$getClassType(runtimetype) '= $$$cCLASSCLASSTYPEDATATYPE) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPcalculated)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPmultidimensional)) Set simple=0 Quit
			Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,prop)
		}
	}
		#; Initialize the transaction state
		#; This method is a transaction itself and isn't called recursively. Therefore, the
		#; SaveSet state variable - %objTX - is new'ed here.
	$$$GENERATE("	Set $ZTrap=""%SaveERR""")
	$$$GENERATE("	New %objTX Set sc=$$$OK,traninit=0 If '$data(%objTX2) New %objTX2 Set %objTX2=1")
		#; If already in %Save, just build a shallow graph and serialize the object
		#; %TStart - Start a transaction if one doesn't exist and $zu(115,9) is on
		#; %TInclude - include this oref in the current transaction...
	$$$GENERATE("	If $$$txNOTINTRAN { Set traninit=1 $$$txBeginTran"_$select(objectjournal:"Jrn",1:"")_" }")
	If simple {
		Set runtimeclasstype=$$$getClassType(%class)
		#; If we call %OnBeforeSave/%OnAfterSave we need part of save set created if we are also persistent
		set onAfter = $$$comMemberKeyGet(%class,$$$cCLASSmethod,"%OnAfterSave",$$$cMETHrunnable), onBefore = $$$comMemberKeyGet(%class,$$$cCLASSmethod,"%OnBeforeSave",$$$cMETHrunnable), tTriggered = 0
		if (runtimeclasstype=$$$cCLASSCLASSTYPEPERSISTENT) && '(onAfter + onBefore) {
			set prop = $$$comMemberNext(%class,$$$cCLASSproperty,"")
			While prop '= "" {
				if $$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPsqlcomputed) {
					if $$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPsqlcomputeonchange) [ "%%" { set tTriggered = 1 quit }
				}
				Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,prop)
			}
		}
		if (onBefore) || (onAfter) || (tTriggered) || (tDSTIME) {
			If runtimeclasstype=$$$cCLASSCLASSTYPEPERSISTENT {
				$$$GENERATE("	Set %objTX(1,+$this,1)=i%""%%OID"",%objTX(1,+$this)=$this,%objTX(1,+$this,4)=$select(%objTX(1,+$this,1)="""":1,..%ExistsId($$$oidPrimary(%objTX(1,+$this,1))):0,1:1)")
			}
		}
		If runtimeclasstype=$$$cCLASSCLASSTYPEPERSISTENT {
			$$$GENERATE("	If ..%ObjectModified() Set sc=..%SerializeObject(i%""%%OID"") If $$$ISERR(sc) ZTrap ""SG""")
		} ElseIf runtimeclasstype=$$$cCLASSCLASSTYPESERIAL {
			$$$GENERATE("	If ..%ObjectModified() Set sc=..%SerializeObject("""") If $$$ISERR(sc) ZTrap ""SG""")
		} Else {
			$$$GENERATE("	Set sc=..%SerializeObject("""") If $$$ISERR(sc) ZTrap ""SG""")
		}
	} Else {
		$$$GENERATE("	If $get(%objTX2(+$this)) Set sc=..%BuildObjectGraph(1) Quit:$$$ISERR(sc) sc Set intRef=+$this,objValue=$get(%objTX(1,intRef,1)),sc=..%SerializeObject(.objValue,1) Set:$$$ISOK(sc) %objTX(1,intRef,1)=objValue Quit sc")
		$$$GENERATE("	Set sc=..%BuildObjectGraph(related+2) If $$$ISERR(sc) ZTrap ""SG""")
			#; At this point, %objTX(2) contains a list of all objects that need to be saved
		$$$GENERATE("	If '$data(%objTX(2)) s sc=$$$OK GoTo %SaveCOMMIT")
			#; First, examine the objects designated to be saved to see if any have zero predecessors
		$$$GENERATE("	Set %objTX(3)=0,intRef="""" For  Set intRef=$order(%objTX(2,intRef)) Quit:intRef=""""  If '$data(%objTX(1,intRef,2)) Set %objTX(3,$increment(%objTX(3)))=%objTX(1,intRef) Kill %objTX(2,intRef)")
			#; Process the AOV. Calls to %SerializeObject here are complete serializations. If one fails, the TX needs to fail
		$$$GENERATE("	For ptr=1:1 Quit:ptr>%objTX(3)  Set objRef=%objTX(3,ptr),objValue=$get(%objTX(1,+objRef,1)),sc=objRef.%SerializeObject(.objValue) Do  Set %objTX(1,+objRef,1)=objValue Kill %objTX(1,+objRef,3) Do $system.CLS.SetModified(objRef,0)")
		$$$GENERATE("	. If $$$ISERR(sc) ZTrap ""SG""")
			#; Process the mod bits for potential tx rollback
		$$$GENERATE("	. $$$txSaveModState(objRef)")
			#; visit the successors
		$$$GENERATE("	. Set intSucc="""" For  Set intSucc=$order(%objTX(1,+objRef,3,intSucc)) Quit:intSucc=""""  Kill %objTX(1,+objRef,3,intSucc),%objTX(1,intSucc,2,+objRef) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$increment(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)")
			#; If any objects are remaining in the graph then do a 'partial serialization' of the persistent objects that are
			#; designated as 'predecessors'. Any objects remaining in the graph following partial serialization represent unresolvable cycles. 
		$$$GENERATE("	Kill %objTX(3) Set %objTX(3)=0 For  Set pserial=0 Do  Quit:'pserial")
		$$$GENERATE("	. Set intRef="""" For  Set intRef=$order(%objTX(2,intRef)) Quit:intRef=""""  Set intPred="""" For  Set intPred=$order(%objTX(1,intRef,2,intPred)) Quit:intPred=""""  If $get(%objTX(1,intPred,6))=1 Set objValue=$get(%objTX(1,intPred,1)),sc=(%objTX(1,intPred)).%SerializeObject(.objValue,1) s:$$$ISERR(sc) %objTX(2,intPred,1)=sc If $$$ISOK(sc) Set pserial=1,%objTX(1,intPred,1)=objValue Do")
			#; Visit the successors of this 'forced' ID assignment. If all predecessors are visited then add to the stack
		$$$GENERATE("	. . Set intSucc="""" For  Set intSucc=$order(%objTX(1,intPred,3,intSucc)) Quit:intSucc=""""  Kill %objTX(1,intPred,3,intSucc),%objTX(1,intSucc,2,intPred) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$i(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)")
			#; Again, process the AOV. Calls to %SerializeObject here are complete serializations. If one fails, the TX needs to fail
		$$$GENERATE("	. . For ptr=1:1 Quit:ptr>%objTX(3)  Set objSerialize=%objTX(3,ptr),objValue=$get(%objTX(1,+objSerialize,1)),sc=objSerialize.%SerializeObject(.objValue) Do  Set %objTX(1,+objSerialize,1)=objValue Kill %objTX(1,+objSerialize,3) Do $system.CLS.SetModified(objSerialize,0)")
		$$$GENERATE("	. . . If $$$ISERR(sc) ZTrap ""SG""")
			#; Process the mod bits for potential tx rollback
		$$$GENERATE("	. . . $$$txSaveModState(objSerialize)")
			#; visit the successors
		$$$GENERATE("	. . . Set intSucc="""" For  Set intSucc=$order(%objTX(1,+objSerialize,3,intSucc)) Quit:intSucc=""""  Kill %objTX(1,+objSerialize,3,intSucc),%objTX(1,intSucc,2,+objSerialize) If '$data(%objTX(1,intSucc,2)) Set %objTX(3,$i(%objTX(3)))=%objTX(1,intSucc) Kill %objTX(2,intSucc)")
		$$$GENERATE("	. . Kill %objTX(3) Set %objTX(3)=0")

		$$$GENERATE("	If $data(%objTX(2))>2 {")
		$$$GENERATE("		Set sc=$$$ERROR($$$SaveCyclicDependancy,$classname())")
		$$$GENERATE("		set intRef="""" for  set intRef=$order(%objTX(2,intRef)) quit:intRef=""""  if $$$ISERR($Get(%objTX(2,intRef,1),1)) set sc=$$$EMBEDSC(sc,%objTX(2,intRef,1))")
		$$$GENERATE("	 	ZTrap ""SG""")
		$$$GENERATE("	}")
	}
	$$$GENERATE("	Set cmd="""" For  Set cmd=$order(%objTX(9,cmd)) Quit:cmd=""""  Xecute cmd")
		#; Commit the transaction and cleanup
	$$$GENERATE("%SaveCOMMIT	If traninit { $$$txCommit"_$select(objectjournal:"Jrn",1:"")_" }")
	$$$GENERATE("	Do $system.CLS.SetModified(0) Quit sc")
	$$$GENERATE("%SaveERR	Set $ZTrap="""" If $extract($zerror,1,5)'=""<ZSG>"" Set sc=$$$ERROR($$$CacheError,$ZE)")
	$$$GENERATE($Char(9)_"If $get(traninit) { $$$txRollback"_$select(objectjournal:"Jrn",1:"")_"(sc) }")
	$$$GENERATE("	Quit sc")
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%UpgradeConcurrency">
<Description><![CDATA[
Elevates the concurrency level of an instance in memory to a higher level 
by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's 
instance. Fails if it cannot elevate the concurrency level.

Refer to <LINK href=/AboutConcurrency.html>About Concurrency</LINK> for more details 
on the <var>concurrency</var> argument.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>concurrency:%Integer(MINVAL=0,MAXVAL=4)=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	If (concurrency > 4) || (concurrency < 0) || (concurrency '= (concurrency\1)) Quit $$$ERROR($$$ConcurrencyValueInvalid)
	#; Locks are not retained for any setting
	#; less than 3 and if the old and new
	#; setting are the same, nothing is to done!
	Set current=i%%Concurrency
	Quit:concurrency'>current $$$OK
	If concurrency<3 Set modstate=$system.CLS.GetModifiedBits(),i%%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate) Quit $$$OK
	#; Get the new lock
	Set sc=..%AcquireLock($select(concurrency=3:"s",1:"e")) Quit:$$$ISERR(sc) sc
	#; the following line releases the old lock
	#; which must be a shared lock as that is the
	#; only possible condition.
	If current=3 Do ..%ReleaseLock("s")
	#; Update the concurrency setting:
	Set modstate=$system.CLS.GetModifiedBits(),i%%Concurrency=concurrency Do $system.CLS.SetModifiedBits(modstate)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%AcquireLock">
<Description><![CDATA[
Acquires a lock for the current instance.

<p>The <var>locktype</var> argument specifies the type of lock to acquire.
It can take the following values:
<table cols=2>
<tr>
<td width="33%" valign="top">"e": <i>Exclusive</i></td>
<td valign="top">
An exclusive lock will prevent any other process from acquiring any type of lock
on this object.
</td>
</tr>

<tr>
<td width="33%" valign="top">"s": <i>Shared</i></td>
<td valign="top">
A shared lock will allow other processes to acquire shared locks but will
prevent other processes from acquiring an exclusive lock.
</td>
</tr>
</table>

Fails if the locktype parameter is not one of the values described above.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>locktype:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[..%LockId($$$idCurrent,$s($e(locktype)="s":1,1:0))
]]></Implementation>
</Method>

<Method name="%ReleaseLock">
<Description><![CDATA[
Releases a lock for the current instance.

<p>The <var>locktype</var> argument specifies the type of lock to release.
It can take the following values:
<table cols=2>
<tr>
<td width="33%" valign="top">"e": <i>Exclusive</i></td>
<td valign="top">
An exclusive lock will prevent any other process from acquiring any type of lock
on this object.
</td>
</tr>

<tr>
<td width="33%" valign="top">"s": <i>Shared</i></td>
<td valign="top">
A shared lock will allow other processes to acquire shared locks but will
prevent other processes from acquiring an exclusive lock.
</td>
</tr>
</table>

Fails if the locktype parameter is not one of the values described above.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>locktype:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[..%UnlockId($$$idCurrent,$s($e(locktype)="s":1,1:0),$s($e(locktype,2)="i":1,1:0))
]]></Implementation>
</Method>

<Method name="%LockExtent">
<Description><![CDATA[
%LockExtent acquires a lock on the entire extent of the class. If <var>shared</var> is true then a shared lock
is acquired, otherwise an exclusive lock is acquired. If the requested lock cannot be acquired then a failure
%Status value is returned. The default implementation returns an error indicating that the method is not implemented.
This method is automatically generated for persistent classes using <class>%Library.CacheStorage</class> and
<class>%Library.CacheSQLStorage</class>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>shared:%Boolean=0</FormalSpec>
<PlaceAfter>%LockId</PlaceAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%LockExtent")
]]></Implementation>
</Method>

<Method name="%UnlockExtent">
<Description><![CDATA[
%UnlockExtent releases a lock on the entire extent of the class. If <var>shared</var> is true then a shared lock
is acquired, otherwise an exclusive lock is acquired. If the requested lock cannot be acquired then a failure
%Status value is returned. The default implementation returns an error indicating that the method is not implemented.
This method is automatically generated for persistent classes using <class>%Library.CacheStorage</class> and
<class>%Library.CacheSQLStorage</class>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<PlaceAfter>%LockExtent</PlaceAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%UnlockExtent")
]]></Implementation>
</Method>

<Method name="%LockId">
<Description><![CDATA[
Obtain an exclusive or shared lock on the object identified by <var>id</var>. The type
of lock obtained is determined by <var>shared</var>. This method is normally generated by
the storage class for persistent classes using <class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	Set sc=..%OnDetermineClass($$$oidForm(id),.class) If $$$ISERR(sc) Quit sc
	If class'="",class'=$classname() Quit $classmethod(class,"%LockId",id,shared,.timeout)
	QUIT $$$ERROR($$$MethodNotImplemented,$classname()_"::%LockId")
]]></Implementation>
</Method>

<Method name="%UnlockId">
<Description><![CDATA[
Release an exclusive or shared lock on the object identified by <var>id</var>. The type
of lock released is determined by <var>shared</var>. If this method is not overridden
then the default implementation returns an error. This method is normally generated by
the storage class for persistent classes using <class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	Set sc=..%OnDetermineClass($$$oidForm(id),.class) If $$$ISERR(sc) Quit sc
	If class'="",class'=$classname() Quit $classmethod(class,"%UnlockId",id,shared)
	QUIT $$$ERROR($$$MethodNotImplemented,$classname()_"::%UnlockId")
]]></Implementation>
</Method>

<Method name="%GetLock">
<Description>
This method acquires a lock on the object identified by 'id'. If the number of locks
already taken out for this extent is greater than the configured maximum then the lock
will be escalated to an extent-level lock. If the lock is successfully obtained a 1 will
be returned, 2 will be returned if the lock was escalated to an extent-level lock. A zero, '0',
is returned if the method failed to obtain a lock.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set sc=..%OnDetermineClass($$$oidForm(id),.class) If $$$ISERR(sc) Quit 0
	If class'="",class'=$classname() Quit $classmethod(class,"%GetLock",id,shared)
	If $tlevel,$increment(%0CacheLock($classname()))>$zutil(115,6) { If $$$ISOK(..%LockExtent(shared)) { Quit 2 } Else { Quit 0 } } Quit:$$$ISOK(..%LockId(id,shared)) 1
	Quit 0
]]></Implementation>
</Method>

<Method name="%BuildIndices">
<Description><![CDATA[
<p>Builds entries for each index specified in the <var>pIndexList</var> argument.
If <var>pIndexList</var> is empty then all indices that originate in the class are rebuilt.
If there are other bitmap indexes specified in <var>pIndexList</var> 
and there is a bitmap extent index defined for the class
then it will be implicitly included in <var>pIndexList</var>. If the bitmap 
extent index is included then the bitmap extent index for each subextent is also built. </p>

<p>If <var>pAutoPurge</var> is true then the indices contained in <var>pIndexList</var> will be
purged before they are built as long as no range is specified, if a range is specified we will
skip any purge. The default is TRUE (1).</p>

<p>If <var>pLockFlag</var> is one (1) then an extent lock will be acquired before the indices
are built. If the lock cannot be acquired then an error is returned. The lock is released
after the index build is completed. If <var>pLockFlag</var> is two (2) then a lock is acquired prior to filing 
indices for that instance and it is released as soon the indices for that instance are filed. 
If it is zero (0) then no locks are used while filing the indices. If it is three (3) then a 
shared extent lock will be acquired before the indices are built and released upon completion.</p>

<p>If <var>pJournalFlag</var> is false then journaling is disabled for the processes used to build the 
indices (except where the database is in a Mirror). If this flag is true then the journal status is not altered during BuildIndices(). 
The default value of this argument is 1 (TRUE). </p> 

<p><var>pStartID</var> and <var>pEndID</var> define a range of IDs for which indices will be built. 
The range is inclusive. If the starting ID is null then the range begins at the 
first ID defined in the extent. If the ending ID is null then the range ends at the 
last ID defined in the extent. </p>

<p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be built.
This argument allows you to build all indices except those defined in <var>pIgnoreIndexList</var>.
The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be built. </p> 

<p>If <method>%OnBeforeBuildIndices</method> is implemented and is runnable then it will be called
just prior to purging and building any index structures. Refer to <method>%OnBeforeBuildIndices</method>
for more information.</p>

<p>If <method>%OnAfterBuildIndices</method> is implemented and is runnable then it will be called
after all index structures have been built completely. Refer to <method>%OnAfterBuildIndices</method>
for more information.</p>

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.</p>

<p>If your index is corrupt running this function will not fix the corruption unless you rebuild the entire index
and purge the existing indexes. If you have inserted some new items but have deferred building the index for these
new items then you can run %BuildIndices on this range oif IDs to add the index entries for these new items.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndexList:%CacheString="",pAutoPurge:%Integer=1,pLockFlag:%Integer=0,pJournalFlag:%Integer=1,pStartID:%CacheString="",pEndID:%CacheString="",pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%BuildIndices")
]]></Implementation>
</Method>

<Method name="%BMEBuilt">
<Description><![CDATA[
On return, <var>bmeName</var> contains the name of the bitmap extent index for this class.
<p>Returns <CLASS>%Boolean</CLASS> TRUE is the bitmap extent has been built, FALSE if not.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&bmeName:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Method name="%CheckConstraintsForExtent">
<Description><![CDATA[
<p>
This method will loop over each object in the extent of the current class and invoke <method>%CheckConstraints</method>. 
If only selected constraints are to be checked then <var>pConstraintList</var> can be passed as a $list of the 
names of the constraints to be checked. All constraint failures are included in the returned %Status value, subject 
to the maximum <class>%Status</class> size. In addition, the output parameter <var>pErrorLog</var> contains up to 1,000 entries 
containing the object ID and the values of all properties that are referenced by constraints defined for the current class. 
The error log also adds the %Status value returned by %CheckConstraints() as the last $list element.
</p>
<p>
<pre>
SAMPLES>set status = ##class(Sample.Person).%CheckConstraintsForExtent(,,.errorlog)

SAMPLES>do $system.OBJ.DisplayError(status)                                       

ERROR #5808: Key not unique: Sample.Person.SSNKey
ERROR #5808: Key not unique: Sample.Person.SSNKey
SAMPLES>zw errorlog
errorlog=2
errorlog(1)=$lb(1,"798-92-1974","0 "_$lb($lb(5808,"Sample.Person.SSNKey",,,,,,,,"%CheckConstraints+7^Sample.Person.1:SAMPLES"))/* ERROR #5808: Key not unique: Sample.Person.SSNKey [%CheckConstraints+7^Sample.Person.1:SAMPLES] */)
errorlog(2)=$lb(100,"798-92-1974","0 "_$lb($lb(5808,"Sample.Person.SSNKey",,,,,,,,"%CheckConstraints+7^Sample.Person.1:SAMPLES"))/* ERROR #5808: Key not unique: Sample.Person.SSNKey [%CheckConstraints+7^Sample.Person.1:SAMPLES] */)
</pre>
</p>
<p>
<table border=1>
	<tr>
		<th colspan=3>
			Parameters
		</th>
	</tr>
	<tr>
		<th>Name</th>
		<th>Direction</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>pConstraintList</td>
		<td>Input</td>
		<td>A $list of constraints to be checked. If null then all constraints defined for the most specific type class 
			of each object will be checked. 
		</td>
	</tr>
	<tr>
		<td>pCheckDisabled</td>
		<td>Input</td>
		<td>If this value is passed as a true value (1) then %CheckConstraints will also check any constraints that are 
			defined as %NOCHECK. 
		</td>
	</tr>
	<tr>
		<td>pErrorLog</td>
		<td>Output</td>
		<td>
			This is an array of up to 1,000 entries containing error information reported by <method>%CheckConstraints</method>.
		</td>
	</tr>
	<tr>
		<td></td>
		<td>Return</td>
		<td>
			%Status return value. This value contains %Status values for each constraint that failed. If no errors are 
			reported then %Status will be $$$OK. 
		</td>
	</tr>
</table>
</p>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pConstraintList:%String(MAXLEN="")="",pCheckDisabled:%Integer=0,*pErrorLog:%String(MAXLEN="")</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		kill %code
		if ($$$getClassType(%class) = $$$cCLASSCLASSTYPEPERSISTENT) && ('$$$comClassKeyGet(%class,$$$cCLASSnoextent)) {
			do generateCheckExtent^%occConstraint(%class,.%code)
		}
		set tStatus = $$$OK
	}
	catch tException {
		set tStatus = tException.AsStatus()
	}
	QUIT tStatus
]]></Implementation>
</Method>

<Method name="%CheckConstraints">
<Description><![CDATA[
<p>
This method checks the constraints defined in the current class for one object, identified by <var>pID</var>. 
If only selected constraints are to be checked then <var>pConstraintList</var> can be passed as a $list of the 
names of the constraints to be checked. If any constraint fails then the failure status will be included in the 
returned %Status value. In addition, the output parameter <var>pErrorInfo</var> will contain the object ID and 
the values of all properties that are referenced by constraints defined for the current class. 
</p>
<p>
If the current class is not the most specific type class (MSTC) of the object identified by <var>pID</var>, then this method 
will dispatch to the object's most specific type class. Note that if you do not pass a constraint list then all 
constraints present for the MSTC are checked, which may include others in addition to those present for the current class. 
</p>
<p>
<pre>
SAMPLES>set status = ##class(Sample.Person).%CheckConstraints(1,,,.errorinfo)

SAMPLES>do $system.OBJ.DisplayError(status)                                 

ERROR #5808: Key not unique: Sample.Person.SSNKey
SAMPLES>zw errorinfo                                                        
errorinfo=$lb(1,"798-92-1974")
</pre>
</p>
<p>
<table border=1>
	<tr>
		<th colspan=3>
			Parameters
		</th>
	</tr>
	<tr>
		<th>Name</th>
		<th>Direction</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>pID</td>
		<td>Input</td>
		<td>The ID of the object to be checked.</td>
	</tr>
	<tr>
		<td>pConstraintList</td>
		<td>Input</td>
		<td>A $list of constraints to be checked. If null then all constraints defined for this class will be checked. 
		</td>
	</tr>
	<tr>
		<td>pCheckDisabled</td>
		<td>Input</td>
		<td>If this value is passed as a true value (1) then %CheckConstraints will also check any constraints that are 
			defined as %NOCHECK. 
		</td>
	</tr>
	<tr>
		<td>pErrorInfo</td>
		<td>Output</td>
		<td>
			If an error is reported then <var>pErrorInfo</var> will contain the object's ID and all property values 
			that are referenced by constraints defined for this class. 
		</td>
	</tr>
	<tr>
		<td></td>
		<td>Return</td>
		<td>
			%Status return value. This value contains %Status values for each constraint that failed. If no errors are 
			reported then %Status will be $$$OK. 
		</td>
	</tr>
</table>
</p>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pID:%String(MAXLEN=""),pConstraintList:%List="",pCheckDisabled:%Integer=0,*pErrorInfo:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		kill %code
		if ($$$getClassType(%class) = $$$cCLASSCLASSTYPEPERSISTENT) && ('$$$comClassKeyGet(%class,$$$cCLASSnoextent)) {
			do generateCheckConstraints^%occConstraint(%class,.%code)
		}
		set tStatus = $$$OK
	}
	catch tException {
		set tStatus = tException.AsStatus()
	}
	QUIT tStatus
]]></Implementation>
</Method>

<Method name="%Exists">
<Description><![CDATA[
Checks to see if the object identified by the OID <var>oid</var> exists in the extent.

<p>Returns <CLASS>%Boolean</CLASS> TRUE if it exists, FALSE if it does not.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	If $$$getClassType(%class) '= $$$cCLASSCLASSTYPEPERSISTENT {
		$$$GENERATE("	Set classname = $$$oidClassName(oid) If classname="""" Quit 0")
		$$$GENERATE("	Set $ZTrap = ""CatchExistsError""")
		$$$GENERATE("	If classname '= $classname() Quit $classmethod(classname,""%Exists"",oid)")
		$$$GENERATE("	Quit $isobject(..%Open(oid,0))=1")
		$$$GENERATE("CatchExistsError	Set $ZTrap = """"")
		$$$GENERATE("	Quit 0")
	} Else {
		Set %codemode=$$$cMETHCODEMODEEXPRESSION
		Set %code="$isobject(..%Open(oid,0))=1"
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%ExistsId">
<Description><![CDATA[
Checks to see if the object identified by the ID <var>id</var> exists in the extent.

<p>Returns <CLASS>%Boolean</CLASS> TRUE is it exists, FALSE if it does not.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[	Quit ..%Exists($listbuild(id))
]]></Implementation>
</Method>

<Method name="%1Check">
<Description><![CDATA[
%1Check()
	This is a method that corresponds the the '%1' key (a convention introduced in the SQL filer).
	The '%1' key is a synonym for the %Id() value. The general description of &lt;candidatekey&gt;Check()

&lt;key&gt;Check()
	This method checks for the existence of the key and locks the object associated with that key.
		The lock is released but will be retained for the duration of the transaction.

	The optional lockonly parameter is used by callers wishing only to validate the key. If lockonly is true
		then success is returned if the key does not exists. If the key exists then an attempt is made to
		lock the corresponding object. That status from the lock call is then returned.

		If lockonly is false then an error is returned if the key does not exist. If the key does exist then
		the corresponding object is locked and released. If the lock cannot be acquired then an error is returned.
		Otherwise the key is checked for existence again and an error is returned if it doesn't exist.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String="",lockonly:%Boolean=0,concurrency:%Integer=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set exists=..%ExistsId(id)
	Quit:'exists $select('lockonly:$$$ERROR($$$KeyNotFound,$classname(),id),1:$$$OK)
	set:concurrency=-1 concurrency=$select(..#DEFAULTCONCURRENCY="$zu(115,10)":$zu(115,10),1:$xecute("q "_..#DEFAULTCONCURRENCY))
	if concurrency { set status=..%LockId(id,1) Quit:$$$ISERR(status) status }
	If 'lockonly { set exists=..%ExistsId(id) if concurrency { do ..%UnlockId(id,1,0) } Quit $select('exists:$$$ERROR($$$KeyNotFound,$classname(),id),1:$$$OK)}
	if concurrency Do ..%UnlockId(id,1,0)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%FileIndices">
<Description><![CDATA[
Files each index for the object identified by <var>id</var>. <var>pIndexHandle</var> is for internal use only.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[id:%String(MAXLEN=""),&pIndexHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%FileIndices")
]]></Implementation>
</Method>

<Method name="%GUID">
<Description><![CDATA[
This method returns the GUID assigned to &lt;oid&gt;. This method is only runnable if the GUIDENABLED parameter is TRUE.
This method will dispatch polymorphically and will determine the most-specific-type class if the oid does not contain that information.
If pDeepSearch is true and no GUID is found for the object then a deep search of the GUID registry will be performed, starting with the
current class. This is useful if the most specific type class cannot be determined, such as in the case of an object that has been deleted.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity,pDeepSearch:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If $$$oidPrimary($Get(oid)) = "" Quit ""
	#; Optimize for the full-oid,no polymorphic case:
	If $classname()=$$$oidClassName(oid) Quit $Get(^OBJ.GUID(1,oid))
	Set class=$$$oidClassName(oid)
	#; if class name is not present in oid, we must call the class method %OnDetermineClass
	If class="" { Set sc=..%OnDetermineClass(oid,.class) if $$$ISOK(sc) { set oid=$$$oidInsertClassName(oid,class) } elseif pDeepSearch { quit ##class(%Library.GUID).%FindGUID($classname(),$$$oidPrimary(oid)) } else { quit "" } } Else { set class=$$$NormalizeClassname(class) }
	#; See if we are the correct class. If not, dispatch polymorphically to correct %GUID()
	If $classname()'=class Quit $classmethod(class,"%GUID",oid,pDeepSearch)
	If 'pDeepSearch { Quit $Get(^OBJ.GUID(1,oid)) } else { set tGUID = $Get(^OBJ.GUID(1,oid)) if tGUID'="" { quit tGUID } else { quit ##class(%Library.GUID).%FindGUID($classname(),$$$oidPrimary(oid)) } }
]]></Implementation>
</Method>

<Method name="%GUIDSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity,guid:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If '..#GUIDENABLED Quit ""
	If $$$oidPrimary($Get(oid)) = "" Quit ""
	#; Optimize for the full-oid,no polymorphic case:
	If ($classname()=$$$oidClassName(oid)) && ($Data(^OBJ.GUID(1,oid),guid)) Quit guid
	Set class=$$$oidClassName(oid)
	#; if class name is not present in oid, we must call the class method %OnDetermineClass
	If class="" { Set sc=..%OnDetermineClass(oid,.class) Quit:$$$ISERR(sc) "" Set oid=$$$oidInsertClassName(oid,class) } Else { Set class=$$$NormalizeClassname(class) }
	#; See if we are the correct class. If not, dispatch polymorphically to correct %GUID()
	If $classname()'=class Quit $classmethod(class,"%GUIDSet",oid,guid)
	#; If guid already assigned to this oid just return it
	If $Data(^OBJ.GUID(1,oid),guid) Quit guid
	If ($Get(guid) = "") { Set guid = $System.Util.CreateGUID()}
	If '$Data(^OBJ.GUID(0,guid)) { Set ^OBJ.GUID(0,guid)=oid,^OBJ.GUID(1,oid)=guid } Else { Set guid = "" }
	Quit guid
]]></Implementation>
</Method>

<Method name="%KillExtent">
<Description>
%KillExtent performs a physical kill of the extent. No constraints are enforced. This method should not be
used in place of %DeleteExtent. Only physical storage occupied by this extent will be killed. If this extent
is a subextent of another class then no data is killed. Indexes that originate with this extent will be killed.
%KillExtent will be called on any subextents and on any child extents (the extent of the type class of a
relationship whose cardinality = children is a 'child' extent) of this extent.

This method is not meant for production applications. It is meant to be a development utility to quickly clear
extent physical data. Also this will not remove stream data associated with these instances.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pDirect:%Integer=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
	if $$$comMemberKeyGet(%class,$$$cCLASSparameter,"READONLY",$$$cPARAMdefault) $$$GENERATE(" QUIT $$$ERROR($$$ClassIsReadOnly,$classname())") QUIT $$$OK
		#; 1. Invoke %KillExtent in all child extents.
	set tProperty = $$$comMemberNext(%class,$$$cCLASSproperty,"")
	while tProperty '= "" {
		if ($$$comMemberKeyGet(%class,$$$cCLASSproperty,tProperty,$$$cPROPrelationship)) && ($$$comMemberKeyGet(%class,$$$cCLASSproperty,tProperty,$$$cPROPcardinality) = $$$cPROPCARDINALITYCHILDREN) {
			set tChildType = $$$comMemberKeyGet(%class,$$$cCLASSproperty,tProperty,$$$cPROPtype)
				// Only invoke %KillExtent on the child if the CHILDREN relationship originates in this class
				// or this class is the root class of the concrete extent.
			if ($$$getClassType(tChildType) = $$$cCLASSCLASSTYPEPERSISTENT) && (($Get($$$EXTrootclass($$$pEXT,%class))) || ($$$comMemberKeyGet(%class,$$$cCLASSproperty,tProperty,$$$cXXXXorigin) = %class)) { $$$GENERATE($Char(9)_"if ($$$comMemberKeyGet("""_tChildType_""",$$$cCLASSmethod,""%KillExtent"",$$$cMETHrunnable)) && ($Data(^rOBJ($$$nameClassRoutineNameGet("""_tChildType_""",0)))) { set sc=##class("_tChildType_").%KillExtent() }") }
		}
		set tProperty = $$$comMemberNext(%class,$$$cCLASSproperty,tProperty)
	}
		#; 2. Invoke %KillExtent in all subextents. While this doesn't delete any data it does delete the indices
	$$$GENERATE("	set subextent=$order($$$EXTSUBEXTENT($$$pEXT,$classname(),"""")) While subextent'="""" { if ($$$comMemberKeyGet(subextent,$$$cCLASSmethod,""%KillExtent"",$$$cMETHrunnable)) && ($Data(^rOBJ($$$nameClassRoutineNameGet(subextent,0)))) { Set sc=$classmethod(subextent,""%KillExtent"") If $$$ISERR(sc) { Goto Exit } } Set subextent=$order($$$EXTSUBEXTENT($$$pEXT,$classname(),subextent)) }")
		#; 3. Delete all indices originating in this class
	$$$GENERATE("	set sc=..%PurgeIndices()")
		#; 4. Invoke the storage method, %KillExtentData
	$$$GENERATE("	If $$$ISOK(sc) { Set sc=..%KillExtentData() }")
		// if DSTIME is auto then kill the DSTIME index for this class
	$$$comMemberKeyGetLvar(tDSTIME,%class,$$$cCLASSparameter,"DSTIME",$$$cPARAMdefault)
	if ($$$ucase(tDSTIME) = "AUTO") || ($$$ucase(tDSTIME) = "TIME") {
		$$$GENERATE($Char(9)_"if pDirect { kill ^OBJ.DSTIME($classname()) }")
	}
	$$$GENERATE("Exit	Quit sc")
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%SaveIndices">
<Description><![CDATA[
Files the indices for all objects whose ID is in the range defined by <var>pStartId</var> and <var>pEndId</var>.
If <var>pEndId</var> is null then it defaults to <var>pStartId</var>. If <var>pStartId</var> is null then the
range is empty and no filing will occur.

If <var>lockExtent</var> is true then an extent lock will be acquired before the indices
are built. If the lock cannot be acquired then an error is returned. The lock is released
after the index filing is completed.


<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStartId:%String(MAXLEN="")="",pEndId:%String(MAXLEN="")="",lockExtent:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%SaveIndices")
]]></Implementation>
</Method>

<Method name="%AddJrnObjToSyncSet">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[objSS:%SYNC.SyncSet,fileop:%Integer=0,oid:%ObjectIdentity,&object:%String,changed:%List="",guid:%String="",originSystem:%String="",originNS:%String=""]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If '..#OBJJOURNAL Quit ""
	Set objRef = ..%LoadFromMemory($$$oidPrimary(oid),.object)
	If $isobject(objRef)=0 { set objRef = ..%Open(oid) }
	Quit $Select($isobject(objRef)=1:..%AddToSyncSet(objSS, objRef, fileop, oid, changed, guid, originSystem, originNS),1:"")
]]></Implementation>
</Method>

<Method name="%BuildIndexInternal">
<Description><![CDATA[
Internal helper method for <method>%BuildIndicies</method>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLockFlag,pAutoPurge,pStartID,pEndID,pIndexList,pBuildFlags,pGLVN,pBMEIndexPtr,pJournalFlag,pCompositeKey</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK,class=$classname()
	Try {
		If pLockFlag=1||(pLockFlag=3) {
			$$$THROWONERROR(sc,..%LockExtent($s(pLockFlag=1:0,1:1)))
			Set tLocked=1
		}
		If $system.CLS.IsMthd("%OnBeforeBuildIndices") {
			$$$THROWONERROR(sc,..%OnBeforeBuildIndices(.pIndexList))
			if ($listlength(pIndexList)=1)&&($listget(pIndexList,1)="") {
				If $Get(tLocked) {
					Do ..%UnlockExtent($s(pLockFlag=1:0,1:1))
				}
				RETURN $$$OK
			}
		}
		If pAutoPurge,pStartID="",pEndID="" {
			Set sc=..%PurgeIndices(.pIndexList)
			If $$$ISERR(sc) Goto exit
		}
		
		Set splits=$system.Util.NumberOfCPUs()
		If splits>$get(^%SYS("Compiler","MaxIndexWorkers"),12) Set splits=$get(^%SYS("Compiler","MaxIndexWorkers"),12)
		Set oldsubnode=pStartID,split=""
		If splits>1 {
			Set splitlist=$$SplitSize^%GSIZE(pGLVN,"N",splits,$select(pCompositeKey:$piece(pStartID,"||"),1:pStartID),$select(pCompositeKey:$piece(pEndID,"||"),1:pEndID))
			Set status=$listget(splitlist,1)
			If status=1 {
				Set split=$listget(splitlist,2)
				#; If the split point is also the start point remove it to avoid potential issue where same node is processed twice
				If pStartID'="",$listget(split)=pStartID Set split=$list(split,2,*)
			}
		}
		Set numbersplits=$listlength(split)+1
		Set queue = $SYSTEM.WorkMgr.Initialize("/multicompile=1/journal="_pJournalFlag,.sc,numbersplits)
		If $$$ISERR(sc) Goto exit
		Kill ^CacheTempIndexBuild($job)
		Set ptr=0
		While $listnext(split,ptr,subnode) {
			Set sc=queue.Queue("##class("_class_").%BuildIndicesSegment",oldsubnode,subnode,.pBuildFlags,pLockFlag,$select(pStartID'=""&&(oldsubnode=pStartID):1,1:0),$job)
			If $$$ISERR(sc) Goto exit
			Set oldsubnode=subnode
		}
		#; Queue the last range
		Set sc=queue.Queue("##class("_class_").%BuildIndicesSegment",oldsubnode,pEndID,.pBuildFlags,pLockFlag,$select(pStartID'=""&&(oldsubnode=pStartID):1,1:0),$job)		
		If $$$ISOK(sc) Set sc=queue.WaitForComplete()
		If $$$ISERR(sc) Goto exit
		
			// Cascade the BME build to subextents
		If pBMEIndexPtr,$Ascii(pBuildFlags(class),pBMEIndexPtr) {
			Set subextent=""
			For {
				Set subextent=$o($$$EXTSUBEXTENT($$$pEXT,class,subextent))
				Quit:subextent=""
				Set tSubBuilt=$classmethod(subextent,"%BMEBuilt",.subbme)
				Set sc=$classmethod(subextent,"%BuildIndices",$listbuild(subbme),pAutoPurge,pLockFlag,pJournalFlag,.pStartID,.pEndID)
				If $$$ISERR(sc) Goto exit
			}
		}

		If $system.CLS.IsMthd("%OnAfterBuildIndices") {
			Set sc=..%OnAfterBuildIndices(.pIndexList)
			If $$$ISERR(sc) Goto exit
		}
	} Catch tException {
		Set sc=tException.AsStatus()
	}
exit	If $Get(tLocked) {
		Do ..%UnlockExtent($s(pLockFlag=1:0,1:1))
	}
	Set i=""
	For {
		Set i=$order(^CacheTempIndexBuild($job,i),1,val) Quit:i=""
		If val'=0 Do $system.Event.Delete($name(^CacheTempIndexBuild($job,i)))
	}
	Kill ^CacheTempIndexBuild($job)
	Quit sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<Description><![CDATA[
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>. Persistent
classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%DeleteData")
]]></Implementation>
</Method>

<Method name="%KillExtentData">
<Description>
%KillExtentData() - kills extent data in storage. This method is
implemented by the storage class.</Description>
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%KillExtentData")
]]></Implementation>
</Method>

<Method name="%LoadData">
<Description>
%LoadData() - loads an object from storage. This method is
implemented by the storage class.</Description>
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%LoadData")
]]></Implementation>
</Method>

<Method name="%PurgeIndices">
<Description><![CDATA[
<p>Deletes all entries from each index specified in the <var>idxlist</var> argument.
If <var>idxlist</var> is empty then all indices that originate
in the class are purged. The index definition remains intact.</p>

<p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be purged.
This argument allows you to purge all indices except those defined in <var>pIgnoreIndexList</var>.
The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be purged. </p> 

<p>If <method>%OnBeforePurgeIndices</method> is implemented and is runnable then it will be called
just after acquiring the extent lock, if one is requested, and just prior to performing the
the purge. If <method>%OnBeforePurgeIndices</method> returns an error status
then %PurgeIndices will exit immediately, no indices will be purged and that error status
will be returned to the caller of %PurgeIndices.</p>

<p>If <method>%OnAfterPurgeIndices</method> is implemented and is runnable then it will be called
just prior to releasing the extent lock, if one is requested. All index structures have been purged
prior to calling <method>%OnAfterPurgeIndices</method>. If <method>%OnAfterPurgeIndices</method> returns
and error status then that status will be returned to the caller of %PurgeIndices but all structures will
still have been purged.
</p>
<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>. Persistent
classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
method.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>idxlist:%List="",lockExtent:%Boolean=0,pIgnoreIndexList:%CacheString=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%PurgeIndices")
]]></Implementation>
</Method>

<Method name="%SaveData">
<Description>
%SaveData() - saves an object to disk, checks uniqueness and referential
integrity constraints, and maintains index structures. This method is
implemented by the storage class.</Description>
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%SaveData")
]]></Implementation>
</Method>

<Method name="%SaveDirect">
<Description><![CDATA[
%SaveDirect() - saves an object to disk, checks uniqueness and referential
integrity constraints, and maintains index structures. The state of the object
is passed to this method in three arguments.
<var>id</var> contains the ID value if the object has been previously saved.
<var>idList</var> is a $list value containing the IDKEY components. If the class is a child
class (contains a relationship with CARDINALITY = PARENT) then the first value in the list is the parent reference.
If the ID is system assigned the next value (or only value if the class is not a child class) is the system assigned ID value.
If the ID is based on a user-defined IDKEY then there is a $list element corresponding to each property in the same order as
defined in the IDKEY index.
<br>
<var>data</var> is a structure that mirrors the disk structure of the object. The root value (unsubscripted) contains the properties stored in the
data node from the storage definition with a null subscript. Additional entries in the <var>data</var> structure correspond to any additional data nodes
defined in the storage definition.
<br>
This method is not commonly called directly.
<br>
This method is implemented by the storage class.
<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&id:%String="",idList:%List="",&data:%Binary,concurrency:%Integer=-1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Persistent::%SaveDirect")
]]></Implementation>
</Method>

<Method name="%SortBegin">
<Description><![CDATA[
Executes a $SortBegin for the base global reference of each index specified in the <var>idxlist</var> argument.
If <var>idxlist</var> is empty then a $SortBegin is executed for all indices that originate
in the class.

<p>The <var>excludeunique</var> argument, if TRUE, causes any index defined as UNIQUE or PRIMARY KEY to be ignored.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>idxlist:%List="",excludeunique:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[$$$OK
]]></Implementation>
</Method>

<Method name="%SortEnd">
<Description><![CDATA[
Executes a $SortEnd for the base global reference of each index specified in the <var>idxlist</var> argument.
If <var>idxlist</var> is empty then a $SortBegin is executed for all indices that originate
in the class.

<p>The <var>commit</var> argument, if FALSE, causes the data to be discarded. Otherwise, all data placed in
the global since the $SortBegin is committed.
<p>The <var>excludeunique</var> argument, if TRUE, causes any index defined as UNIQUE or PRIMARY KEY to be ignored.

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>idxlist:%List="",commit:%Integer=1,excludeunique:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[$$$OK
]]></Implementation>
</Method>

<Query name="Extent">
<Description><![CDATA[
<p>This is a system provided query that returns a row for each instance within this extent. The first column of the row is the
object ID. Additional columns can be included in the select list by adding the desired columns to the <parameter>EXTENTQUERYSPEC</parameter> parameter.</p>
<p>
The Extent query default implementation is generated by <class>%Library.ExtentSQLQuery</class>. That class
supports the <var>COMPILEMODE</var> parameter with possible values of IMMEDIATE and DYNAMIC. If DYNAMIC is specified
then the SQL statement used to implement the query will be generated as a dynamic SQL statement. If IMMEDIATE is specified
then the statement is generated as an embedded SQL statement.</p>
<br><p>This query can be overridden by a subclass so long as two requirements are met. The list of columns must include %ID as the first column and
it must return a row corresponding to each instance/row in the extent.</p>]]></Description>
<Type>%ExtentSQLQuery</Type>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
</Query>

<Method name="%OnBeforeBuildIndices">
<Description><![CDATA[
<p>
This callback method is invoked by the <METHOD>%BuildIndices</METHOD> method. 
</p>
<p>
It is called prior to modifying any index structures. If an extent lock is requested by the 
%BuildIndices caller then %OnBeforeBuildIndices is called after the extent lock is acquired. 
<P>If this method returns an error then %BuildIndices will exit immediately without 
purging and building any index structures, returning the error to the caller of %BuildIndices. 
</p>
<p>
<table border=1>
<tr>
	<th colspan=3>Parameters</th>
</tr>
<tr>
<th>
Name
</th>
<th>
Type
</th>
<th>
Description
</th>
</tr>
<tr>
		<td>indexlist</td>
		<td>Input/output</td>
		<td>
			A $list value containing the names of the indexes to be built. This parameter is 
			passed by reference. If the implementation of %OnBeforeBuildIndices alters this value 
			then %BuildIndices will honor those changes.
		</td>
</tr>
</table>
</p>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&indexlist:%String(MAXLEN="")=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterBuildIndices">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%BuildIndices</METHOD> method after all work is completed.
<P>If this method returns an error then %BuildIndices will return that error but all normal processing is
completed. This call occurs just prior to releasing the extent lock if one was requested by the %BuildIndices caller.
All index structures have been built and SortEnd executed.</p>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>indexlist:%String(MAXLEN="")=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDelete">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Delete</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> is being deleted.

<P>If this method returns an error then the object will not be deleted.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterDelete">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Delete</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> has been deleted.
The callback occurs immediately after %DeleteData has been called. If %DeleteData returns
an error then %OnAfterDelete is not called.

<P>If %OnAfterDelete returns an error (%Status) then the transaction is rolled back.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnBeforeSave">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that the object is being saved. It is called before 
any data is written to disk.

<P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.

<P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.]]></Description>
<Abstract>1</Abstract>
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterSave">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that the object is being saved. It is called after 
the object's data has been successfully written to disk.

<P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.

<P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.]]></Description>
<Abstract>1</Abstract>
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Open</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> is being opened.

<P>If this method returns an error then the object will not be opened.]]></Description>
<Abstract>1</Abstract>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnBeforePurgeIndices">
<Description><![CDATA[
<p>
This callback method is invoked by the <METHOD>%PurgeIndices</METHOD> method. 
</p>
<p>
If this method returns an error then %PurgeIndices will exit immediately without
purging any index structures, returning the error to the caller of %PurgeIndices.
</p>
<p>
<table border=1>
<tr>
<th colspan=3>Parameters</th>
</tr>
<tr>
<th>
Name
</th>
<th>
Type
</th>
<th>
Description
</th>
</tr>
<tr>
		<td>indexlist</td>
		<td>Input/output</td>
		<td>
			A $list value containing the names of the indexes to be built. This parameter is 
			passed by reference. If the implementation of %OnBeforePurgeIndices alters this value 
			then %PurgeIndices will honor those changes.
		</td>
</tr>
</table>
</p>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&indexlist:%String(MAXLEN="")=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterPurgeIndices">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%PurgeIndices</METHOD> method after all work is completed.
<P>If this method returns an error then %PurgeIndices will return that error but all normal processing is
completed. This call occurs just prior to releasing the extent lock.</p>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>indexlist:%String(MAXLEN="")=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnReload">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Reload</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> was reloaded.
<method>%Reload</method> is invoked by %Open when the object identified by the OID 
is already in memory. 
<br>
<P>If this method returns an error then the object will not be opened.]]></Description>
<Abstract>1</Abstract>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnRollBack">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that a save transaction is being rolled back.

<P>If this method returns an error then the rollback operation will be aborted.]]></Description>
<Abstract>1</Abstract>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDetermineClass">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[oid:%ObjectIdentity,&class:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set class=$classname()
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="%OBJJRNIU">
<Code><![CDATA[	if ($$$getClassType(%class) '= $$$cCLASSCLASSTYPEPERSISTENT) || ($$$comClassKeyGet(%class,$$$cCLASSnoextent)) { kill %code quit $$$OK }
	set journal = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"OBJJOURNAL",$$$cPARAMdefault)
	set guid = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"GUIDENABLED",$$$cPARAMdefault)
	if journal {
		if journal < 3 {
			$$$GENERATE($Char(9)_"if %oper=""INSERT"" { n %e,iJrnPtr,jid,oref s i=$o(%d("""")) while i'="""" { set $e(%e,i)=$c(1),i=$o(%d(i)) } Set oref=##class({%%CLASSNAME}).%OpenId({%%ID}) $$$txJournalSQLSave({%%CLASSNAMEQ},jid,{%%ID},1"_$select('guid:",""""",1:",##class({%%CLASSNAME}).%GUID($$$oidCompose({%%ID},{%%CLASSNAMEQ}))")_",oref,iJrnPtr) }")
			$$$GENERATE($Char(9)_"elseif %oper=""UPDATE"" { n iJrnPtr,jid,oref set oref=##class({%%CLASSNAME}).%OpenId({%%ID}) $$$txJournalSQLSave($classname(oref),jid,{%%ID},0"_$select('guid:",""""",1:",oref.%GUID($$$oidCompose({%%ID},$classname(oref)))")_",oref,iJrnPtr) }")
		}
		else {
			$$$GENERATE($Char(9)_"if %oper=""INSERT"" { n jid $$$txJournal({%%CLASSNAMEQ},jid,{%%ID},1)")
			$$$GENERATE($Char(9)_"elseif %oper=""UPDATE"" { n jid $$$txJournal({%%CLASSNAMEQ},jid,{%%ID},0)")
		}
	}
	quit $$$OK]]></Code>
<Event>INSERT/UPDATE</Event>
<Order>2</Order>
<Time>AFTER</Time>
<Foreach>row</Foreach>
<CodeMode>generator</CodeMode>
</Trigger>

<Trigger name="%OBJJRND">
<Code><![CDATA[	if ($$$getClassType(%class) '= $$$cCLASSCLASSTYPEPERSISTENT) || ($$$comClassKeyGet(%class,$$$cCLASSnoextent)) { kill %code quit $$$OK }
	set journal = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"OBJJOURNAL",$$$cPARAMdefault)
	set guid = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"GUIDENABLED",$$$cPARAMdefault)
	if journal {
		if journal < 3 {
			$$$GENERATE($Char(9)_"n iJrnPtr,jid,oref Set oref=##class({%%CLASSNAME}).%OpenId({%%ID}) $$$txJournalSQLDelete($classname(oref),jid,{%%ID}"_$select('guid:",""""",1:",oref.%GUID($$$oidCompose({%%ID},$classname(oref)))")_",oref,iJrnPtr)")
		}
		else {
			$$$GENERATE($Char(9)_"n jid $$$txJournal({%%CLASSNAMEQ},jid,{%%ID},2)")
		}
	}
	quit $$$OK]]></Code>
<Event>DELETE</Event>
<Order>1</Order>
<Foreach>row</Foreach>
<CodeMode>generator</CodeMode>
</Trigger>

<Trigger name="%OBJGUID">
<Code>	if ($$$getClassType(%class) '= $$$cCLASSCLASSTYPEPERSISTENT) || ($$$comClassKeyGet(%class,$$$cCLASSnoextent)) { kill %code quit $$$OK }
	set guid = $$$comMemberKeyGet(%class,$$$cCLASSparameter,"GUIDENABLED",$$$cPARAMdefault)
		// For GUIDENABLED classes this trigger assigns a GUID to inserted rows.
	if guid {
		$$$GENERATE($Char(9)_"if '$a(%check,6) { do ##class({%%CLASSNAME}).%GUIDSet($$$oidCompose({%%ID},{%%CLASSNAMEQ}),{%GUID}) }")
	}
	quit $$$OK</Code>
<Event>INSERT</Event>
<Order>1</Order>
<Time>AFTER</Time>
<Foreach>row</Foreach>
<CodeMode>generator</CodeMode>
</Trigger>
</Class>


<Class name="%Library.PersistentProperty">
<Description>
This is an additional property class for properties of a persistent class.</Description>
<IncludeGenerator>%occInclude</IncludeGenerator>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59945,42316.517843</TimeCreated>

<Method name="GetStored">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>id:%String</FormalSpec>
<NoContext>1</NoContext>
<ReturnType>%CacheString</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	s %code=0
		#; don't generate any code if it not for a property
	i %mode="method" QUIT $$$OK
	$$$comMemberKeyGetLvar(blStorable,%class,$$$cCLASSproperty,%property,$$$cPROPstorable)
	$$$comMemberKeyGetLvar(blSQLComputed,%class,$$$cCLASSproperty,%property,$$$cPROPsqlcomputed)
	Set strStored = $Get($$$EXTPROPondisk($$$pEXT,%class,%property))
	If (blStorable) && (strStored '= "") {
		$$$comMemberKeyGetLvar(blPrivate,%class,$$$cCLASSproperty,%property,$$$cPROPprivate)
		If blPrivate $$$modifySubMemberKeySet(%class,$$$cCLASSproperty,%property,$$$cPROPmethod,%method,$$$cMETHprivate,1)
		$$$modifySubMemberKeySet(%class,$$$cCLASSproperty,%property,$$$cPROPmethod,%method,$$$cMETHreturntype,$$$comMemberKeyGet(%class,$$$cCLASSproperty,%property,$$$cPROPruntimetype))
		Set %code="$Select(id'="""":"_strStored_",1:"""")", %codemode = $$$cMETHCODEMODEEXPRESSION
	}
	QUIT $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%Library.Populate">
<Description><![CDATA[
<CLASS>%Populate</CLASS> is a utility class that provides the ability to 
create instances of an object populated with random data.

<p>To use the <CLASS>%Populate</CLASS> class do the following:
<ol>
<li>Create a persistent object class, such as <b>Employee</b>.</li>
<li>Add <CLASS>%Populate</CLASS> to the end of the class' super class list:<br>
<example>super = %Persistent,%Populate</example></li>
<li>Save and compile the class.</li>
<li><CLASS>%Populate</CLASS> will add a class method, <b>Populate()</b>, to your class.</li>
</ol>
Run this method to create instances of your class in the database:<br>
<example>Do ##class(Employee).Populate(100)</example>
<p>For more information refer to 
<LINK href=DocBook.UI.Page.cls?KEY=GOBJ_populate>The Cach&eacute; Populate Utility</LINK>.]]></Description>
<Abstract>1</Abstract>
<IncludeGenerator>%systemInclude,%occUtility</IncludeGenerator>
<ProcedureBlock>0</ProcedureBlock>
<PropertyClass>%Library.CachePopulate</PropertyClass>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>

<Parameter name="POPSPEC">
<Description><![CDATA[
The <i>POPSPEC</i> parameter provides a way to control how 
<CLASS>%Populate</CLASS> generates data for properties.

<p>For more information refer to 
<LINK href=DocBook.UI.Page.cls?KEY=GOBJ_populate>The Cach&eacute; Populate Utility</LINK>.]]></Description>
</Parameter>

<Method name="Populate">
<Description><![CDATA[
Creates up to <var>count</var> instances an object and stores 
them in the database.

<p>If <var>verbose</var> is true, then details are echoed to the console.
<p>If <var>DeferIndices</var> is true, then indices are sorted at the end of the operation.
<p>If <var>objects</var> is true, then each object that is created is returned in the objects array
<p>If <var>tune</var> is true, then $SYSTEM.SQL.TuneTable is called after the instances of the class have been created. 
If tune>1, then $SYSTEM.SQL.TuneTable is also called for any tables projected by persistent superclasses of this class
<p>If <var>deterministic</var> is true, then the set of objects produced by identical calls to Populate at different times will be identical. 

<P>Returns the number of instances successfully created.

<p>For more information refer to 
<LINK href=DocBook.UI.Page.cls?KEY=GOBJ_populate>The Cach&eacute; Populate Utility</LINK>.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[count:%Integer=10,verbose:%Integer=0,DeferIndices:%Integer=1,&objects:%Integer=0,tune:%Integer=1,deterministic:%Integer=0]]></FormalSpec>
<GenerateAfter>OnPopulate</GenerateAfter>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	QUIT:'($$$getClassType(%class)=$$$cCLASSCLASSTYPEPERSISTENT) $$$OK
	QUIT:($$$CLASSabstract($$$gMGINFO,%class)) $$$OK
	New assignvals,attrib,buildinstances,buildsamples,cardinality,classtype,closing,collection,concrete,dt,dts,i,initcode,keepobj,lvars,max,min,p,popspec,populate,properties,references,relationship,saveobj,spec,specatom,set,sett,typecategory,unordered,val,vallist,scale,order,prop
	Set popspec=%parameter("POPSPEC")
	Set spec="" If popspec'="" QUIT:'$$ParseNestedString^%occStorageUtil(popspec,",",,.spec)
	For i=1:1:spec {
		Kill specatom
		If $$ParseNestedString^%occStorageUtil(spec(i),":",,.specatom)
		Set attrib=$Piece($Get(specatom(1)),":")
		If attrib '= "" {
			Set attrib(attrib)=$Select("#."'[$Extract(specatom(2),1):"##class(%PopulateUtils)."_specatom(2),$Extract(specatom(2))=".":"obj"_specatom(2),1:specatom(2))
			Set:specatom>2 attrib(attrib,"count")=specatom(3)
			Set:specatom>3 attrib(attrib,"key")=$Select("#."'[$Extract(specatom(4),1):"##class(%PopulateUtils)."_specatom(4),$Extract(specatom(4))=".":"obj"_specatom(4),1:specatom(4))
			Set:specatom>4 attrib(attrib,"concrete") = specatom(5)
			Set:specatom>5 attrib(attrib,"sqltable")=specatom(6)
			Set:specatom>6 attrib(attrib,"sqlcolumn")=specatom(7)
		}
	}
	Set references = 0, concrete = 0
		#; Set up the code generation structure...
	Do InitializeFlowGraph^%occStorageUtil(.populate)
		#; Initialize and generate the top level code blocks
	Set initcode = $$NewCodeBlock^%occStorageUtil(.populate,0,0)
	Do DefineLocalVariables^%occStorageUtil(.populate,initcode,"errcnt,i,keepobjects,obj,save,saved,id")

	Set buildsamples = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)
	Set buildinstances = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)
	Set assignvals = $$NewCodeBlock^%occStorageUtil(.populate,buildinstances,1)
	Set saveobj = $$NewCodeBlock^%occStorageUtil(.populate,assignvals,1)
	Set keepobj = $$NewCodeBlock^%occStorageUtil(.populate,assignvals,0)
	Set closing = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)

	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"#class "_%class_" obj")
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"#import "_$$$ClassPackageName(%class))
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"Set saved=0,keepobjects=0,errcnt=0")
	//Seed the $ZU(165 RNG with a constnat if we want deterministic results
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"Do $ZU(165,0,$S(deterministic:481516,1:$RANDOM(99999999)))")
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"If objects Set keepobjects=1,objects=0")
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"If DeferIndices Do ..%SortBegin("""",1)")

	Do QueueCodeLine^%occStorageUtil(.populate,buildinstances,"For i=1:1:count Do  if errcnt>1000 write:verbose !,""over 1,000 errors encountered with no successful save - exiting"" quit")
	Do QueueCodeLine^%occStorageUtil(.populate,assignvals,"Set obj=##class("_%class_").%New()")

	$$$comMemberKeyGetLvar(versionProperty,%class,$$$cCLASSparameter,"VERSIONPROPERTY",$$$cPARAMdefault)
	Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,"")
	While prop '= "" {
		If (versionProperty '= prop) && (prop '= "%%GUID") && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPprivate)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPreadonly)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPcalculated)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPidentity)) {
				#; suppress populate if POPORDER is less than zero!!
			set poporder = $$$comMemberArrayGet(%class,$$$cCLASSproperty,prop,$$$cPROPparameter,"POPORDER")
			if poporder '< 0 {
				$$$comMemberKeyGetLvar(dt,%class,$$$cCLASSproperty,prop,$$$cPROPtype)
				if $$$getClassType(dt) '= "" {
					$$$comMemberKeyGetLvar(relationship,%class,$$$cCLASSproperty,prop,$$$cPROPrelationship)
					$$$comMemberKeyGetLvar(cardinality,%class,$$$cCLASSproperty,prop,$$$cPROPcardinality)
					If ('relationship) || ((cardinality '= $$$cPROPCARDINALITYCHILDREN) && (cardinality '= $$$cPROPCARDINALITYMANY)) {
						$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,prop,$$$cPROPcollection)
						$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,prop,$$$cPROPcollection)
						If (collection = "") || (collection = $$$cPROPCOLLECTIONLIST) || (collection = $$$cPROPCOLLECTIONARRAY) {
								#; The following check quits if the initialexpression is set because
								#; default values always override randomly generated values. In the case of a collection,
								#; the initialexpression applies to the collection object - not to the elements.
							If (collection '= "") || ($$$IVARinitialexpression($$$gMGINFO,%class,prop) = """""") {
								If (poporder) && ('$Data(properties(poporder))) { Set properties(poporder) = prop } Else { Set unordered(prop) = "" }
							}
						}
					}
				}
			}
		}
		Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,prop)
	}
	Set max = $Order(properties(""),-1)
	Set prop = $Order(unordered(""))
	While prop '= "" {
		Set properties($Increment(max)) = prop
		Set prop = $Order(unordered(prop))
	}
	Set p = $Order(properties(""))
	While p '= "" {
		Set prop = properties(p)
		$$$comMemberKeyGetLvar(dt,%class,$$$cCLASSproperty,prop,$$$cPROPtype)
		Set classtype = $$$getClassType(dt)
		Set spec = $$$PROPPARAM($$$gMGINFO,%class,prop,"POPSPEC")
			#; Is there a property parameter POPSPEC? If so, process this and discard any class POPSPEC info that might be around.
		If spec '= "" {
			Kill specatom, attrib(prop)
			If $$ParseNestedString^%occStorageUtil(spec,":",,.specatom)
				#; Prefix the value generator specified:
			Set attrib(prop) = $Select("#."'[$Extract(specatom(1),1):"##class(%PopulateUtils)."_specatom(1),$Extract(specatom(1))=".":"obj"_specatom(1),1:specatom(1))
				#; This is the collection element count
			Set:specatom>1 attrib(prop,"count") = specatom(2)
				#; and the collection key generator
			Set:specatom>2 attrib(prop,"key")=$Select("#."'[$Extract(specatom(3),1):"##class(%PopulateUtils)."_specatom(3),$Extract(specatom(3))=".":"obj"_specatom(3),1:specatom(3))
				#; and the size of a subdomain (extent)
			If specatom>3 Set attrib(prop,"concrete") = specatom(4)
			Set:specatom>4 attrib(prop,"sqltable") = specatom(5)
			Set:specatom>5 attrib(prop,"sqlcolumn") = specatom(6)
		}
		 	#; typecategory is set based on collection because collections do not behave nicely. The typecategory for collections
		 	#; is based on the collection class, not the defined type class.
		Set typecategory = $Case(classtype,$$$cCLASSCLASSTYPEDATATYPE:"literal",$$$cCLASSCLASSTYPEPERSISTENT:"reference",$$$cCLASSCLASSTYPESTREAM:"stream",:"serial")
		$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,prop,$$$cPROPcollection)
		If collection = "" {
			If (typecategory = "literal") || (typecategory = "stream")  {
				Set set = "Set obj."_$$$QN(prop)_"="
				Set sett = ""
			}
			ElseIf typecategory = "reference" {
				Set set = "Set id="
				Set sett = " If id'="""",##class("_dt_").%ExistsId(id) Do obj."_$$$QN(prop_"SetObjectId")_"(id)"
			}
			Else {
				Set set = "Do obj."_$$$QN(prop_"SetObject")_"("
				Set sett = ")"
			}
		}
		Else {
			Set lvars = "elem,cval"
			Set set = "f elem=1:1:$$$PRand("_($Select('$Get(attrib(prop,"count")):"10",1:attrib(prop,"count"))+1)_") s cval="
			If collection = $$$cPROPCOLLECTIONARRAY {
				Set lvars = lvars_",key"
				Set sett=" s key="_$Select($Get(attrib(prop,"key"))="":"##class(%PopulateUtils).String(4)",1:attrib(prop,"key"))_" d obj."_$$$QN(prop)_$Select(typecategory="literal":".SetAt(",typecategory="reference":".SetObjectIdAt(",1:".SetObjectAt(")_"cval,key)"
			}
			ElseIf collection = $$$cPROPCOLLECTIONLIST {
				Set sett = " d obj."_$$$QN(prop)_$Select(typecategory="literal":".Insert(",typecategory="reference":".InsertObjectId(",1:".InsertObject(")_"cval)"
			}
			Set:typecategory="reference" sett = " If (cval'=""""),(##class("_dt_").%ExistsId(cval))"_sett
			Do DefineLocalVariables^%occStorageUtil(.populate,initcode,lvars)
		}
			#; If an override value generator was specified in POPSPEC, use it now!
		Set val = $Get(attrib(prop))
		If val = "" {
				#; If there is a value list, pick a value from it...
			Set vallist = $$$PROPPARAM($$$gMGINFO,%class,prop,"VALUELIST")
			if vallist = "" { set vallist = $$$PROPPARAM($$$gMGINFO,%class,prop,"DISPLAYLIST") }
			If vallist '= "" { set val = "##class(%PopulateUtils).ValueList("""_vallist_""")" }
				#; If the property's type class is SERIAL then check to see if it can be populated
				#; if it can then generate a call to dt.PopulateSerial
			ElseIf typecategory = "serial" {
				If $$$comMemberKeyGet(dt,$$$cCLASSmethod,"PopulateSerial",$$$cMETHrunnable) { Set val = "##class("_dt_").PopulateSerial()" }
			}
			ElseIf typecategory = "reference" {
					#; can't generate a reference if the target isn't persistent...
				If ($$$getClassType(dt) = $$$cCLASSCLASSTYPEPERSISTENT) {
					If $Get(references(dt)) = "" {
						Set references=references+1,references(dt)="rss"_references
						Do DefineLocalVariables^%occStorageUtil(.populate,initcode,"rss"_references)
						Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"d ##class(%PopulateUtils).BuildReferenceSample("""_dt_""",."_references(dt)_")")
					}
					Set val = "##class(%PopulateUtils).ArrayElement(."_references(dt)_")"
				}
			}
			ElseIf typecategory = "literal" {
				Set val = ""
				Set dts = $$$ClassShortName(dt), ucProp = $$$ucase(prop)
				Set val = $Case(ucProp,
							"NAME":		"##class(%PopulateUtils).Name()",
							"SSN":		"##class(%PopulateUtils).SSN()",
							"COMPANY":	"##class(%PopulateUtils).Company()",
							"TITLE":	"##class(%PopulateUtils).Title()",
							"PHONE":	"##class(%PopulateUtils).USPhone()",
							"CITY":		"##class(%PopulateUtils).City()",
							"STREET":	"##class(%PopulateUtils).Street()",
							"ZIP":		"##class(%PopulateUtils).USZip()",
							"MISSION":	"##class(%PopulateUtils).Mission()",
							"STATE":	"##class(%PopulateUtils).USState()",
							"COLOR":	"##class(%PopulateUtils).Color()",
							"PRODUCT":	"##class(%PopulateUtils).Product()",
							:"")
					#; If no value generator is assigned by the property name rule then proceed with the property type rule:
				If val = "" {
					set minlen = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINLEN"), maxlen = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXLEN")
					if (dts = "String") && (minlen > 1) { set val = "##class(%PopulateUtils).StringMin("_minlen_","_maxlen_")" }
					else {
						Set val = $Case(dts,
							"String":		"##class(%PopulateUtils).String("_maxlen_")",
							"Integer":		"##class(%PopulateUtils).Integer("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Date":			"##class(%PopulateUtils).Date("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Binary":		"##class(%PopulateUtils).String("_maxlen_")",
							"Double":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Name":			"##class(%PopulateUtils).Name()",
							"Boolean":		"$$$PRand(2)",
							"Currency":		"##class(%PopulateUtils).Currency("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Float":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Numeric":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Decimal":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"PosixTime":		"##class(%PopulateUtils).PosixTime("_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"TimeStamp":		"##class(%PopulateUtils).TimeStamp("_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							:			"")
					}
						#; None of the above? try SmallInt and Time:
					If val = "" {
						If dts="SmallInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":32767,max>32767:32767,1:max)
							Set min = $Select(min="":-32768,min<-32768:-32768,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						ElseIf dts = "Time" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":86399,max>86399:86399,1:max)
							Set min = $Select(min="":0,min<0:0,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						elseif dts="TinyInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":127,max>127:127,1:max)
							Set min = $Select(min="":-128,min<-128:-128,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						elseif dts="BigInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":100000000000000000,max>100000000000000000:100000000000000000,1:max)
							Set min = $Select(min="":-100000000000000000,min<-100000000000000000:-100000000000000000,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
					}
				}
			}
		}
		If $Get(attrib(prop,"concrete")) && (val '= "") {
			Set concrete = concrete + 1
			Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"If verbose { Write !,""Constructing value set for " _ prop _ ":"" }")
			If ($Get(attrib(prop,"sqltable")) = "") || ($Get(attrib(prop,"sqlcolumn")) = "") {
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Set ^CacheTemp(cptr,"_concrete _ ") = " _ attrib(prop,"concrete") _", cextcnt = 0")
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"While cextcnt < " _ attrib(prop,"concrete") _ " { Set val = " _ val _ " If '$d(^CacheTemp(cptr,"_concrete _ ",""u"",val)) { Set cextcnt = cextcnt + 1, ^CacheTemp(cptr," _ concrete _ ",""u"",val) = cextcnt, ^CacheTemp(cptr," _ concrete _ ",cextcnt) = val If verbose && ('(cextcnt#1000)) { Write ""."" } } }")
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Kill ^CacheTemp(cptr," _ concrete _ ",""u"")")
			}
			Else {
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Set sc = ##class(%Library.PopulateUtils).BuildValueSetSQL(cptr," _ concrete _ "," _ $$$quote(attrib(prop,"sqltable")) _ "," _ $$$quote(attrib(prop,"sqlcolumn")) _ "," _  attrib(prop,"concrete") _ ",verbose)")
			}
			Set val = "##class(%PopulateUtils).ExtentValue(cptr," _ concrete _ ")"
		}
		If val = "" { Set val = """""" }
		Do QueueCodeLine^%occStorageUtil(.populate,assignvals,set_val_sett)
		Set p = $Order(properties(p))
	}
 		#; concrete is a local array of the concrete literal subextents. When it exists it means that some
 		#; value extents must be made concrete and a random selection from that concrete set is used.
 		#; The parameters affecting value generation are considered when the concrete set is built. Value selection
 		#; is simply a random choice. Here we will allocate space in ^CacheTemp
 	If concrete {
		Do DefineLocalVariables^%occStorageUtil(.populate,initcode,"cptr,cextcnt,val")
		Do QueueCodeLine^%occStorageUtil(.populate,initcode,"Set cptr = $Increment(^CacheTemp)")
		Do QueueCodeLine^%occStorageUtil(.populate,initcode,"$$$AddTempNode(^CacheTemp(cptr))")
		Do QueueCodeLine^%occStorageUtil(.populate,closing,"$$$RemoveTempNode(^CacheTemp(cptr))")
 	}
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"$$$AddTempNode(^CacheTempPop($j)) Kill ^CacheTempPop($j)")
	Do QueueCodeLine^%occStorageUtil(.populate,closing,"$$$RemoveTempNode(^CacheTempPop($j)) Kill ^CacheTempPop($j)")
	If ($$$METHrunnable($$$gMGINFO,%class,"OnPopulate")) Do QueueCodeLine^%occStorageUtil(.populate,assignvals,"s save=obj.OnPopulate() i $$$ISERR(save) Do:verbose DisplayError^%apiOBJ(save) s obj="""" q")
	Do QueueCodeLine^%occStorageUtil(.populate,assignvals,"If 'keepobjects Do")
	Do QueueCodeLine^%occStorageUtil(.populate,saveobj,"Set save=obj.%Save()")
	Do QueueCodeLine^%occStorageUtil(.populate,saveobj,"If $$$ISOK(save) Set saved=saved+1,errcnt=0 If verbose Write !,""Object saved..."",saved")
	Do QueueCodeLine^%occStorageUtil(.populate,saveobj,"If $$$ISERR(save) set errcnt=errcnt+1 if verbose Do DisplayError^%apiOBJ(save)")
	Do QueueCodeLine^%occStorageUtil(.populate,keepobj,"If keepobjects Set objects($Increment(objects))=obj")
	Do QueueCodeLine^%occStorageUtil(.populate,keepobj,"Set obj=""""")

	Do QueueCodeLine^%occStorageUtil(.populate,closing,"If DeferIndices Do ..%SortEnd(,,1)")
	$$$comClassKeyGetLvar(schemaTableQ,%class,$$$cCLASSsqlqualifiednameQ)
	Do QueueCodeLine^%occStorageUtil(.populate,closing,"If tune Do TuneTable^%apiSQL("_$$quoter^%occClass(schemaTableQ)_",1,verbose,.%msg,1)")
		#; Here will will potentially also call TuneTable on the suprt extents of the class.
		#; First get a list of SuperExtents up to the RootExtent
	#; Determine the root extent class of this class from DEF
	set tSuperClasses=..GetSuperExtents(%class)
	if tSuperClasses'="" {
		Do QueueCodeLine^%occStorageUtil(.populate,closing,"If tune>1 {")
		for i=1:1:$l(tSuperClasses,"~") {
			$$$comClassKeyGetLvar(schemaTableQ,$p(tSuperClasses,"~",i),$$$cCLASSsqlqualifiednameQ)
			do QueueCodeLine^%occStorageUtil(.populate,closing,$c(9)_"do TuneTable^%apiSQL("_$$quoter^%occClass(schemaTableQ)_",1,verbose,.%msg,1)")
		}
		Do QueueCodeLine^%occStorageUtil(.populate,closing,"}")
	}

	Do QueueCodeLine^%occStorageUtil(.populate,closing,"Quit saved")

	Do DequeueFlowGraph^%occStorageUtil(.populate,.%code)

	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="GetSuperExtents">
<Description>
Given a class, return a '~' delimited list of the class's super extents</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSuperList="",tClass=pClass
loop	set tPrimarySuper=$piece($listget($get(^rINDEXCLASS($zconvert(tClass,"U"))),7),",")
	$$$NormalizeClassnameByDef(tPrimarySuper,tClass) if $$$ISERR(sc) { QUIT tSuperList }
	QUIT:tPrimarySuper="" tSuperList						// No super class
	if $$$comClassKeyGet(tPrimarySuper,$$$cCLASSnoextent) { QUIT tSuperList }	// Primary SuperClass is NoExtent	
	set tClassType = $$$getClassType(tPrimarySuper)
	if tClassType '= $$$cCLASSCLASSTYPEPERSISTENT { QUIT tSuperList }		// Primary super is not a persistent class
	QUIT:$e(tPrimarySuper,1)="%" tSuperList						// Hit a system class, don't want to return %Library.Persistent
	set tSuperList=tSuperList_$e("~",tSuperList'="")_tPrimarySuper
	set tClass=tPrimarySuper
	goto loop
]]></Implementation>
</Method>

<Method name="PopulateSerial">
<Description>
Create a single instance of a serial object.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<GenerateAfter>OnPopulate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	QUIT:'($$$getClassType(%class)=$$$cCLASSCLASSTYPESERIAL) $$$OK
	QUIT:($$$CLASSabstract($$$gMGINFO,%class)) $$$OK
	New assignvals,attrib,buildinstances,buildsamples,cardinality,classtype,closing,collection,concrete,dt,dts,i,initcode,max,min,p,popspec,populate,properties,references,relationship,spec,specatom,set,sett,typecategory,unordered,val,vallist,prop,order
	Set popspec=%parameter("POPSPEC")
	Set spec="" If popspec'="" QUIT:'$$ParseNestedString^%occStorageUtil(popspec,",",,.spec)
	For i=1:1:spec {
		Kill specatom
		If $$ParseNestedString^%occStorageUtil(spec(i),":",,.specatom)
		Set attrib=$Piece($Get(specatom(1)),":")
		If attrib '= "" {
			Set attrib(attrib)=$Select("#."'[$Extract(specatom(2),1):"##class(%PopulateUtils)."_specatom(2),$Extract(specatom(2))=".":"obj"_specatom(2),1:specatom(2))
			Set:specatom>2 attrib(attrib,"count")=specatom(3)
			Set:specatom>3 attrib(attrib,"key")=$Select("#."'[$Extract(specatom(4),1):"##class(%PopulateUtils)."_specatom(4),$Extract(specatom(4))=".":"obj"_specatom(4),1:specatom(4))
			Set:specatom>4 attrib(attrib,"concrete")=specatom(5)
			Set:specatom>5 attrib(attrib,"sqltable")=specatom(6)
			Set:specatom>6 attrib(attrib,"sqlcolumn")=specatom(7)
		}
	}
	Set references = 0, concrete = 0
		#; Set up the code generation structure...
	Do InitializeFlowGraph^%occStorageUtil(.populate)
		#; Initialize and generate the top level code blocks
	Set initcode = $$NewCodeBlock^%occStorageUtil(.populate,0,0)
	Do DefineLocalVariables^%occStorageUtil(.populate,initcode,"i,obj,save")

	Set buildsamples = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)
	Set assignvals = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)
	Set closing = $$NewCodeBlock^%occStorageUtil(.populate,initcode,0)
	Do QueueCodeLine^%occStorageUtil(.populate,initcode,"#class "_%class_" obj")
	Do QueueCodeLine^%occStorageUtil(.populate,assignvals,"Set obj=##class("_%class_").%New()")
	Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,"")
	While prop '= "" {
		If ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPprivate)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPreadonly)) && ('$$$comMemberKeyGet(%class,$$$cCLASSproperty,prop,$$$cPROPcalculated)) {
				#; suppress populate if POPORDER is less than zero!!
			set poporder = $$$comMemberArrayGet(%class,$$$cCLASSproperty,prop,$$$cPROPparameter,"POPORDER")
			if poporder '< 0 {
				$$$comMemberKeyGetLvar(relationship,%class,$$$cCLASSproperty,prop,$$$cPROPrelationship)
				$$$comMemberKeyGetLvar(cardinality,%class,$$$cCLASSproperty,prop,$$$cPROPcardinality)
				If ('relationship) || ((cardinality '= $$$cPROPCARDINALITYCHILDREN) && (cardinality '= $$$cPROPCARDINALITYMANY)) {
					$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,prop,$$$cPROPcollection)
					If (collection = "") || (collection = $$$cPROPCOLLECTIONLIST) || (collection = $$$cPROPCOLLECTIONARRAY) {
							#; The following check quits if the initialexpression is set because
							#; default values always override randomly generated values. In the case of a collection,
							#; the initialexpression applies to the collection object - not to the elements.
						If (collection '= "") || ($$$IVARinitialexpression($$$gMGINFO,%class,prop) = """""") {
							If (poporder) && ('$Data(properties(poporder))) { Set properties(poporder) = prop } Else { Set unordered(prop) = "" }
						}
					}
				}
			}
		}
		Set prop = $$$comMemberNext(%class,$$$cCLASSproperty,prop)
	}
	Set max = $Order(properties(""),-1)
	Set prop = $Order(unordered(""))
	While prop '= "" {
		Set properties($Increment(max)) = prop
		Set prop = $Order(unordered(prop))
	}
	Set p = $Order(properties(""))
	While p '= "" {
		Set prop = properties(p)
		$$$comMemberKeyGetLvar(dt,%class,$$$cCLASSproperty,prop,$$$cPROPtype)
		Set classtype = $$$getClassType(dt)
		Set spec = $$$PROPPARAM($$$gMGINFO,%class,prop,"POPSPEC")
			#; Is there a property parameter POPSPEC? If so, process this and discard any class POPSPEC info that might be around.
		If spec '= "" {
			Kill specatom, attrib(prop)
			If $$ParseNestedString^%occStorageUtil(spec,":",,.specatom)
				#; Prefix the value generator specified:
			Set attrib(prop) = $Select("#."'[$Extract(specatom(1),1):"##class(%PopulateUtils)."_specatom(1),$Extract(specatom(1))=".":"obj"_specatom(1),1:specatom(1))
				#; This is the collection element count
			Set:specatom>1 attrib(prop,"count") = specatom(2)
				#; and the collection key generator
			Set:specatom>2 attrib(prop,"key")=$Select("#."'[$Extract(specatom(3),1):"##class(%PopulateUtils)."_specatom(3),$Extract(specatom(3))=".":"obj"_specatom(3),1:specatom(3))
				#; and the size of a subdomain (extent)
			If specatom>3 Set attrib(prop,"concrete")=specatom(4)
			Set:specatom>4 attrib(prop,"sqltable")=specatom(5)
			Set:specatom>5 attrib(prop,"sqlcolumn")=specatom(6)
		}
		 	#; typecategory is set based on collection because collections do not behave nicely. The typecategory for collections
		 	#; is based on the collection class, not the defined type class.
		Set typecategory = $Case(classtype,$$$cCLASSCLASSTYPEDATATYPE:"literal",$$$cCLASSCLASSTYPEPERSISTENT:"reference",$$$cCLASSCLASSTYPESTREAM:"stream",:"serial")
		$$$comMemberKeyGetLvar(collection,%class,$$$cCLASSproperty,prop,$$$cPROPcollection)
		If collection = "" {
			If (typecategory = "literal") || (typecategory = "stream")  {
				Set set = "Set obj."_$$$QN(prop)_"="
				Set sett = ""
			}
			ElseIf typecategory = "reference" {
				Set set = "Set id="
				Set sett = " If (id'=""""),(##class("_dt_").%ExistsId(id)) Do obj."_$$$QN(prop_"SetObjectId")_"(id)"
			}
			Else {
				Set set = "Do obj."_$$$QN(prop_"SetObject")_"("
				Set sett = ")"
			}
		}
		Else {
			Set lvars = "elem,cval"
			Set set = "f elem=1:1:$$$PRand("_($Select('$Get(attrib(prop,"count")):"10",1:attrib(prop,"count"))+1)_") s cval="
			If collection = $$$cPROPCOLLECTIONARRAY {
				Set lvars = lvars_",key"
				Set sett=" s key="_$Select($Get(attrib(prop,"key"))="":"##class(%PopulateUtils).String(4)",1:attrib(prop,"key"))_" d obj."_$$$QN(prop)_$Select(typecategory="literal":".SetAt(",typecategory="reference":".SetObjectIdAt(",1:".SetObjectAt(")_"cval,key)"
			}
			ElseIf collection = $$$cPROPCOLLECTIONLIST {
				Set sett = " d obj."_$$$QN(prop)_$Select(typecategory="literal":".Insert(",typecategory="reference":".InsertObjectId(",1:".InsertObject(")_"cval)"
			}
			Set:typecategory="reference" sett = " If (cval'=""""),(##class("_dt_").%ExistsId(cval))"_sett
			Do DefineLocalVariables^%occStorageUtil(.populate,initcode,lvars)
		}
			#; If an override value generator was specified in POPSPEC, use it now!
		Set val = $Get(attrib(prop))
		If val = "" {
				#; If there is a value list, pick a value from it...
			Set vallist = $$$PROPPARAM($$$gMGINFO,%class,prop,"VALUELIST")
			if vallist = "" { set vallist = $$$PROPPARAM($$$gMGINFO,%class,prop,"DISPLAYLIST") }
			If vallist '= "" { Set val = "##class(%PopulateUtils).ValueList("""_vallist_""")" }
				#; If the property's type class is SERIAL then check to see if it can be populated
				#; if it can then generate a call to dt.PopulateSerial
			ElseIf typecategory = "serial" {
				If $$$comMemberKeyGet(dt,$$$cCLASSmethod,"PopulateSerial",$$$cMETHrunnable) { Set val = "##class("_dt_").PopulateSerial()" }
			}
			ElseIf typecategory = "reference" {
					#; can't generate a reference if the target isn't persistent...
				If ($$$getClassType(dt) = $$$cCLASSCLASSTYPEPERSISTENT) {
					If $Get(references(dt)) = "" {
						Set references=references+1,references(dt)="rss"_references
						Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"d ##class(%PopulateUtils).BuildReferenceSample("""_dt_""",."_references(dt)_")")
						Do DefineLocalVariables^%occStorageUtil(.populate,initcode,references(dt)_",ref,id")
					}
					Set val = "##class(%PopulateUtils).ArrayElement(."_references(dt)_") "
				}
			}
			ElseIf typecategory = "literal" {
				Set val = ""
				Set dts = $$$ClassShortName(dt), ucProp = $$$ucase(prop)
				Set val = $Case(ucProp,
							"NAME":		"##class(%PopulateUtils).Name()",
							"SSN":		"##class(%PopulateUtils).SSN()",
							"COMPANY":	"##class(%PopulateUtils).Company()",
							"TITLE":	"##class(%PopulateUtils).Title()",
							"PHONE":	"##class(%PopulateUtils).USPhone()",
							"CITY":		"##class(%PopulateUtils).City()",
							"STREET":	"##class(%PopulateUtils).Street()",
							"ZIP":		"##class(%PopulateUtils).USZip()",
							"MISSION":	"##class(%PopulateUtils).Mission()",
							"STATE":	"##class(%PopulateUtils).USState()",
							:"")
					#; If no value generator is assigned by the property name rule then proceed with the property type rule:
				If val = "" {
					set minlen = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINLEN"), maxlen = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXLEN")
					if (dts = "String") && (minlen > 1) { set val = "##class(%PopulateUtils).StringMin("_minlen_","_maxlen_")" }
					else {
						Set val = $Case(dts,
							"String":		"##class(%PopulateUtils).String("_maxlen_")",
							"Integer":		"##class(%PopulateUtils).Integer("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Date":			"##class(%PopulateUtils).Date("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Binary":		"##class(%PopulateUtils).String("_maxlen_")",
							"Double":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Name":			"##class(%PopulateUtils).Name()",
							"Boolean":		"$$$PRand(2)",
							"Currency":		"##class(%PopulateUtils).Currency("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"Float":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Numeric":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"Decimal":		"##class(%PopulateUtils).Float("_($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_","_($$$PROPPARAM($$$gMGINFO,%class,prop,"SCALE"))_")",
							"PosixTime":		"##class(%PopulateUtils).PosixTime("_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							"TimeStamp":		"##class(%PopulateUtils).TimeStamp("_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL"))_","_$$$quote($$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL"))_")",
							:				"")
					}
						#; None of the above? try SmallInt and Time:
					If val = "" {
						If dts="SmallInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":32767,max>32767:32767,1:max)
							Set min = $Select(min="":-32768,min<-32768:-32768,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						ElseIf dts = "Time" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":86399,max>86399:86399,1:max)
							Set min = $Select(min="":0,min<0:0,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						elseif dts="TinyInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":127,max>127:127,1:max)
							Set min = $Select(min="":-128,min<-128:-128,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
						elseif dts="BigInt" {
							Set min = $$$PROPPARAM($$$gMGINFO,%class,prop,"MINVAL")
							Set max = $$$PROPPARAM($$$gMGINFO,%class,prop,"MAXVAL")
							Set max = $Select(max="":100000000000000000,max>100000000000000000:100000000000000000,1:max)
							Set min = $Select(min="":-100000000000000000,min<-100000000000000000:-100000000000000000,1:min)
							Set val = "##class(%PopulateUtils).Integer("_min_","_max_")"
						}
					}
				}
			}
		}
		If $Get(attrib(prop,"concrete")) && (val '= "") {
			Set concrete = concrete + 1
			If ($Get(attrib(prop,"sqltable")) = "") || ($Get(attrib(prop,"sqlcolumn")) = "") {
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Set ^CacheTemp(cptr,"_concrete _ ") = " _ attrib(prop,"concrete") _", cextcnt = 0")
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"While cextcnt < " _ attrib(prop,"concrete") _ " { Set val = " _ val _ " If '$d(^CacheTemp(cptr,"_concrete _ ",""u"",val)) { Set cextcnt = cextcnt + 1, ^CacheTemp(cptr," _ concrete _ ",""u"",val) = cextcnt, ^CacheTemp(cptr," _ concrete _ ",cextcnt) = val } }")
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Kill ^CacheTemp(cptr," _ concrete _ ",""u"")")
			}
			Else {
				Do QueueCodeLine^%occStorageUtil(.populate,buildsamples,"Set sc = ##class(%Library.PopulateUtils).BuildValueSetSQL(cptr," _ concrete _ "," _ $$$quote(attrib(prop,"sqltable")) _ "," _ $$$quote(attrib(prop,"sqlcolumn")) _ "," _  attrib(prop,"concrete") _ ")")
			}
			Set val = "##class(%PopulateUtils).ExtentValue(cptr," _ concrete _ ")"
		}
		If val = "" { Set val = """""" }
		Do QueueCodeLine^%occStorageUtil(.populate,assignvals,set_val_sett)
		Set p = $Order(properties(p))
	}
 		#; concrete is a local array of the concrete literal subextents. When it exists it means that some
 		#; value extents must be made concrete and a random selection from that concrete set is used.
 		#; The parameters affecting value generation are considered when the concrete set is built. Value selection
 		#; is simply a random choice. Here we will allocate space in ^CacheTemp
	If concrete {
		Do DefineLocalVariables^%occStorageUtil(.populate,initcode,"cptr,cextcnt,val")
		Do QueueCodeLine^%occStorageUtil(.populate,initcode,"Set cptr = $Increment(^CacheTemp)")
		Do QueueCodeLine^%occStorageUtil(.populate,initcode,"$$$AddTempNode(^CacheTemp(cptr))")

		Do QueueCodeLine^%occStorageUtil(.populate,closing,"$$$RemoveTempNode(^CacheTemp(cptr))")
	}

	If ($$$METHrunnable($$$gMGINFO,%class,"OnPopulate")) Do QueueCodeLine^%occStorageUtil(.populate,closing,"s save=obj.OnPopulate() i $$$ISERR(save) Do:verbose DisplayError^%apiOBJ(save) s obj="""" q")
	Do QueueCodeLine^%occStorageUtil(.populate,closing,"If obj.%GetSwizzleObject(1,.save)")
	Do QueueCodeLine^%occStorageUtil(.populate,closing,"Set obj=""""")
	Do QueueCodeLine^%occStorageUtil(.populate,closing,"Quit save")
	Do DequeueFlowGraph^%occStorageUtil(.populate,.%code)

	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="OnPopulate">
<Abstract>1</Abstract>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
</Method>

<Method name="Random">
<Description><![CDATA[
Return a random number from 0-<var>n</var> using a seeded RNG. Identical to $$$PRand]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>n:%Integer</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	//$ZU(165 was seeded in Populate()
	Quit $$$PRand(n)
]]></Implementation>
</Method>
</Class>


<Class name="%Library.PopulateUtils">
<Description><![CDATA[
The <CLASS>%PopulateUtils</CLASS> class contains a number of utility methods used by the 
<CLASS>%Populate</CLASS> class.]]></Description>
<IncludeCode>%occInclude</IncludeCode>
<IncludeGenerator>%occInclude</IncludeGenerator>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>

<Method name="ArrayElement">
<Description>
Return a random array element.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&array]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ QUIT $s($g(array):$g(array($$$PRand(array)+1)),1:"")
]]></Implementation>
</Method>

<Method name="ExtentValue">
<Description>
Return a random value from a concrete value extent.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cptr:%Integer,cext:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ QUIT $s($g(^CacheTemp(cptr,cext)):$g(^CacheTemp(cptr,cext,$$$PRand(^CacheTemp(cptr,cext))+1)),1:"")
]]></Implementation>
</Method>

<Method name="BuildReferenceSample">
<Description><![CDATA[
	Return an array of ids selected randomly from the 
	Extent query of the class in the <var>sample</var> parameter. The array is of the form: 
	sample=n 
	sample(1)=id1,sample(2)=id2,...,sample(n)=idn 
	Parameters: 
	class   - the class to retrieve samples from 
	sample  - the array of samples (returned) 
	size    - the maximum number of samples to retrieve 
	selpct  - the percentage of instances to be randomly selected. 
	for example, 25 means approximately 25% of the instances 
	will be selected (1 in 4).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class,sample,size=500,selpct=25</FormalSpec>
<Implementation><![CDATA[
 New count,density,rs,sc
 Set density=$s(selpct>90:2,selpct>74:4,selpct>49:6,selpct>39:5,selpct>24:36,selpct>12:7,1:29)
 Kill sample
 Set sample=0
 QUIT:$g(class)=""
 Set rs=##class(%ResultSet).%New(class_".Extent")
 Set sc=rs.Execute()
 If $$$ISERR(sc) Set rs="""" QUIT
 For count=1:1 Quit:rs.Next()=0  i '(density#($$$PRand(density)+1)) s sample=sample+1,sample(sample)=rs.GetData(1) Quit:sample=size
 #; If the sample is less than 50% of requested size then select all of the instances...
 If (sample/size)<.5,count>sample DO
 . Do rs.Close()
 . Set sc=rs.Execute()
 . Quit:$$$ISERR(sc)
 . Kill sample
 . Set sample=0
 . For  Quit:rs.Next()=0  s sample=sample+1,sample(sample)=rs.GetData(1) Quit:sample=size
 QUIT
]]></Implementation>
</Method>

<Method name="BuildValueSetSQL">
<Description>
Populate a value set from a query</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cptr,cext,table,column,size=500,verbose:%Integer=0</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ('$Get(cptr)) || ('$Get(cext)) || ( table = "" ) || ( column = "" ) Quit $$$ERROR($$$GeneralError,"Invalid BuildValueSet parameters")
	Set sql = "select DISTINCT(" _ $Select($$$ucase(column)'["%EXACT":"%EXACT("_column_")",1:column) _ ") from " _ table
	Set rs = ##class(%Library.ResultSet).%New()
	Set sc = rs.Prepare(sql)
	If $$$ISERR(sc) Quit $$$ERROR($$$GeneralError,"Cannot prepare BuildValueSetSQL dynamic query: " _ $Get(%msg))
	Set sc=rs.Execute()
	If $$$ISERR(sc) Quit $$$ERROR($$$GeneralError,"Cannot execute BuildValueSetSQL dynamic query: " _ $Get(%msg))
	Set temp = $Increment(^CacheTemp)
	$$$AddTempNode(^CacheTemp(temp))
	Set ^CacheTemp(temp) = 0
	If verbose { Write !,sql }
	Set next = rs.Next()
	While next {
		Set ^CacheTemp(temp,$Increment(^CacheTemp(temp))) = rs.GetData(1)
		If verbose && ('(^CacheTemp(temp)#1000)) { Write "." }
		Set next = rs.Next()
	}
	Set sc = rs.Close()
	If verbose { Write "(",^CacheTemp(temp),")" }
	Set ^CacheTemp(cptr,cext) = 0, cextcnt = 0, domainsize = ^CacheTemp(temp)
	If size '< domainsize {
		If verbose { Write !," requested number is greater than domain size, taking all values." }
		Merge ^CacheTemp(cptr,cext) = ^CacheTemp(temp)
	}
	Else {
		If verbose { Write !,"Selecting ",size," random values" }
		While cextcnt < size {
			Set valptr = $$$PRand(domainsize) + 1
			If '$d(^CacheTemp(cptr,cext,"u",valptr)) {
				Set val = ^CacheTemp(temp,valptr)
				Set cextcnt = $Increment(^CacheTemp(cptr,cext)), ^CacheTemp(cptr,cext,"u",valptr) = cextcnt, ^CacheTemp(cptr,cext,cextcnt) = val
				If verbose && ('(cextcnt#1000)) { Write "." }
			}
		}
		Kill ^CacheTemp(cptr,cext,"u")
	}
	Kill ^CacheTemp(temp)
	$$$RemoveTempNode(^CacheTemp(temp))
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="City">
<Description>
Return a random city name.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n t1
 s t1=$lb("Albany","Boston","Bensonhurst","Chicago","Denver","Elmhurst","Fargo","Gansevoort","Hialeah","Islip","Jackson","Larchmont","Miami","Newton","Oak Creek","Pueblo","Queensbury","Reston","St Louis","Tampa","Ukiah","Vail","Washington","Xavier","Youngstown","Zanesville")
 Quit $li(t1,$$$PRand($ll(t1))+1)
]]></Implementation>
</Method>

<Method name="Company">
<Description>
Return a random company name.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New c1,c2,c3

 Set c1=$LB("Compu","Dyna","Quanta","Hyper","Meta","Kwal","Opti","Robo","Tera","Mega","Giga","Xena","Micro","Macro","Inter","Yoyo","Medi","Pico","Accu","Globa","Octo","Cyber","Tele","Syner","Securi","Bio","Intra")
 Set c2=$LB("Dyne","Sys","Tron","Matix","mo","gy","Sonics","Calc","Tel","Soft","Dynamics","Pedia","Systems","Net","Data","Ware","Glomerate","Lateral","Tech","Plex","Comp")
 Set c3=$LB(" Inc."," Corp."," Media Inc."," Holdings Inc.",".com"," LLC."," Group Ltd."," Associates"," Partners"," Gmbh.")

 Quit $LI(c1,$$$PRand($LL(c1))+1)_$LI(c2,$$$PRand($LL(c2))+1)_$LI(c3,$$$PRand($LL(c3))+1)
]]></Implementation>
</Method>

<Method name="Currency">
<Description><![CDATA[
Return a random currency value between <var>min</var> and <var>max</var> (if present).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>min:%Integer=0,max:%Integer=10000</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[ Quit ##class(%PopulateUtils).Float(min,max,4)
]]></Implementation>
</Method>

<Method name="Date">
<Description><![CDATA[
Return a random date value in <i>Cach&eacute;</i> <code>$H</code> format.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>min:%Date,max:%Integer</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	if '$Get(min) { set min = 30000 }
	if '$Get(max) { set max = +$h }
	if min>max Quit 0
	quit min+$$$PRand(max-min+1)
]]></Implementation>
</Method>

<Method name="CDate">
<ClassMethod>1</ClassMethod>
<FormalSpec>format:%Integer=1,min:%Date=30000,max:%Date=55000</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 If min>max Quit 0
 Quit $zdate(##class(%Library.PopulateUtils).Date(min,max),format)
]]></Implementation>
</Method>

<Method name="Counter">
<ClassMethod>1</ClassMethod>
<FormalSpec>counter:%String="c",initial:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 If '$Data(^CacheTempPop($j,"c",counter)) Set ^CacheTempPop($j,"c",counter) = initial Quit initial
 Quit $Increment(^CacheTempPop($j,"c",counter))
]]></Implementation>
</Method>

<Method name="FirstName">
<Description><![CDATA[
Return a string containing a random first name.
<p><var>gender</var> is a optional string used to control the 
gender of the generated name: 1 is Male, 2 = Female, "" is either.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>gender:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New list
 #; gender is 1:MALE,2:FEMALE
 s:$g(gender)="" gender=$$$PRand(2)+1

 If (gender = 1) {
 Set list = $LB("Al","Alfred","Alvin","Andrew","Angelo","Aviel",
 "Bart","Bill","Bob","Brendan","Brian","Buzz","Chad",
 "Charles","Chris","Clint","Dan","Dave",
 "David","Dick","Dmitry","Ed","Edgar","Edward",
 "Elmo","Elvis","Emilio","Fred","Geoffrey",
 "George","Howard","James","Jeff","Joe","John",
 "Jose","Joshua","Jules","Keith","Kenny","Kevin",
 "Lawrence","Mark","Mario","Martin","Marvin","Michael","Milhouse",
 "Mo","Neil","Norbert","Orson","Patrick","Paul",
 "Peter","Phil","Quentin","Quigley","Ralph",
 "Richard","Rob","Robert","Roger","Sam","Stavros",
 "Stuart","Ted","Terry","Umberto","Vincent",
 "Will","William","Wolfgang","Xavier","Zeke")
 }
 Else {
 Set list = $lb("Agnes","Alexandra","Alice","Amanda","Angela","Ashley",
 "Barb","Barbara","Belinda","Brenda",
 "Charlotte","Chelsea","Christine","Christen",
 "Danielle","Debra","Debby","Diane","Elvira","Emily","Emma",
 "Filomena","Frances","Gertrude","Greta","Hannah","Heloisa","Imelda",
 "Jane","Janice","Jocelyn","Josephine","Juanita","Julie",
 "Kim","Kirsten","Kristen","Kyra","Laura",
 "Linda","Lisa","Liza","Lola","Lydia",
 "Maria","Mary","Maureen","Michelle","Molly",
 "Nataliya","Natasha","Nellie",
 "Olga","Pam","Pat","Patricia","Phyllis",
 "Rhonda","Roberta","Sally","Samantha","Sophia","Susan",
 "Tara","Terry","Thelma",
 "Uma","Usha","Valery","Violet","Wilma","Yan","Zelda","Zoe")
 }

 Quit $LI(list,$$$PRand($LL(list))+1)
]]></Implementation>
</Method>

<Method name="Float">
<Description><![CDATA[
Return a random floating point value between <var>min</var> 
and <var>max</var> (if present).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>min:%Float=0,max:%Float=10000,scale:%Integer=0</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If max '> min { Quit "" }
	If scale > 17 { Set scale = 17 }
	Set factor = 10 ** scale
		#; Normalize min and max
	Set minn = (min*factor\1)/factor, maxn = (max*factor\1)/factor
	Set range = maxn - minn
		#; smaller values are simpler
	If ($Length(range\1) + scale) < 17 { Quit +(((minn * factor) + $$$PRand(range * factor + 1)) / factor) }
		#; generate large values as two separate random values
		#; This algorithm slightly favors min and max in some cases but allows for floats with large scale values
		#; first, make sure that range and factor don't trigger a function error.
	set range = $Extract(range,1,17), factor = $Extract(factor,1,17)
	Set float = minn + $$$PRand(range) + $Select(scale:+($$$PRand(factor+1)/factor),1:0)
	Quit $Select((float<max)&(float>min):float,float'<max:maxn,1:minn)
]]></Implementation>
</Method>

<Method name="Integer">
<Description><![CDATA[
Return a random integer value between <var>min</var> 
and <var>max</var> (if present).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>min:%Integer=0,max:%Integer=1000000000</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	if min > max quit 0
	set range = max - min + 1
	if range '> 1E17 { quit min+$$$PRand(range) }
	set range1 = $$$PRand(1E17)
	set range2 = $$$PRand(range\1E17)
	quit min + (range2*1E17) + range1
]]></Implementation>
</Method>

<Method name="LastName">
<Description>
Return a string containing a random last name.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New list,x
 Set x = $$$PRand(26)+1

 If (x = 1) 	{ Set list = $LB("Allen","Avery","Adam","Adams","Alton","Ahmed","Anderson") }
 ElseIf (x = 2)	{ Set list = $LB("Baker","Beatty","Burroughs","Bach","Bachman","Black","Brown","Browne","Browning","Braam","Basile","Bukowski","Bush") }
 ElseIf (x = 3)	{ Set list = $LB("Chadbourne","Cheng","Chang","Campos","Cannon","Chadwick","Chesire","Clinton","Clay","Connors","Cooke","Cooper","Cerri","Cunningham") }
 ElseIf (x = 4)	{ Set list = $LB("Diavolo","DeSantis","Djakovic","DeLillo","Drabek","Donaldson","Davis","Dunlap","Duquesnoy") }
 ElseIf (x = 5)	{ Set list = $LB("Evans","Edwards","Eisenstien","Edison","Emerson","Eno","Eastman","Eagleman") }
 ElseIf (x = 6)	{ Set list = $LB("Frith","Fripp","Finn","Faust","Fives","Frost","Feynman") }
 ElseIf (x = 7)	{ Set list = $LB("Gaboriault","Geoffrion","Gomez","Gallant","Goldman","Gore","Gibbs","Gold","Goncharuk","Grabscheid","Garcia") }
 ElseIf (x = 8)	{ Set list = $LB("Houseman","Huff","Hanson","Harrison","Hills","Hertz","Hammel","Humby","Hernandez") }
 ElseIf (x = 9)	{ Set list = $LB("Isaksen","Ironhorse","Ipsen","Ingrahm","Ingersol","Iacobelli","Ingleman","Isaacs","Ihringer") }
 ElseIf (x = 10)	{ Set list = $LB("Jafari","Joyce","Jackson","Jones","Johnson","Jaynes","Jung","Jenkins") }
 ElseIf (x = 11)	{ Set list = $LB("Koivu","Kovalev","King","Klingman","Kelvin","Klein","Klausner","Kratzmann","Koenig") }
 ElseIf (x = 12)	{ Set list = $LB("Larson","Leiberman","Lennon","Lepon","Levinson","Long","LaRocca","Lee","Li","Lubbar","Love","Loveluck","Lopez") }
 ElseIf (x = 13)	{ Set list = $LB("Mara","Massias","Malkovich","Moon","Murphy","Murray","McCormick","Macrakis","Mailer","Munt","Martinez","Mastrolito","Minichillo","Monroe","Malynko","Miller","Marks","McCoy") }
 ElseIf (x = 14)	{ Set list = $LB("Noodleman","Novello","Nagel","Nathanson","Newton","Nelson","North","Ng","Nichols") }
 ElseIf (x = 15)	{ Set list = $LB("O'Donnell","O'Brien","O'Rielly","Orwell","Orlin","Ott","Olsen") }
 ElseIf (x = 16)	{ Set list = $LB("Page","Paladino","Palmer","Pantaleo","Pape","Paraskiv","Pascal","Perez","Peters","Peterson","Petersburg","Pybus","Presley","Press") }
 ElseIf (x = 17)	{ Set list = $LB("Quigley","Quilty","Quince","Quincy","Quine","Quixote") }
 ElseIf (x = 18)	{ Set list = $LB("Ramsay","Ragon","Ravazzolo","Rogers","Rotterman","Roentgen","Rodriguez","Russell") }
 ElseIf (x = 19)	{ Set list = $LB("Smith","Smyth","Schultz","Schulte","Salm","Sato","Schaefer","Simpson","Sands","Solomon","Semmens","Sorenson","Sverdlov") }
 ElseIf (x = 20)	{ Set list = $LB("Tesla","Tsatsulin","Tweed","Thompson","Taylor","Tillem","Townsend") }
 ElseIf (x = 21)	{ Set list = $LB("Ubertini","Uhles","Ueckert","Umansky","Uberoth","Ulman","Underman") }
 ElseIf (x = 22)	{ Set list = $LB("Van De Griek","Vanzetti","Vivaldi","Vonnegut") }
 ElseIf (x = 23)	{ Set list = $LB("Waal","Walker","Wilson","Woo","Wells","Waters","Willeke","Wijnschenk","Waterman","Winters","White","Williams","West") }
 ElseIf (x = 24)	{ Set list = $LB("Xander","Xavier","Ximines","Xerxes","Xenia","Xiang") }
 ElseIf (x = 25)	{ Set list = $LB("Young","Yeats","Yang","Yu","Yancik","Yakulis","Yezek","Yoders") }
 ElseIf (x = 26)	{ Set list = $LB("Zemaitis","Zubik","Zimmerman","Zevon","Zucherro","Zampitello","Zweifelhofer") }

 Quit $LI(list,$$$PRand($LL(list))+1)
]]></Implementation>
</Method>

<Method name="Mission">
<Description>
Returns a string containing a randomly generated corporate mission statement.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New c1,c2,c3,c4,c5,c6
 Set c1=$LB("Leaders in ","Developers of ","Providers of ","Resellers of ","On-line distributors of ","Experts in ","Specializing in the development and manufacturing of ","Post-sale services for ","Spearheading the next generation of ","The industry leader in ","Enabling individuals and businesses to manage ","Building shareholder value by delivering ")
 Set c2=$LB("","advanced ","cutting-edge ","breakthrough ","complex ","high-performance ","scalable ","just-in-time ","open ","personal ","high-tech ","high-touch ","open-source ","virtual ","interactive ","eco-friendly ","agile ","cloud-based ","premise-based ","sustainable ","intelligent ","innovative ","world-class ","knowledge-based ","compliant ","secure ","standards-based ","disruptive ","non-linear ","dynamic ","enhanced ","real-time ","synergistic ")
 Set c3=$LB("","quantum ","nano-","hyper-","optical ","financial ","multi-media ","object-oriented ","broad-band ","secure ","digital ","enterprise ","crowd-sourced ","genetic ","wireless ","satellite-based ","ISO 9003-ready ","Web 3.0 ","HTML5 ","post-Microsoft ","natural language ","big data ","predictive analytic ","seven-sigma ","distributed ","massively-parallel ","mission-critical ")
 Set c4=$LB("","devices and ","instrumentation ","graphical ","XML ","Internet ","application development ","database ","data warehouse ","forecasting ","voice-enabled ","cold-fusion powered ","platforms for ","advanced ","virtualized ")
 Set c5=$LB("services ","technologies ","media ","content ","middle-ware ","connectivity ","consulting services ","gaming ","models ","productivity tools ","instruments ","marketing services ","apps ")
 Set c6=$LB("for on-line commerce.","for the Financial community.","for discriminating investors.","for the Entertainment industry.","for consumers.","for the Fortune 5.","for the Fortune 50.","for the Fortune 500.","for the Fortune 5000.","for the enterprise.","for the desktop.","for the Health Care community.","for mobile devices.","for social networks.","for industry and government.","for emerging markets.","for industry and academia.","for capital markets.","for high-worth individuals.","for our long-term clients.","for the pharmaceutical industry.","for additive manufacturing.")
 Quit $LI(c1,$$$PRand($LL(c1))+1)_$LI(c2,$$$PRand($LL(c2))+1)_$LI(c3,$$$PRand($LL(c3))+1)_$LI(c4,$$$PRand($LL(c4))+1)_$LI(c5,$$$PRand($LL(c5))+1)_$LI(c6,$$$PRand($LL(c6))+1)
]]></Implementation>
</Method>

<Method name="Name">
<Description><![CDATA[
Return a string containing a random name as <i>lastname,firstname</i>.
<p><var>gender</var> is a optional string used to control the 
gender of the generated name: 1 is Male, 2 = Female, "" is either.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>gender:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ Quit ..LastName()_","_..FirstName($g(gender))_" "_$C($$$PRand(26)+65)_"."
]]></Implementation>
</Method>

<Method name="SSN">
<Description>
Return a random U.S. Social Security Number.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[($$$PRand(899)+100)_"-"_($$$PRand(89)+10)_"-"_($$$PRand(8999)+1000)
]]></Implementation>
</Method>

<Method name="String">
<Description><![CDATA[
Return a string value of the form <random character>_<random number less than 9999> and whose length
does not exceed <var>len</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>len:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ QUIT $e($c($$$PRand(26)+65)_$$$PRand(9999),1,$s(len>0:len,1:1))
]]></Implementation>
</Method>

<Method name="StringMin">
<Description><![CDATA[
Return a random string value whose length is at least <var>minlen</var> and not greater than <var>maxlen</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>minlen:%Integer=1,maxlen:%Integer=1</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	if maxlen '< minlen { set len=$$$PRand(maxlen-minlen+1)+minlen, string="" for i=1:1:len { Set charn=$s($$$PRand(2):$$$PRand(26)+65,1:$$$PRand(26)+97),string=string_$s(charn<123:$c(charn),1:" ") } quit string } else { quit "" }
]]></Implementation>
</Method>

<Method name="Street">
<Description>
Return a random street address.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n t1,t2
 s t1=$lb("Maple","Ash","Elm","Oak","Main","First","Second","Washington","Franklin","Clinton","Madison"), t2=$lb("Street","Avenue","Blvd","Court","Place","Drive")
 Quit ($$$PRand(9999)+1)_" "_$li(t1,$$$PRand($ll(t1))+1)_" "_$li(t2,$$$PRand($ll(t2))+1)
]]></Implementation>
</Method>

<Method name="Syllable">
<Description>
	Return a string of random syllables and spaces. 
	The algorithm uses several syllable 'lists'. First, a list is randomly 
	chosen. Then a syllable from that list is chosen and added to the string. 
	Then, if a random boolean is TRUE, a space is appended. Syllables are added to the 
	string until the string length exceeds a random length less than or equal 
	to the parameter maxlen.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>maxlen:%Integer=30</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New len,p,s,string
 Set len=$$$PRand(maxlen)+1
 Set s(1)=$lb("A","I","Am","An","Iso","Ic")
 Set s(2)=$lb("Lo","Ly","Re","Co","To","On","Op")
 Set s(3)=$lb("Com","Syn","Tri","Uni","Via","Geo","Ism","Ion","Ies","Two","Pus","Tech","Quo")
 Set s(4)=$lb("Able","Cycle","Atic","Look","Mili","Nano","Octo","Pyro","Status","Kilo","Dyna","Endo","Ecto","Gyro","Heli","Atic","Able","Look","Much","Graph","Gram","Wave","Sound","Plasm","Physical","Scope","Copter","Morph","Range","Pede","Second","Zeno","Photo","Type","Much","Invent","Thetic")
 Set string=""
 For  q:$l(string)>len  s p=$$$PRand(4)+1 s string=string_$li(s(p),$$$PRand($ll(s(p)))+1) s:$$$PRand(2) string=string_" "
 Quit $extract(string,1,len)
]]></Implementation>
</Method>

<Method name="TimeStamp">
<Description><![CDATA[
	Return a random TimeStamp value that is between the specified <var>min</var> and <var>max</var> timestamp values. 
	The default <var>min</var> value is the default <method>Date</method> min date value with time = 0. 
The default <var>max</var> value is the default <method>Date</method> max date value with time = 86399 (23:59:59). 
	If either <var>min</var> or <var>max</var> is not a valid %TimeStamp value, then the default value is used instead.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>min:%TimeStamp,max:%TimeStamp</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	try {
		if $Get(min) '= "" { set minh = $zdth(min,3) set mindateh = $Piece(minh,",",1), mintimeh = $Piece(minh,",",2) } else { set mindateh = "", mintimeh = 0 }
		if $Get(max) '= "" { set maxh = $zdth(max,3) set maxdateh = $Piece(maxh,",",1), maxtimeh = $Piece(maxh,",",2) } else { set maxdateh = "", maxtimeh = 86399 }
	}
	catch tException { set mindateh = "", mintimeh = 0, maxdateh = "", maxtimeh = 86399 }
	Set date=##class(%PopulateUtils).Date(mindateh,maxdateh)
	Set time=##class(%PopulateUtils).Integer(mintimeh,maxtimeh)
	Quit $zd(date,3)_" "_$zt(time,1)
]]></Implementation>
</Method>

<Method name="Title">
<Description>
Return a random job title.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New t1,t2

 Set t1=$LB("","Senior ","Associate ","Assistant ","Strategic ","Global ","Laboratory ","Executive ")
 Set t2=$LB("Engineer","Sales Rep.","Support Engineer","Developer","Marketing Manager","Accounts Rep.","Resources Director","Director","Product Manager","Research Asst.","Systems Engineer","Technician","WebMaster","Administrator","Product Specialist","Accountant","Hygienist")

 Quit $LI(t1,$$$PRand($LL(t1))+1)_$LI(t2,$$$PRand($LL(t2))+1)
]]></Implementation>
</Method>

<Method name="USPhone">
<Description>
Return a random U.S. phone number.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[($$$PRand(799)+200)_"-"_($$$PRand(799)+200)_"-"_($$$PRand(8999)+1000)
]]></Implementation>
</Method>

<Method name="USState">
<Description>
Return a random U.S. state abbreviation.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n t1
 s t1=$lb("AK","AL","AR","AZ","CA","CO","CT","DE","FL","GA","HI","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WI","WV","WY")
 Quit $li(t1,$$$PRand($ll(t1))+1)
]]></Implementation>
</Method>

<Method name="USZip">
<Description>
Return a random U.S. Zone Improvement Plan (ZIP) code.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[($$$PRand(89999)+10000)
]]></Implementation>
</Method>

<Method name="ValueList">
<Description>
Return a random piece from a delimited list. The first character in the list is the delimiter.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>vallist</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 New del
 Set del=$e(vallist,1)
 Quit $piece(vallist,del,$$$PRand($length(vallist,del)-1)+2)
]]></Implementation>
</Method>

<Method name="VarString">
<Description><![CDATA[
Return a random string value of random length 
up to <var>maxlen</var> characters.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>maxlen:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n i,len,string
 s:'$g(maxlen) maxlen=1
 s len=$$$PRand(maxlen)+1
 s string=""
 For i=1:1:len Set string=string_$c($$$PRand(64)+32)
 QUIT string
]]></Implementation>
</Method>

<Method name="Color">
<Description>
Return a random color name (one of 5 possible values).</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n t1
 s t1=$lb("Red","Green","Blue","Yellow","Black")
 Quit $li(t1,$$$PRand($ll(t1))+1)
]]></Implementation>
</Method>

<Method name="Product">
<Description>
Return a random product name (one of 4 possible values).</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n t1
 s t1=$lb("Table","Chair","Lamp","Desk")
 Quit $li(t1,$$$PRand($ll(t1))+1)
]]></Implementation>
</Method>

<Method name="Random">
<Description><![CDATA[
Return a random number from 0-<var>n</var> using a random number generator that is
seeded by <class>%Library.Populate</class>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit ##class(%Populate).Random(n)
]]></Implementation>
</Method>
</Class>


<Class name="%Library.ProcedureContext">
<Description>
Stored procedure context</Description>
<Super>%Library.IProcedureContext</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59735,38932.814951</TimeCreated>

<Property name="%LTT">
<Description>
%LTT is an array of temporary table storage indexes subscripted by temp table name.</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="PTT">
<Description>
PTT is an array of private temporary table orefs subscripted by temp table name.
Private Temporary Table to OREF index.</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="TTNI">
<Description>
TTNI is an array of private temporary table names subscripted by UPPERCASE source language temporary tablename. This property is used to resolve a source language table reference to a Cache private temporary table name.
TTNI = temporary table name index</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Results">
<Description>
Results is a MD-style collection of result objects. This repository is
private and not meant for direct access. It is exposed through the interface.
A result can be added by calling AddResultSet or AddContext. The %CurrentResult
property is set to the result currently available to the client. The next result
becomes the current result by calling %NextResult().</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="cursors">
<Description>
cursors is a multidimensional array of cursor objects, subscripted by cursor name (case sensitive)
The value of the cursor is the cursor object reference (oref).</Description>
<Type>%String</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Parameter name="MAXLEN"/>
</Property>

<Property name="context">
<Type>%CacheString</Type>
<Private>1</Private>
</Property>

<Property name="static">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="AddPrivateTable">
<Description><![CDATA[
AddPrivateTable()
		This method will register a temporary table object. Only registered table objects are usable by dSQL.
		The TTNI property is the <source_language_tablename> to <actual_tablename> index and is not set up here
		since the actual table (referenced by pTable) has no clue as to the source language table name. That must
		be done by the source language.]]></Description>
<FormalSpec>pTable:%XSQL.DS.TempTable</FormalSpec>
<Implementation><![CDATA[
	set context = $this
	if $Get(pTable.%dsd("%GlobalScope"),0) { if '$IsObject($Get(%processcontext)) { set %processcontext = ..%New() } set context = %processcontext }
		#; Storage offset
	set context.%LTT($Piece(pTable.%dsd("%TABLENAME"),".",2,999)) = pTable.%dsd("%STOFF")
	set context.PTT(pTable.%dsd("%TABLENAME")) = pTable
	quit
]]></Implementation>
</Method>

<Method name="RemovePrivateTable">
<Description>
RemovePrivateTable() will remove the private table name from the current context object or the process context
object. The storage offset information remains to that any existing result sets will still be valid. However,
If another instance of a private table with the same name is created any result sets against the prior private
table may become invalid.</Description>
<FormalSpec>pTableName:%String(MAXLEN="")</FormalSpec>
<Implementation><![CDATA[
	set tTable = $Get(..PTT(pTableName))
	if ($Isobject(tTable)) { set context = $this }
	elseif ($IsObject($Get(%processcontext))) {
		set tTable = $Get(%processcontext.PTT(pTableName))
		if $IsObject(tTable) { set context = %processcontext } else { set context = $$$NULLOREF }
	}
	else { set context = $$$NULLOREF }
	if $Isobject(context) {
		if $ZUtil(115,14) { do ##class(%XSQL.Log).traceDeferredStatement("DROP TEMP TABLE "_pTableName) }
			#; There are three places in the context object where we hold information about a temporary table - PTT, %LTT, and TTNI.
		kill context.PTT(pTableName)
			#; GLOBAL PRIVATE tables remove themselves on destruct, LOCAL PRIVATE tables leave the storage offset intact but allow
			#; recreate. GLOBAL PRIVATE tables cannot be recreated after DROP until all instances of the table go out of scope.
		if 'tTable.%dsd("%GlobalScope") {
			if $Get(tTable.%dsd("%SOURCENAME")) '= "" { kill context.TTNI($$$UPPER(tTable.%dsd("%SOURCENAME"))) }
				#; Leave %LTT because some result sets might still be accessing it. If we could tell now then we could also remove %LTT.
			if 0 { kill context.%LTT($Piece(pTable.%dsd("%TABLENAME"),".",2,999)) }
		}
	}
	quit
]]></Implementation>
</Method>

<Method name="ResolveTableName">
<Description>
ResolveTableName will locate a temporary table registered in either the current object (usually equates to
%sqlcontext) or in the process context object (%processcontext). The temporary table name passed into this
method is the host language name such as #my_temp in TSQL or a normal temporary table name in Informix. This
name is the one bound to the actual name in the TTNI (temporary table name index) by the host language procedure.
If the table name is not found in TTNI, either local(current object) or global (%processcontext) then the name
submitted is returned an no context is returned in the byref pContext argument.</Description>
<FormalSpec><![CDATA[pTableName:%String(MAXLEN=""),&pContext:%Library.ProcedureContext="",pDDLFlag:%Integer=0]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tTable = $Get(..TTNI($$$UPPER(pTableName)))
	if tTable '= "" { set pContext = $this }
	if $isobject($Get(%processcontext)) { set tTable = $Get(%processcontext.TTNI($$$UPPER(pTableName))) if tTable '= "" { set pContext = %processcontext } }
	if '$isobject(pContext) { quit pTableName }
	if (tTable = -1) && ('pDDLFlag) {
		merge tDDL = pContext.TTNI($$$UPPER(pTableName))
		set tDDL = tDDL(0)
		kill tDDL(0)
		set tTableHandle = ##class(%XSQL.DSI.GlobalPrivateTable).%Prepare(.tDDL) set %sqlcontext.Error= tTableHandle.%Get("%ERROR")
		if '$Isobject(%sqlcontext.Error) { set tTable = tTableHandle.%dsd("%TABLENAME"),pContext.TTNI($$$UPPER(pTableName)) = tTable, tTableHandle.%dsd("%SOURCENAME") = pTableName }
			#; Someday, I hope that %sqlcontext.Error is an exception and we won't have to cast it as an exception.
		else { throw %sqlcontext.Error.AsException() }
	}
	quit tTable
]]></Implementation>
</Method>

<Method name="Reset">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ..%LTT,..PTT,..Results
	Set ..context="",..%SQLCODE=0,..%Message="",..%CurrentResult="",..%ROWCOUNT=0,..Error=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AddResultSet">
<Description>
AddResultSet() - add a new result object to the context object. Results are
accessible by callers of the procedure through the %NextResult/%CurrentResult
interface.</Description>
<FormalSpec>rs:%Library.IResultSet</FormalSpec>
<Implementation><![CDATA[
	If $isobject(rs) {
		if $ZUtil(115,14) { do ##class(%XSQL.Log).traceMessage("Adding result set to context object") }
		if '..static { Set ..Results($order(..Results(""),-1)+1)=rs }
		else {
			set srs = ##class(%ResultSet.Static).%New(rs)
			set ..Results($order(..Results(""),-1)+1) = srs
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AddContext">
<Description><![CDATA[
AddContext() is for nesting procedure context objects. If one procedure invokes another procedure and the results
of calling the nested procedure are to be returned to the caller of the outer procedure then simply invoke
AddContext on the context object of the outer procedure, passing the context object of the inner procedure as
an argument, <var>pContext</var>. If the <var>propagateerror</var> argument is true then any error encountered by the nested procedure
will be reported as an error to the caller of the outer procedure.]]></Description>
<FormalSpec>pContext:%Library.IProcedureContext,propagateerror:%Boolean=1</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	If $isobject(pContext) {
		if $ZUtil(115,14) { do ##class(%XSQL.Log).traceMessage("Embedding context object in context object") }
		Set currpos=$order(..Results(""),-1)+1
		Set ..Results(currpos)=pContext,..Results(currpos,1)=""
		If propagateerror {
			If $isobject(pContext.Error),'$isobject(..Error) Set ..Error=pContext.Error
			If pContext.%SQLCODE'=0,pContext.%SQLCODE'=100,..%SQLCODE=0 Set ..%SQLCODE=pContext.%SQLCODE,..%Message=pContext.%Message
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Prepare">
<Description>
Used internally only, do not call directly.</Description>
<Internal>1</Internal>
<FormalSpec>sqlquery:%String(MAXLEN=""),args...</FormalSpec>
<ReturnType>%Library.IResultSet</ReturnType>
<Implementation><![CDATA[
	Set cls = $$%RSPrepare^%SYS.ResultSet(sqlquery,.returnError,args...)
	If $isobject($get(returnError)) Set ..%SQLCODE = returnError.SQLCode, ..%Message = returnError.Message
	Quit cls
]]></Implementation>
</Method>

<Method name="NewResultSet">
<Description>
Used internally only, do not call directly.</Description>
<Internal>1</Internal>
<FormalSpec>rs:%Library.IResultSet,error:%SYSTEM.Error</FormalSpec>
<Implementation><![CDATA[
	If $isobject($get(error)) {
		If $isobject(rs) {
			Set rs.%SQLCODE=error.SQLCode,rs.%Message=error.Message
		} Else {
			Set rs=##class(%ResultSet.Result).%New(error.SQLCode,error.Message)
		}
	}
	If $isobject(rs) {
		if '..static { Set ..Results($order(..Results(""),-1)+1)=rs }
		else {
			set srs = ##class(%ResultSet.Static).%New(rs)
			set ..Results($order(..Results(""),-1)+1) = srs
		}
	}
]]></Implementation>
</Method>

<Method name="ReplaceResultSet">
<Description>
Used internally only, do not call directly.</Description>
<Internal>1</Internal>
<FormalSpec>pResultSet:%Library.IResultSet=""</FormalSpec>
<Implementation><![CDATA[	If $isobject(pResultSet) { set ..Results($order(..Results(""),-1)) = pResultSet }
]]></Implementation>
</Method>

<Method name="NextResult">
<Description>
Called to return the next resultset object.
This also removes the reference to the existing object so it can cleanup and close itself</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[..%NextResult()
]]></Implementation>
</Method>

<Method name="%NextResult">
<Description>
Called to return the next resultset object.
This also removes the reference to the existing object so it can cleanup and close itself</Description>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
loop	If $isobject(..context) {
		Set ..%CurrentResult=..context.%NextResult()
		If $isobject(..%CurrentResult) do initializeContext Quit ..%CurrentResult
	}
	Set data=$$$NULLOREF,currpos=$order(..Results(""),1,data)
	If currpos'="" {
		Set iscontext=$data(..Results(currpos,1))
		Kill ..Results(currpos)
		If iscontext Set ..context=data	Goto loop
	}
	Set ..%CurrentResult=data,..context=$$$NULLOREF
	if ($isobject(data)) && (data.%ResultColumnCount > 0) { do initializeContext }
	Quit ..%CurrentResult
initializeContext
		#; Ask the new result set guest to make itself comfortable in this context
		#; Presumably this is limited to making sure temporary table objects are properly set up in %LTT
		#; We might want to throw an exception here if this context isn't suitable to our new guest.
	set tableName = "", tempTable = ..%CurrentResult.%PrivateTables.GetNext(.tableName)
	while tableName '= "" {
		set tableNameNS = $Piece(tableName,".",2,999)
		if 'tempTable.%Get("%GlobalScope") {
			if '$Data(..%LTT(tableNameNS)) { set ..%LTT(tableNameNS) = tempTable.%dsd("%STOFF") }
		}
		else {
			if '$isobject($get(%processcontext)) { set %processcontext = ..%New() }
			if '$Data(%processcontext.%LTT(tableNameNS)) { set %processcontext.%LTT(tableNameNS) = tempTable.%dsd("%STOFF") }
		}
		set tempTable = ..%CurrentResult.%PrivateTables.GetNext(.tableName)
	}
	quit
]]></Implementation>
</Method>

<Method name="CloseCurrentResult">
<Description>
Close the current resultset object, used to allow the cleanup code to run and the cursor to close</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $isobject(..context) {
		Do ..context.CloseCurrentResult()
	}
	Set ..%CurrentResult = $$$NULLOREF
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DumpResults">
<Description><![CDATA[
DumpResults()
This method writes all of the results to the current device. The <var>pDelimiter</var> parameter
is passed to the result set's %Print() method.]]></Description>
<FormalSpec>pDelimiter:%String=" "</FormalSpec>
<Implementation><![CDATA[
	do ..%Display(pDelimiter)
	quit
]]></Implementation>
</Method>
</Class>


<Class name="%Library.Prompt">
<Description>
Handles prompting for chui applications.</Description>
<Abstract>1</Abstract>
<IncludeCode>%syPrompt</IncludeCode>
<Super>%SYSTEM.Help</Super>
<System>4</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59367,51956</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
/*
---------------------Documentation------------------------------------
SML2207 12/09/15 Simon Li, Warn users when Maximum DB size is reduced.
HYY1993 04/08/15 Huayong Yang, fix return of GetArray() with MultipleSelection
SML1675 03/22/13 Simon Li, Fix help text to display upper bound in %Prompt.GetMenu().
RJF150  07/16/12 Ray Fucillo, fix bug in GetArray() multiple selection with matching 
RJF145  11/10/11 Ray Fucillo, in GetArray() allow multiple responses with matching 
SML968  12/04/07 Simon Li, Refresh fields info after one field is edited in EditField.
SML905  07/26/07 Simon Li, Show mark on dismounted DB when user enter '?' for DB list.
SML900	07/17/07 Simon Li, Fix invalid number range.
JLC1004	04/19/07 Jose' Cordeiro, use only numeric subscripts in options array
LRS981	09/12/05 Lee Smith, fix max and min prompts and help in GetNumber
LFT1428 03/29/05 Laura Tillem, NewGlobalCollation needs a flag for display
LFT1316 11/11/04 Laura Tillem, %SYSTEM -> SYS.Database
PWC922  10/27/04 Peter Cudhea, Move %SYSTEM.Prompt class to %Library.Prompt
LFT1280 07/07/04 Laura Tillem, 
LFT1185 01/08/04 Laura Tillem, add default prompt and flag to GetMore
LFT1140 11/10/03 Laura Tillem, modify LFT1135
LFT1148 10/16/03 Laura Tillem, more additions, support %DM use of classes
LFT1135 10/07/03 Laura Tillem, minor changes
STC477	09/08/03 Steve Clay, Initial version.
-------------------End Documentation----------------------------------
*/
]]></Content>
</UDLText>

<Method name="GetNumber">
<Description><![CDATA[
Prompt for a number.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Value - Default value <br>
Min - Minimum value allowed<br>
Max - Maximum value allowed<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$DisableHelpContextResponse - Disable entry of the help context character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
     - $$$AllowNullMask - Allow null entry
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
$$$HelpContextResponse - Help context character entered if $$$DisableHelpContextCharMask set <br>
Value - Entered number<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String,&Value:%Integer,Min:%Integer,Max:%Integer,&Help:%String,Flag:%Integer=0,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 f  {
	w !,Prompt_" " 
	i $d(Value),(+Value=Value) {
		s DefaultString=Value_" "_$$$DefaultPrompt_" "
		i $x+$l(DefaultString)>70 w !,?$$$HelpTab
		w DefaultString
	}
	i (Timeout'=0),$d(Value),(+Value=Value) {
		r Number:Timeout
		i '$t s Number=Value w Number q
	} else {
		r Number
	}
	i (Number=""),$d(Value),(+Value=Value) s Number=Value q
	i (Number=""), $zb(+Flag,$$$AllowNullMask,1) q
	i (Number=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (Number=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help),! Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		Continue
	}
	i ($zcvt(Number,"U")=$$$HelpContextChar) {
		i $zb(+Flag,$$$DisableHelpContextCharMask,1) q
		d HELP Continue
	}
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[($zcvt(Number,"U")_","),(Number'="") s Number=$$$QuitChar q
	#;SML2207+ ; Allow user to enter leading '+' or '-' for changes to default value.
	if $zb(+Flag,$$$AllowIncrementalNumber,1) {
		s sign=$e(Number)
		if sign="+",$e(Number,2,*)?1.N {
			s Number=$g(Value)+$e(Number,2,*) w " = ",Number
		} elseif sign="-",$e(Number,2,*)?1.N {
			s Number=$g(Value)-$e(Number,2,*) w " = ",Number
		}
	}
	#;SML2207-
	i +Number'=Number w !!,"Please enter a valid number",! Continue
	i $d(Min),(Number<Min) w !!,"Answer must be greater than or equal to "_Min_", please re-enter",! Continue
	i $d(Max),(Number>Max) w !!,"Answer must be less than or equal to "_Max_", please re-enter",! Continue
 	q
 }
 i Number=$$$BackupChar q $$$BackupResponse
 i $zb(+Flag,$$$EnableQuitCharMask,1),(Number=$$$QuitChar) q $$$QuitResponse
 i Number=$$$HelpChar q $$$HelpResponse
 i $zcvt(Number,"U")=$$$HelpContextChar q $$$HelpContextResponse
 s Value=Number	
 q $$$SuccessResponse
HELP
 w !!
 w ?$$$HelpTab,"Any number entered is valid"
 i $d(Min),$d(Max) w !,?$$$HelpTab,"The answer must be between "_Min_ " and "_Max_" (inclusive)"
 i '$d(Min),$d(Max) w !,?$$$HelpTab,"The answer must be less than or equal to "_Max
 i $d(Min),'$d(Max) w !,?$$$HelpTab,"The answer must be greater than or equal to "_Min
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 i '$zb(+Flag,$$$DisableHelpContextCharMask,1) w !,?$$$HelpTab,$$$HelpContextChar_"  displays this help message"
 w !
 q
ERROR s $zt=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="GetMenu">
<Description><![CDATA[
Prompt for a number in a displayed menu.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Value - Default value <br>
List - Array of menu items. This should be in one of the following 
two forms:<br>
List(1)="Option 1"<br>
List(2)="Option 2"<br>
List(n)="Option n"<br>
<br>
or
<br>
$lb(QueryName,ExecuteParam1,ExecuteParam2,ExecuteParamN)<br>
For example: $lb("SYS.Database:List","*")
<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$DisableHelpContextCharMask - Disable entry of the help context character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
     - $$$InitialDisplayMask - Display the menu when initially called<br>
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
$$$HelpContextResponse - Help context character entered if $$$DisableHelpContextCharMask set <br>
Value - Entered number<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String,&Value:%Integer,&List:%String,&Help:%String,Flag:%Integer=0,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 i $zb(+Flag,$$$InitialDisplayMask,1) {
	d LOAD
 	d DISPLAY
 }
 f  {
	w !,Prompt_" " 
	i $d(Value),(Value'="") {
		s DefaultString=Value_" "_$$$DefaultPrompt_" "
		i $x+$l(DefaultString)>70 w !,?$$$HelpTab
		w DefaultString
	}
	i (Timeout'=0),$d(Value),(Value'="") {
		r String:Timeout
		i '$t s String=Value w String q
	} else {
		r String
	}
#; If a null string entered, and a default passed, use it
	i (String=""),$d(Value),(Value'="") s String=Value q
#; If a null string entered, and no default, return a backup char
	i String="" s String=$$$BackupChar q
	i (String=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (String=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		d LOAD
		d DISPLAY
		Continue
	}
	i ($zcvt(String,"U")=$$$HelpContextChar) {
		i $zb(+Flag,$$$DisableHelpContextCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help) d HELP Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		d HELP
		Continue
	}
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[($zcvt(String,"U")_","),(String'="") s String=$$$QuitChar q
 	i $IsValidNum(String,0) {
	 	d LOAD
	 	i (String<1)!(String>$o(Array($$$MaxInt),-1)) w !!,"Please enter a number between 1 and "_$o(Array($$$MaxInt),-1),! Continue
		q
 	} else {
 		w !!,"Please enter a number between 1 and "_$o(Array($$$MaxInt),-1),! Continue
 	}
 }
 i String=$$$BackupChar q $$$BackupResponse
 i $zb(+Flag,$$$EnableQuitCharMask,1),(String=$$$QuitChar) q $$$QuitResponse
 i String=$$$HelpChar q $$$HelpResponse
 i String=$$$HelpContextChar q $$$HelpContextResponse
 s Value=String
 q $$$SuccessResponse
HELP
#;SML1675 ; Call LOAD to make sure the Array is set.
 d LOAD
 w !!
 w ?$$$HelpTab,"The answer may be null or between 1 and "_$o(Array($$$MaxInt),-1)
 w !,?$$$HelpTab,""""" enters a null string"
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 i '$zb(+Flag,$$$DisableHelpContextCharMask,1) w !,?$$$HelpTab,$$$HelpContextChar_"  displays this help message"
 w !
 q
LOAD
 q:$d(Array)
 i $d(List)=1 {
	s Query=$li(List,1)
	Set Rset = ##class(%ResultSet).%New(Query)
	i $ll(List)=1 d Rset.Execute()
	i $ll(List)=2 d Rset.Execute($li(List,2))
	i $ll(List)=3 d Rset.Execute($li(List,2),$li(List,3))
	i $ll(List)=4 d Rset.Execute($li(List,2),$li(List,3),$li(List,4))
	i $ll(List)=5 d Rset.Execute($li(List,2),$li(List,3),$li(List,4),$li(List,5))
	i $ll(List)=6 d Rset.Execute($li(List,2),$li(List,3),$li(List,4),$li(List,5),$li(List,6))
	While (Rset.Next()) {
		s Array($i(Index))=Rset.GetData(1)
 	}
 	k Rset,Query,Index
 } else {
	 m Array=List
 }
 q
DISPLAY
 w !
 s MaxArray=$o(Array($$$MaxInt),-1)
 s Len=$l(MaxArray)
 i MaxArray>$$$LinesPerPage {
 	s Lines=0 
 	s Num=$o(Array(""))
 	while(Num?1n.n) {
	 	s Lines=Lines+1
	 	i Lines#$$$LinesPerPage=0 {
			w !
	 		s Status=..GetMore()
	 		w !
	 		i (Status=$$$QuitResponse)||(Status=$$$BackupResponse) q
	 	}
	 	w !,$j(Num,Len),") "_Array(Num)
	 	s Num=$o(Array(Num))
	 	Continue:Num'?1n.n
	 	i $x>40 Continue
	 	i $x+Len+2+$l(Array(Num))>79 Continue
		w ?40,$j(Num,Len),") "_Array(Num)
	 	s Num=$o(Array(Num))
 	}
 } else {
 	f i=1:1:MaxArray w !,$j(i,Len),") "_Array(i)
 }
 w ! 	 
 q
ERROR s $ZT=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="GetArray">
<Description><![CDATA[
Prompt for a number or entry in a displayed menu. Returns the selected item.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Value - Default value <br>
List - Array of menu items. This should be in one of the following 
two forms:<br>
List(1)="Option 1"<br>
List(2)="Option 2"<br>
List(n)="Option n"<br>
If List(n,0) exist then the help (? entered) will display List(n)_List(n,0).<br>
<br>
or
<br>
$lb(QueryName,ExecuteParam1,ExecuteParam2,ExecuteParamN)<br>
For example: $lb("SYS.Database:List","*")
<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$DisableHelpContextCharMask - Disable entry of the help context character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
     - $$$InitialDisplayMask - Display the menu when initially called<br>
     - $$$AllowNullMask - Allow null entry<br>
     - $$$EnableMultipleSelectionMask - Allow comma delimited numeric entry, ranges, and * for all<br>
     - $$$MatchExactArrayMask - Only entries from the the array of options are allowed, case sensitive<br>
     - $$$MatchArrayMask - Only entries from the array of options are allowed, not case sensitive<br>
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
$$$HelpContextResponse - Help character entered if $$$DisableHelpContextCharMask set <br>
Value - Value of selected item; or if the $$$EnableMultipleSelectionMask flag is used, a list of selected items in $listbuild format.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String,&Value:%String,&List:%String,MinLen:%Integer,MaxLen:%Integer,&Help:%String,Flag:%Integer=0,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 i $zb(+Flag,$$$InitialDisplayMask,1) {
	d LOAD
 	d DISPLAY
 }
 f  {
	s needslist=0
	w !,Prompt_" " 
	i $d(Value),(Value'="") {
		s DefaultString=Value_" "_$$$DefaultPrompt_" "
		i $x+$l(DefaultString)>70 w !,?$$$HelpTab
		w DefaultString
	}
	i (Timeout'=0),$d(Value),(Value'="") {
		r String:Timeout
		i '$t s String=Value w String q
	} else {
		r String
	}
	i (String=""),$d(Value),(Value'="") s String=Value q
	i (String=""),$zb(+Flag,$$$AllowNullMask,1) q
	i (String=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (String=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		d LOAD
		d DISPLAY
		i $zb(+Flag,$$$EnableMultipleSelectionMask,1) {
			#; DISPLAY issues a CRLF at the end
			w ?5,"(Multiple selections allowed: * for all, or list such as 1,4,7-10)"
		}
		Continue
	}
	i ($zcvt(String,"U")=$$$HelpContextChar) {
		i $zb(+Flag,$$$DisableHelpContextCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help) d HELP Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		d HELP
		Continue
	}
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[($zcvt(String,"U")_","),(String'="") s String=$$$QuitChar q
	i String=$$$NullChar s String=""
 	i $IsValidNum(String,0) {
	 	d LOAD
	 	i (String<1)!(String>$o(Array($$$MaxInt),-1)) w !!,"Please enter a number between 1 and "_$o(Array($$$MaxInt),-1),! Continue
		w " ",Array(+String) 
		s String=Array(+String)
		i $zb(+Flag,$$$EnableMultipleSelectionMask,1) s String=$lb(String)
		q
 	} 
 	if $zb(+Flag,$$$EnableMultipleSelectionMask,1) {
		d LOAD
		k String1
		f i=1:1 {
 			s Piece=$p(String,",",i)
			q:Piece=""
 			i Piece="*" {
				f j=1:1:$o(Array(""),-1) s String1(Array(j))=""
				q
			}
#; SML900
 			i (Piece'["-") || '(Piece?.N1"-".N) {
	 			i $d(Array(+Piece)) s String1(Array(+Piece))=""
			} else {
				f j=+$p(Piece,"-",1):1:+$p(Piece,"-",2) i $d(Array(j)) s String1(Array(j))=""
			}	 			
		}
#; Now merge the accumulated strings into $list format
		s i="" 
		s i=$o(String1(i))
		while (i'="") {
			s String2=$g(String2)_$lb(i)
			i $l(String2)>31000 {
				s String2($o(String2(""),-1)+1)=String2
				zk String2
			}
			s i=$o(String1(i))
		}
		i $d(String2(1)) {
			s String2($o(String2(""),-1)+1)=String2
			zk String2
		}
#; If there is no String2 then String needs to be put in list format
#;	because EnableMultipleSelectionMask is true here
		i $d(String2) {
			#; We found at least one of the multiple selections in the list
			#; and ignored any others, so we're done
			m String=String2
			q
		} 
		#; No selections from the list were found and we're treating this as a
		#; single write-in response.  Fall through to the validation logic, but
		#; remember we need to convert the value to a list before returning
		s needslist=1
	}
 	i $d(MinLen),(MinLen=0),(String="") q
	i $zb(+Flag,$$$MatchArrayMask+$$$MatchExactArrayMask,1) {
		s Found=0
		d LOAD
		s Match=$o(Array(""))
		While (Match'="") {
			i $zb(+Flag,$$$MatchArrayMask,1),($zcvt(Array(Match),"U")=$zcvt(String,"U")) {
				s String=Array(Match) 
				s Found=1 
				q
			}
			i $zb(+Flag,$$$MatchExactArrayMask,1),(Array(Match)=String) {
				s String=Array(Match) 
				s Found=1 
				q
			}
			s Match=$o(Array(Match))
		}
		i 'Found {
			w !!,"Entry must be from the list, please re-enter",!
			Continue
		}
		q:Found
	}
	s Len=$l(String)
	i $d(MinLen),(Len<MinLen) w !!,"Answer must be at least "_MinLen_" characters long, please re-enter",! Continue
	i $d(MaxLen),(Len>MaxLen) w !!,"Answer must be at most "_MaxLen_" characters long, please re-enter",! Continue
	q
 }
 i String=$$$BackupChar q $$$BackupResponse
 i $zb(+Flag,$$$EnableQuitCharMask,1),(String=$$$QuitChar) q $$$QuitResponse
 i String=$$$HelpChar q $$$HelpResponse
 i $zcvt(String,"U")=$$$HelpContextChar q $$$HelpResponse
 i $g(needslist) s String=$lb(String)
 if $zb(+Flag,$$$EnableMultipleSelectionMask,1) {
	#; String could be an array, with $LIST values in subnodes
 	m Value=String
 } else {
 	s Value=String
 }
 q $$$SuccessResponse
HELP
 w !!
 w ?$$$HelpTab,"The answer "
 i '$d(MinLen) {
	w "may be null"
 }else {
 	w "must be "_MinLen
 }
 w " or more characters long, and up to "
 i '$d(MaxLen) {
	w "any length"
 
 }else {
	 w MaxLen_" characters long"
 }
 w !,?$$$HelpTab,""""" enters a null string"
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 i '$zb(+Flag,$$$DisableHelpContextCharMask,1) w !,?$$$HelpTab,$$$HelpContextChar_"  displays this help message"
 w !
 q
LOAD
 q:$d(Array)
 i $d(List)=1 {
	s Query=$li(List,1)
	Set Rset = ##class(%ResultSet).%New(Query)
	i $ll(List)=1 d Rset.Execute()
	i $ll(List)=2 d Rset.Execute($li(List,2))
	i $ll(List)=3 d Rset.Execute($li(List,2),$li(List,3))
	i $ll(List)=4 d Rset.Execute($li(List,2),$li(List,3),$li(List,4))
	i $ll(List)=5 d Rset.Execute($li(List,2),$li(List,3),$li(List,4),$li(List,5))
	i $ll(List)=6 d Rset.Execute($li(List,2),$li(List,3),$li(List,4),$li(List,5),$li(List,6))
	While (Rset.Next()) {
		s Array($i(Index))=Rset.GetData(1)
 	}
 k Rset,Query,Index
 }else {
	 m Array=List
 }
 q
DISPLAY
 w !
 s MaxArray=$o(Array($$$MaxInt),-1)
 s Len=$l(MaxArray)
 i MaxArray>$$$LinesPerPage {
 	s Lines=0 
 	s Num=$o(Array(""))
 	while(Num?1n.n) {
	 	s Lines=Lines+1
	 	i Lines#$$$LinesPerPage=0 {
			w !
	 		s Status=..GetMore()
	 		w !
	 		i (Status=$$$QuitResponse)||(Status=$$$BackupResponse) q
	 	}
#;SML905+  ; Get the extra data to be displayed
		s ArrayData=Array(Num)_$G(Array(Num,0),"")
 		w !,$j(Num,Len),") "_ArrayData
#;SML905-
	 	s Num=$o(Array(Num))
	 	Continue:Num'?1n.n
	 	i $x>40 Continue
#;SML905+  ; Get the extra data to be displayed
		s ArrayData=Array(Num)_$G(Array(Num,0),"")
	 	i $x+Len+2+$l(ArrayData)>79 Continue
		w ?40,$j(Num,Len),") "_ArrayData
#;SML905-
	 	s Num=$o(Array(Num))
 	}
}else {
#;SML905+  ; Get the extra data to be displayed
 	f i=1:1:MaxArray w !,$j(i,Len),") "_Array(i)_$G(Array(i,0),"")
 }
 w ! 	 
 q
ERROR s $ZT=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="GetString">
<Description><![CDATA[
Prompt for a String.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Value - Default value <br>
Min - Minimum length of string allowed<br>
Max - Maximum length of string allowed<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$DisableHelpContextCharMask - Disable entry of the help context character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
$$$HelpContextResponse - Help character entered if $$$DisableHelpContextCharMask set <br>
Value - Entered String<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String,&Value:%String,MinLen:%Integer,MaxLen:%Integer,&Help:%String,Flag:%Integer=0,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 f  {
	w !,Prompt_" " 
	i $d(Value),(Value'="") {
		s DefaultString=Value_" "_$$$DefaultPrompt_" "
		i $x+$l(DefaultString)>70 w !,?$$$HelpTab
		w DefaultString
	}
	i (Timeout'=0),$d(Value),(Value'="") {
		r String:Timeout
		i '$t s String=Value w String q
	} else {
		r String
	}
	i (String=""),$d(Value),(Value'="") s String=Value q
	i (String=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (String=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help) Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		Continue
	}
	i ($zcvt(String,"U")=$$$HelpContextChar) {
		i $zb(+Flag,$$$DisableHelpContextCharMask,1) q
		d HELP Continue
	}
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[($zcvt(String,"U")_","),(String'="") s String=$$$QuitChar q
	i String=$$$NullChar s String=""
	s Len=$l(String)
	i $d(MinLen),(Len<MinLen) w !!,"Answer must be at least "_MinLen_" characters long, please re-enter",! Continue
	i $d(MaxLen),(Len>MaxLen) w !!,"Answer must be at most "_MaxLen_" characters long, please re-enter",! Continue
 	q
 }
 i String=$$$BackupChar q $$$BackupResponse
 i $zb(+Flag,$$$EnableQuitCharMask,1),(String=$$$QuitChar) q $$$QuitResponse
 i String=$$$HelpChar q $$$HelpResponse
 i $zcvt(String,"U")=$$$HelpContextChar q $$$HelpContextResponse
 s Value=String
 q $$$SuccessResponse
HELP
 w !!
 w ?$$$HelpTab,"The answer "
 i '$d(MinLen) {
	w "may be null"
 } else {
 	w "must be "_MinLen
 }
 w " or more characters long, and up to "
 i '$d(MaxLen) {
	w "any length"
 
 } else {
	 w MaxLen_" characters long"
 }
 w !,?$$$HelpTab,""""" enters a null string"
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 i '$zb(+Flag,$$$DisableHelpContextCharMask,1) w !,?$$$HelpTab,$$$HelpContextChar_"  displays this help message"
 w !
 q
ERROR s $ZT=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="GetYesNo">
<Description><![CDATA[
Prompt for a Yes/No answer.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Value - Default value 0=No, 1=Yes<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
Value - 0=No, 1=Yes<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String,&Value:%Integer,&Help:%String,Flag:%Integer=0,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 f  {
	w !,Prompt_" " 
	i $d(Value) {
		s DefaultString=$case(Value,0:$$$No,1:$$$Yes)_" "_$$$DefaultPrompt_" "
		i $x+$l(DefaultString)>70 w !,?$$$HelpTab
		w DefaultString
	}
	i (Timeout'=0),$d(Value) {
		r YesNo:Timeout
		i '$t s YesNo=Value w $case(YesNo,0:$$$No,1:$$$Yes) q
	} else {
		r YesNo
	}
	i (YesNo=""),$d(Value) s YesNo=Value q
	i (YesNo=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (YesNo=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help) Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		Continue
	}
	i ($zcvt(YesNo,"U")=$$$HelpContextChar) {
		i $zb(+Flag,$$$DisableHelpContextCharMask,1) q
		d HELP Continue
	}
	s YesNoUpperCase=$zcvt(YesNo,"U")
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[(YesNoUpperCase_","),(YesNoUpperCase'="") s YesNo=$$$QuitChar q
	i YesNoUpperCase]"" {
		i $e($zcvt($$$Yes,"U"),1,$l(YesNoUpperCase))=YesNoUpperCase s YesNo=1 q
		i $e($zcvt($$$No,"U"),1,$l(YesNoUpperCase))=YesNoUpperCase s YesNo=0 q
	}
	w !!,"Please enter "_$$$Yes_" or "_$$$No,!
 }
 i YesNo=$$$BackupChar q $$$BackupResponse
 i $zb(+Flag,$$$EnableQuitCharMask,1),(YesNo=$$$QuitChar) q $$$QuitResponse
 i YesNo=$$$HelpChar q $$$HelpResponse
 i $zcvt(YesNo,"U")=$$$HelpContextChar q $$$HelpContextResponse
 s Value=YesNo
 q $$$SuccessResponse
HELP
 w !!
 w ?$$$HelpTab,"Y/Ye/Yes and N/No are valid responses"
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 i '$zb(+Flag,$$$DisableHelpContextCharMask,1) w !,?$$$HelpTab,$$$HelpContextChar_"  displays this help message"
 w !
 q
ERROR s $ZT=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="GetMore">
<Description><![CDATA[
Prompt for More or Quit.<br>
<br>
Input Parameters:<br>
Prompt - Prompt to be displayed<br>
Help - Array of help text<br>
Flag - From %syPrompt.inc<br>
     - $$$DisableBackupCharMask - Disable entry of the backup character<br>
     - $$$TrapCtrlCMask - Trap CTRL/C and return CTRL/C status<br>
     - $$$EnableQuitCharMask - Enable quit and return Quit status<br>
     - $$$DisableHelpCharMask - Disable entry of the help character<br>
     - $$$TrapErrorMask - Trap errors and return error status<br>
TimeOut - Timeout for prompt<br>
<br>
Output parameters:<br>
Status - One of the following from %syPrompt:<br>
$$$SuccessResponse - Successful entry, Value contains valid open device<br>
$$$BackupResponse - Backup character entered<br>
$$$QuitResponse - Quit character entered if $$$EnableQuitCharMask set<br>
$$$CtrlCResponse - CTRL/C entered if $$$TrapCtrlCMask set<br>
$$$ErrorResponse - Error during entry if $$$TrapErrorMask set<br>
$$$HelpResponse - Help character entered if $$$DisableHelpCharMask set <br>
Value - Entered number<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Prompt:%String="-more-",&Help:%String,Flag:%Integer=$$$EnableQuitCharMask,Timeout:%Integer=0]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 s $zt="ERROR"
 f  {
	w !,Prompt_" "
	i (Timeout'=0) {
		r String#1:Timeout
		i '$t s String="" q
	} else {
		r String#1
	}
	i (String=$$$BackupChar) {
		i '$zb(+Flag,$$$DisableBackupCharMask,1) q
		w !!,$$$BackupChar_" Disabled for this prompt",! Continue
	}
	i (String=$$$HelpChar) {
		i $zb(+Flag,$$$DisableHelpCharMask,1) q
		i $d(Help)=0 d HELP Continue
		i $d(Help)=1 w !!,?$$$HelpTab,$g(Help) Continue
		w ! f i=1:1:+$o(Help($$$MaxInt),-1) w !,?$$$HelpTab,$g(Help(i))
		w !
		d HELP
		Continue
	}
	i String="" q
	i $zb(+Flag,$$$EnableQuitCharMask,1),$$$QuitString[($zcvt(String,"U")_","),(String'="") s String=$$$QuitChar q
 	q
 }
 i String=$$$BackupChar q $$$BackupResponse
 i String=$$$QuitChar q $$$QuitResponse
 i String=$$$HelpChar q $$$HelpResponse
 q $$$SuccessResponse
HELP
 w !!
 i $zb(+Flag,$$$EnableQuitCharMask,1) w !,?$$$HelpTab,$$$QuitChar_" quits the program"
 i '$zb(+Flag,$$$DisableBackupCharMask,1) w !,?$$$HelpTab,$$$BackupChar_"  returns to the previous prompt"
 i '$zb(+Flag,$$$DisableHelpCharMask,1) w !,?$$$HelpTab,$$$HelpChar_"  displays help text"
 w !
 q
ERROR s $ZT=""
 i ($ze["<INTERRUPT>"),$zb(+Flag,$$$TrapCtrlCMask,1) q $$$CtrlCResponse
 i $zb(+Flag,$$$TrapErrorMask,1) q $$$ErrorResponse
 ztrap $ze
]]></Implementation>
</Method>

<Method name="EditFields">
<Description>
Edits an objects properties.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>Obj,New</FormalSpec>
<Implementation><![CDATA[
 s $ZT="ERROR"
 n %Field,%Status,%Value,%New,%Obj
 s %New=New
 s %Obj=Obj
 s ClassName="##Class("_Obj.%ClassName(1)_")"
 d EDITFIELDSMENU
 s Max=$o(%Field($$$MaxInt),-1)
 f {
	s %Value=""
	s %Status=..GetNumber("Field number to change?",.%Value,1,Max,,$$$TrapCtrlCMask+$$$DisableHelpCharMask+$$$AllowNullMask)
 	i (%Status=$$$CtrlCResponse)||(%Status=$$$BackupResponse) q
	i %Status=$$$HelpResponse d EDITFIELDSMENU Continue
	i %Value="" s %Status=$$$SuccessResponse q
	i $d(%Field(%Value,"ReadOnly")) w !!,"Field is for display only, please re-enter",! Continue
	s x="s %Status="_ClassName_"."_%Field(%Value,"Property")_"Prompt(%Field(%Value,""Prompt""),.%Field)" 
	x x
 	i (%Status=$$$CtrlCResponse) q
 	#;SML968+ ; Refresh the %Field info after one of the fields is updated.
 	s x="s %Status="_ClassName_".LoadFields(.%Field,.%Obj,%New)"
 	x x
 	#;SML968-
 }
 q %Status
  
ERROR s $zt=""
 i $ze["<INTERRUPT>" q $$$CtrlCResponse
 ztrap $ZE
EDITFIELDSMENU
 s x="s %Status="_ClassName_".LoadFields(.%Field,.%Obj,%New)"
 x x
 s MaxSize=0
 s Num=$o(%Field(""))
 while (Num'="") {
	s Size=$l(%Field(Num,"Caption"))
	i Size>MaxSize s MaxSize=Size
 	s Num=$o(%Field(Num))
 }
 s MaxSize=MaxSize+7
 s Num=$o(%Field(""))
 w !
 while (Num'="") {
	w !,$j(Num,2)_")"
	i $d(%Field(Num,"ReadOnly")) {
		w "* "
	} else {
		w "  "
	}
	w %Field(Num,"Caption")_":",?MaxSize
	i %Field(Num,"Property")="NewGlobalCollation" s x="w "_ClassName_"."_%Field(Num,"Property")_"LogicalToDisplay(%Obj."_%Field(Num,"Property")_",2)"
	e  s x="w "_ClassName_"."_%Field(Num,"Property")_"LogicalToDisplay(%Obj."_%Field(Num,"Property")_")"
 	x x
 	s Num=$o(%Field(Num))
 }
 w !
 q
]]></Implementation>
</Method>
</Class>


<Class name="%Library.PropertyDefinition">
<Description><![CDATA[
<b>
Note: The class definition classes in the %Library package have been superceded
by those in the %Dictionary package.</b>
<p>
This class represents a specific <i>property</i> description for a class contained 
within the <i>Cach&eacute; Dictionary.</i>

<p>For more information on class definition classes, refer to
<link href=/AboutClassDefinition.html>About Class Definition Classes</link>.]]></Description>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41415</TimeCreated>

<Property name="ClassName">
<Description>
A string containing the name of the class the property belongs to.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
A string containing the name of the property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Calculated">
<Description>
A flag indicating whether the property is calculated (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Cardinality">
<Description>
If the property is a relationship, this is a string contains the cardinality of
the relationship. Cardinality = 'one' indicates the child side of the relationship while
Cardinality = 'many' indicates the parent. Cardinality = 'child' and 'parent' mean the same
but also indicate a dependent relationship.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Collection">
<Description>
If the property is a collection, this is a string containing the name of 
the collection type. If the property is not a collection (single-valued) it 
contains a null string ("").</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Description">
<Description>
A string containing the description of the property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
A flag indicating whether the property is final (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="InitialExpression">
<Description>
A string containing the initial value expression for the property.</Description>
<Type>%CacheString</Type>
<InitialExpression>""""""</InitialExpression>
</Property>

<Property name="Internal">
<Description>
A flag indicating whether the property is internal (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Inverse">
<Description>
A string containing the name of the inverse relationship in the related class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="MultiDimensional">
<Description>
A flag indicating whether the property is multi-dimensional (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
A flag indicating whether the property is private (1) or public (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReadOnly">
<Description>
A flag indicating whether the property is a readonly (1) or writeable (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Relationship">
<Description>
A flag indicating whether the property is a relationship (1) or attribute (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Required">
<Description>
A flag indicating whether the property is required (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlCollation">
<Description>
A string containing the name of the class this method belongs to.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlColumnNumber">
<Description>
The column number used when projecting the property as an SQL table.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputeCode">
<Description>
For an SQL-computed field this is a string containing any SQL compute code for the field.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputed">
<Description>
A flag indicating whether the property is SQL-computed (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputeOnChange">
<Type>%CacheString</Type>
</Property>

<Property name="SqlFieldName">
<Description>
A string containing an optional SQL name for the property. This is the name with 
which the property is projected to SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlListDelimiter">
<Type>%CacheString</Type>
</Property>

<Property name="SqlListType">
<Type>%CacheString</Type>
</Property>

<Property name="Transient">
<Description>
A flag indicating whether the property is transient (1) or not (0).</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
A string containing the type (class name) of the field.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
An array containing any parameter definitions for the property. The array 
keys are the parameter names and the array values are the parameter values.</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="SequenceNumber">
<Description>
Sequence number used to determine order of this item in Studio editor and in XML export format.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%Name=$p(initvalue,":",2)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 s i%ClassName=$$$NormalizeClassname(i%ClassName)
 i i%Name="" q $$$ERROR($$$PropertyNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$PropertyNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,propertyname
 i id[":"
 i  s classname=$p(id,":",1),propertyname=$p(id,":",2)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-1),propertyname=$p(id,".",len)
 s i%ClassName=classname
 s i%Name=propertyname
 ;
 s i%Final=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPfinal)
 s i%Calculated=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPcalculated)
 s i%Cardinality=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPcardinality)
 s i%Collection=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPcollection)
 s i%Description=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPdescription)
 s i%InitialExpression=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPinitialexpression)
 s i%Inverse=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPinverse)
 s i%Internal=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPinternal)
 s i%MultiDimensional=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPmultidimensional)
 s i%Private=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPprivate)
 s i%ReadOnly=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPreadonly)
 s i%Relationship=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPrelationship)
 s i%Required=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPrequired)
 s i%SqlCollation=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcollation)
 s i%SqlColumnNumber=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcolumnnumber)
 s i%SqlComputeCode=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputecode)
 s i%SqlComputed=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputed)
 s i%SqlComputeOnChange=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputeonchange)
 s i%SqlFieldName=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlfieldname)
 s i%SqlListDelimiter=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqllistdelimiter)
 s i%SqlListType=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqllisttype)
 s i%Transient=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPtransient)
 s i%Type=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPtype)
 s i%SequenceNumber=$$$defMemberKeyGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPsequencenumber)
 ;
 n param
 s param="" f  s param=$$$defSubMemberNext(classname,$$$cCLASSproperty,propertyname,$$$cPROPparameter,param) q:param=""  d
 . d ..Parameters.SetAt($$$defMemberArrayGet(classname,$$$cCLASSproperty,propertyname,$$$cPROPparameter,param),param)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$PropertyNameRequired)
 ;
 n classname,propertyname
 s classname=i%ClassName
 s propertyname=i%Name
 ;
 i id="" n sc s sc=..%IdSet(classname_":"_propertyname) i $$$ISERR(sc) QUIT sc
 ;
 #define SAVEstring(%class,%kind,%member,%keyword,%value) i %value'=$$$tableDefaultGet(%kind,%keyword) { $$$defMemberKeySet(%class,%kind,%member,%keyword,%value) } else { $$$defMemberKeyKill(%class,%kind,%member,%keyword) }
 #define SAVEnumber(%class,%kind,%member,%keyword,%value) i +%value'=$$$tableDefaultGet(%kind,%keyword) { $$$defMemberKeySet(%class,%kind,%member,%keyword,+%value) } else { $$$defMemberKeyKill(%class,%kind,%member,%keyword) }
 ;
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPcalculated,i%Calculated)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPcardinality,i%Cardinality)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPcollection,i%Collection)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPdescription,i%Description)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPinitialexpression,i%InitialExpression)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPinverse,i%Inverse)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPinternal,i%Internal)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPfinal,i%Final)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPmultidimensional,i%MultiDimensional)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPprivate,i%Private)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPreadonly,i%ReadOnly)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPrelationship,i%Relationship)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPrequired,i%Required)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcollation,i%SqlCollation)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcolumnnumber,i%SqlColumnNumber)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputecode,i%SqlComputeCode)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputed,i%SqlComputed)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlcomputeonchange,i%SqlComputeOnChange)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqlfieldname,i%SqlFieldName)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqllistdelimiter,i%SqlListDelimiter)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPsqllisttype,i%SqlListType)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPtransient,i%Transient)
 $$$SAVEstring(classname,$$$cCLASSproperty,propertyname,$$$cPROPtype,i%Type)
 $$$SAVEnumber(classname,$$$cCLASSproperty,propertyname,$$$cPROPsequencenumber,i%SequenceNumber)
 ;
 $$$defMemberKeyKill(classname,$$$cCLASSproperty,propertyname,$$$cPROPparameter)
 n p s p="" f  s p=..Parameters.Next(p) q:p=""  d
 . $$$defSubMemberSet(classname,$$$cCLASSproperty,propertyname,$$$cPROPparameter,p,..Parameters.GetAt(p))
 ;
 $$$defMemberSet(classname,$$$cCLASSproperty,propertyname,"")
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,propertyname
 s classname=$p(id,":",1)
 s propertyname=$p(id,":",2)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i propertyname="" q $$$ERROR($$$PropertyNameRequired)
 $$$defMemberKill(classname,$$$cCLASSproperty,propertyname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.PropertyDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>
</Export>
