<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2018.1.7 (Build 721U)" ts="2025-08-07 11:55:46">
<Class name="%Library.Storage">
<Description>
Physical Storage Base Class</Description>
<Abstract>1</Abstract>
<IncludeCode>%occSqlfunc</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Parameter name="STORAGECOMPILERCLASS">
<Default>%Compiler.Storage.Common</Default>
</Parameter>

<Parameter name="STORAGEINTERFACE">
<Description>
STORAGEINTERFACE defines the type of serialization implemented by this class.
The value has to match the classtype of the class that is inheriting the serialization
interface.</Description>
<Type>STRING</Type>
<Constraint>,persistent,serial</Constraint>
<Flags>ENUM</Flags>
</Parameter>

<Parameter name="IDTYPE">
</Parameter>

<Method name="%BuildIndices">
<Description><![CDATA[
<p>Builds entries for each index specified in the <var>idxlist</var> argument.
If <var>pIndexList</var> is empty then all indices that originate in the class are rebuilt. If no indexes 
are specified in <var>pIndexList</var> or there are other bitmap indexes specified in <var>pIndexList</var> 
and there is a bitmap extent index defined for the class and there are currently no entries in the bitmap extent index 
then it will be implicitly included in <var>pIndexList</var>. If there is an ID range specified in
<var>pStartID</var>-<var>pEndID</var> and there are either no indexes specified in <var>pIndexList</var>
or if indexes are specified then at least one of them is a bitmap index
then the bitmap extent index will be implicitly included in <var>pIndexList</var>. If the bitmap 
extent index is included then the bitmap extent index for each subextent is also built. </p>

<p>If <var>pAutoPurge</var> is true then the indices contained in <var>pIndexList</var> will be
purged before they are built as long as no range is specified, if a range is specified we will
skip any purge. The default is TRUE (1).</p>

<p>If <var>pLockFlag</var> is one (1) then an extent lock will be acquired before the indices
are built. If the lock cannot be acquired then an error is returned. The lock is released
after the index build is completed. If it is two (2) then a lock is acquired prior to filing 
indexes for that instance and it is released as soon the indexes for that instance are filed. 
If it is zero (0) then no locks are used while filing the indexes. If it is three (3) then it
an shared extent lock will be acquired before the indices are build.</p>

<p>If <var>pJournalFlag</var> is false then journaling is disabled for the processes used to build the 
indexes. If this flag is true then the journal status is not altered during BuildIndices(). 
The default value of this argument is 1 (TRUE). </p> 

<p><var>pStartID</var> and <var>pEndID</var> define a range of IDs for which indexes will be built. 
The range is inclusive. If the starting ID is not passed a non-null value then the range begins at the 
first ID defined in the extent. If the ending ID is not passed a non-null value then the range ends at the 
last ID defined in the extent. </p>

<p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be built.
This argument allows you to build all indices except those defined in <var>pIgnoreIndexList</var>.
The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be built. </p> 

<p>If <method>%OnBeforeBuildIndices</method> is implemented and is runnable then it will be called
just prior to purging and building any index structures. Refer to <method>%OnBeforeBuildIndices</method>
for more information.</p>

<p>If <method>%OnAfterBuildIndices</method> is implemented and is runnable then it will be called
after all index structures have been built completely. Refer to <method>%OnAfterBuildIndices</method>
for more information.</p>

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>.</p>

<p>If your index is corrupt running this function will not fix the corruption unless you rebuild the entire index
and purge the existing indexes. If you have inserted some new items but have deferred building the index for these
new items then you can run %BuildIndices on this range oif IDs to add the index entries for these new items.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndexList:%CacheString="",pAutoPurge:%Integer=1,pLockFlag:%Integer=0,pJournalFlag:%Integer=1,pStartID:%CacheString="",pEndID:%CacheString="",pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%BuildIndices")
]]></Implementation>
</Method>

<Method name="%DeleteData">
<Description><![CDATA[
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>. Persistent
classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%DeleteData")
]]></Implementation>
</Method>

<Method name="%KillExtentData">
<Description>
%KillExtentData() - kills extent data in storage. This method is
implemented by the storage class.</Description>
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%KillExtentData")
]]></Implementation>
</Method>

<Method name="%LoadData">
<Description>
%LoadData() - loads an object from storage. This method is
implemented by the storage class.</Description>
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%LoadData")
]]></Implementation>
</Method>

<Method name="%PurgeIndices">
<Description><![CDATA[
Deletes all entries from each index specified in the <var>idxlist</var> argument.
If <var>idxlist</var> is empty then all indices that originate
in the class are purged. The index definition remains intact.

<p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be purged.
This argument allows you to purge all indices except those defined in <var>pIgnoreIndexList</var>.
The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be purged. </p> 

<p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
This method is normally generated by the storage class for persistent classes using
<class>%Library.CacheStorage</class> or <class>%Library.CacheSQLStorage</class>. Persistent
classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>idxlist:%List="",lockExtent:%Boolean=0,pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%PurgeIndices")
]]></Implementation>
</Method>

<Method name="%ValidateIndices">
<Description><![CDATA[
%ValidateIndices() - Validates indices for a class
<br><br>
<b>Parameters:</b>
<dl>
<dt><i>idxList</i>
<dd>Optional.  "" to check all indices, or specify a $list of index names to check.  Default=""
<dt><i>autoCorrect</i>
<dd>Optional.  If true, correct any errors found.  Default=0
<dt><i>lockOption</i>
<dd>Optional.  Default = 1
     0 - No locking is performed at all
     1 - Shared locking as each row is checked
     2 - exclusive lock on entire table for duration of the run
<dt><i>multiProcess</i>
<dd>Optional.  If true, parts of %ValidateIndices will use parallel processing when possible.  Default=1
</dl>
<p><b>Returns:</b>
<dd>Status Code</dd>
</p>
<p><b>Example</b>:
<li>Do $SYSTEM.OBJ.ValidateIndices("Sample.Person","",1,2)</li>
<li>Do $SYSTEM.OBJ.ValidateIndices("Sample.Company",$lb("NameIdx"),1,1)</li>
</p>
<p><b>Note:</b>:
<br>Indices may also be validated by calling the class method <i>$SYSTEM.OBJ.ValidateIndices(classname,idxList,autoCorrect,lockOption)</i>.
<br>There is one main difference between validating indices through <i>$SYSTEM.OBJ.ValidateIndices()</i> and <i>##class(classname).%ValidateIndices()</i>.
<br><i>$SYSTEM.OBJ.ValidateIndices()</i> will validate the indices for a table, and it will also validate any indices in collection child tables for that table.  
<br>When using <i>##class(classname).%ValidateIndices()</i>, collection child table indices must be checked with separate calls.
<br>Also, when calling <i>$SYSTEM.OBJ.ValidateIndices()</i>, multiProcess default is 0. When calling <i>##class(classname).%ValidateIndices()</i>, multiProcess default is 1.
</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>idxList:%List="",autoCorrect:%Boolean=0,lockOption:%Integer=1,multiProcess:%Boolean=1</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%ValidateIndices")
]]></Implementation>
</Method>

<Method name="%SaveData">
<Description>
%SaveData() - saves an object to disk, checks uniqueness and referential
integrity constraints, and maintains index structures. This method is
implemented by the storage class.</Description>
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SaveData")
]]></Implementation>
</Method>

<Method name="%SQLDelete">
<Description>
This class just holds stub methods that will be injected into the class definition by the table
compiler.  No implementation details here.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowid,%check,%tstart=1,%mv=0,%polymorphic=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDelete")
]]></Implementation>
</Method>

<Method name="%SQLInsert">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String,%check:%Binary,%inssel,%vco,%tstart=1,%mv=0]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsert")
]]></Implementation>
</Method>

<Method name="%SQLUpdate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%rowid:%String,%check:%Binary,&%d,%vco,%tstart=1,%mv=0,%polymorphic=0,&%soid:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdate")
]]></Implementation>
</Method>

<Method name="%SQLAfterTriggers">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAfterTriggers")
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
ClassMethod %SQLAfterInsertTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAfterInsertTriggers")
}

ClassMethod %SQLAfterUpdateTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAfterUpdateTriggers")
}
*/
]]></Content>
</UDLText>

<Method name="%SQLAcquireLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%rowid:%String,s:%Boolean=0,&unlockref:%String=0]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAcquireLock")
]]></Implementation>
</Method>

<Method name="%SQLAcquireTableLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[s:%Boolean=0,&SQLCODE:%Integer,to:%Integer=""]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAcquireTableLock")
]]></Implementation>
</Method>

<Method name="%SQLBeforeTriggers">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBeforeTriggers")
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
ClassMethod %SQLBeforeInsertTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBeforeDeleteTriggers")
}

ClassMethod %SQLBeforeUpdateTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBeforeDeleteTriggers")
}
*/
]]></Content>
</UDLText>

<Method name="%SQLBuildIndices">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndices:%List="",pLockFlag:%Integer=0,pStartID:%CacheString="",pEndID:%CacheString="",pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildIndices")
]]></Implementation>
</Method>

<Method name="%SQLBuildPurgeIndexForRow">
<Description>
%SQLBuildPurgeIndexForRow - given a list of indices (or all by default), an ID, and new and old values, purge and build the index entries for the row
pIndices - $listbuild of index map names to purge/build.  Default is "" and means purge/build all indices
pActions - A string of action characters to perform.  If pActions["P", the old index entries will be Purged/Deleted.  If pActions["B", the new index entries will be Built/Defined.  
           The default is pActions="BP".  This can be overridden to provide a way to just Purge a row's index entries (delete) or to define a row's index entries (Insert).  Any other characters in pActions besides "B" or "P" are ignored.
pLockRow - 1/0 flag, default=1, 1 means acquire an exclusive, long-term lock on the row.  0 means no lock is acquired.
%d()     - Array subscripted by SqlColumnNumber which holds new values for indexed entries to be built
%e()     - Array subscripted by SqlColumnNumber which holds old values for indexed entries to be purged
pIgnoreIndexList - $listbuild of index map names to not purge/build.  Can be used in conjuction with pIndices to purge/build all indices except thise list.  Default is "".
</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIndices:%List="",pActions:%CacheString="BP",pLockRow:%Integer=1,&%d:%CacheString,&%e:%CacheString,pIgnoreIndexList:%CacheString=""]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildPurgeIndexForRow")
]]></Implementation>
</Method>

<Method name="%SQLBuildPurgeIndices">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndices:%List="",pBuild:%Boolean,pLockFlag:%Integer=0,pStartID:%CacheString="",pEndID:%CacheString="",pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildPurgeIndices")
]]></Implementation>
</Method>

<Method name="%SQLCheckUnique">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFromOrig:%Boolean=0,%pID:%String,%pVals...:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUnique")
]]></Implementation>
</Method>

<Method name="%SQLCheckUniqueKeys">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConNumber:%Integer,pFromOrig:%Boolean=0,pUpdate:%Boolean=0,pVals...:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUniqueKeys")
]]></Implementation>
</Method>

<Method name="%SQLCheckUniqueIndices">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIndices:%List,&pOK:%Boolean]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUniqueIndices")
]]></Implementation>
</Method>

<Method name="%SQLCopyIcolIntoName">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCopyIcolIntoName")
]]></Implementation>
</Method>

<Method name="%SQLCopyNameIntoIcol">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCopyNameToIcol")
]]></Implementation>
</Method>

<Method name="%SQLCreateInsDelTables">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pInsTrigObj:%String,&pDelTrigObj:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCreateInsDelTables")
]]></Implementation>
</Method>

<Method name="%SQLDefineiDjVars">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String,&subs:%String,master:%Boolean]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDefineiDjVars")
]]></Implementation>
</Method>

<Method name="%SQLDeleteChildren">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%parent:%String,%check:%String,&sqlcode:%Integer]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDeleteChildren")
]]></Implementation>
</Method>

<Method name="%SQLDeleteTempStreams">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDeleteTempStreams")
]]></Implementation>
</Method>

<Method name="%SQLExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pLockOnly:%Boolean=0,&pUnlockRef:%String,%pVal...:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLExists")
]]></Implementation>
</Method>

<Method name="%SQLEExit">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLEExit")
]]></Implementation>
</Method>

<Method name="%SQLFieldValidate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLFieldValidate")
]]></Implementation>
</Method>

<Method name="%SQLFKeyDelLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLFKeyDelLock")
]]></Implementation>
</Method>

<Method name="%SQLGetLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRowId:%String,pShared:%Boolean=0,&pUnlockRef:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetLock")
]]></Implementation>
</Method>

<Method name="%SQLGetOld">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%rowid:%String,&%d:%String,&%e:%String,&sqlcode:%Integer]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOld")
]]></Implementation>
</Method>

<Method name="%SQLGetOldAll">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOldAll")
]]></Implementation>
</Method>

<Method name="%SQLGetOldIndex">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%rowid:%String,&%d:%String,&pF:%String=0,&sqlcode:%Integer]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOldIndex")
]]></Implementation>
</Method>

<Method name="%SQLicompView">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLicompView")
]]></Implementation>
</Method>

<Method name="%SQLInsertComputes">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>view:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsertComputes")
]]></Implementation>
</Method>

<Method name="%SQLInsertStreams">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pVal:%String,pClassname:%String,pProperty:%String,pField:%String,pChangeEmptyToNull:%Boolean,pOIDType:%Boolean,&sqlcode:%Integer,&%msg:%String]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsertStreams")
]]></Implementation>
</Method>

<Method name="%SQLInvalid">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIcol:%Integer,pVal:%String</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInvalid")
]]></Implementation>
</Method>

<Method name="%SQLInvalid2">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>ficol:%Integer,val:%String,char:%String</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<PublicList>sqlcode</PublicList>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInvalid2")
]]></Implementation>
</Method>

<Method name="%SQLMissing">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>fname:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLmissing")
]]></Implementation>
</Method>

<Method name="%SQLMVDelete">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>oref:%Binary,flags:%String,%rowid:%String,oldrec:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVDelete")
]]></Implementation>
</Method>

<Method name="%SQLMVIndexDelete">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%e:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexDelete")
]]></Implementation>
</Method>

<Method name="%SQLMVIndexInsert">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexInsert")
]]></Implementation>
</Method>

<Method name="%SQLMVIndexUpdate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String,&%e:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexUpdate")
]]></Implementation>
</Method>

<Method name="%SQLMVInsert">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>oref:%Binary,flags:%String,%rowid:%String,newrec:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVInsert")
]]></Implementation>
</Method>

<Method name="%SQLMVUpdate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>oref:%Binary,flags:%String,%rowid:%String,newrec:%String,oldrec:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVUpdate")
]]></Implementation>
</Method>

<Method name="%SQLnBuild">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLnBuild")
]]></Implementation>
</Method>

<Method name="%SQLNormalizeCompFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLNormalizeCompFields")
]]></Implementation>
</Method>

<Method name="%SQLNormalizeFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLNormalizeFields")
]]></Implementation>
</Method>

<Method name="%SQLPurgeIndices">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndices:%List="",pLockExtent:%Boolean=0,pIgnoreIndexList:%CacheString=""</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLPurgeIndices")
]]></Implementation>
</Method>

<Method name="%SQLQuickBulkInsert">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%nolock:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkInsert")
]]></Implementation>
</Method>

<Method name="%SQLQuickBulkLoad">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowidlist:%List,%nolock:%Boolean=0,pkey:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkLoad")
]]></Implementation>
</Method>

<Method name="%SQLQuickBulkSave">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%nolock:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkSave")
]]></Implementation>
</Method>

<Method name="%SQLQuickBulkUpdate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%nolock:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkUpdate")
]]></Implementation>
</Method>

<Method name="%SQLQuickDelete">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowid:%String,%nolock:%Boolean=0,pkey:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickDelete")
]]></Implementation>
</Method>

<Method name="%SQLQuickDeleteChildren">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%parent:%String,%nolock:%Boolean=0,pkey:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickDeleteChildren")
]]></Implementation>
</Method>

<Method name="%SQLQuickFindPKeyByRowID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowid:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickFindPKeyByRowID")
]]></Implementation>
</Method>

<Method name="%SQLQuickFindRowIDByPKey">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPKey:%String,pOutput:%Boolean=1,pInternal:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickFindRowIDByPKey")
]]></Implementation>
</Method>

<Method name="%SQLQuickInsert">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&d:%String,%nolock:%Boolean=0,pkey:%Boolean=0,parentpkey:%Boolean=0]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickInsert")
]]></Implementation>
</Method>

<Method name="%SQLQuickLoad">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowid:%List,%nolock:%Boolean=0,pkey:%Boolean=0,qq:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickLoad")
]]></Implementation>
</Method>

<Method name="%SQLQuickLoadChildren">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%parref:%List,%nolock:%Boolean=0,pkey:%Boolean=0,returnpkey:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickLoadChildren")
]]></Implementation>
</Method>

<Method name="%SQLQuickLogicalToOdbc">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLLogicalToOdbcFields")
]]></Implementation>
</Method>

<Method name="%SQLQuickOdbcToLogical">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&%d:%String]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickOdbcToLogical")
]]></Implementation>
</Method>

<Method name="%SQLQuickUpdate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[%rowid:%String,&d:%String,%nolock:%Boolean=0,pkey:%Boolean=0]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickUpdate")
]]></Implementation>
</Method>

<Method name="%SQLReleaseLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%rowid:%String,s:%Boolean=0,i:%Boolean=0,e:%Boolean=""</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLReleaseLock")
]]></Implementation>
</Method>

<Method name="%SQLReleaseTableLock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>s:%Boolean=0,i:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTableReleaseLock")
]]></Implementation>
</Method>

<Method name="%SQLStorageValidation">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLStorageValidation")
]]></Implementation>
</Method>

<Method name="%SQLTrigDelTab">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTrigDelTab")
]]></Implementation>
</Method>

<Method name="%SQLTrigInsTab">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTrigInsTab")
]]></Implementation>
</Method>

<Method name="%SQLUnlockError">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>cname:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLULError")
]]></Implementation>
</Method>

<Method name="%SQLUnlock">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlock")
]]></Implementation>
</Method>

<Method name="%SQLUnlock2">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlock2")
]]></Implementation>
</Method>

<Method name="%SQLUnlockRef">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlockRef")
]]></Implementation>
</Method>

<Method name="%SQLUpdateComputes">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>view:%Boolean=0</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdateComputes")
]]></Implementation>
</Method>

<Method name="%SQLUpdateStreams">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNew:%String,pOld:%String,pClassname:%String,pProperty:%String,pField:%String,pChangeEmptyToNull:%Boolean,pOIDType:%Boolean,&sqlcode:%Integer,&%msg:%String,pAllowOid:%Boolean=0]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdateStreams")
]]></Implementation>
</Method>

<Method name="%SQLValidateCompFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sqlcode:%Integer]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLValidateCompFields")
]]></Implementation>
</Method>

<Method name="%SQLValidateFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&sqlcode:%Integer]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLValidateFields")
]]></Implementation>
</Method>
</Class>


<Class name="%Library.StorageDataDefinition">
<Description><![CDATA[
Contains information about a data definition within a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Structure">
<Type>%CacheString</Type>
</Property>

<Property name="Subscript">
<Type>%CacheString</Type>
</Property>

<Property name="Value">
<Type>%CacheString</Type>
</Property>

<Property name="ValueList">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%Name=$p(initvalue,":",3)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-2),i%StorageName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 ;
 s i%ValueList=$$$oidForm($lb($name($$$defSubMemberKeyRaw(i%ClassName,$$$cCLASSstorage,i%StorageName,$$$cSDEFdata,i%Name,$$$cSDEFDATAvalue)),i%ClassName_":"_i%StorageName_":"_i%Name,"%StorageDataValueDefinition"))
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,dataname,i
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),dataname=$p(id,":",3)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-2),storagename=$p(id,".",len-1),dataname=$p(id,".",len)
 ;
 s i%ClassName=classname
 s i%StorageName=storagename
 s i%Name=dataname

 Set i%Structure=$$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAstructure)
 Set i%Subscript=$$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAsubscript)
 Set i%Value=$$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAattribute)

 s i%ValueList=$$$oidForm($lb($name($$$defSubMemberKeyRaw(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAvalue)),id,"%StorageDataValueDefinition"))

 #; now swizzle everything in, so that they can be re-saved after the global is killed
 f i=1:1:..ValueList.Count() d ..ValueList.GetAt(i)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)

 n classname,storagename,dataname
 s classname=i%ClassName
 s storagename=i%StorageName
 s dataname=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_dataname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%value) i %value'=$$$tableDefaultGet(%keyword,%subkey) { $$$defStorageSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%value) } Else { $$$defStorageSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey) }

 $$$defStorageSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,"")
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAattribute,i%Value)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAstructure,i%Structure)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAsubscript,i%Subscript)

 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,dataname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s dataname=$p(id,":",3)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i dataname="" q $$$ERROR($$$StorageNameRequired)
 $$$defStorageSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageDataDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageDataValueDefinition">
<Description><![CDATA[
Contains information about a data value definition within a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="DataName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Value">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%DataName=$p(initvalue,":",3),i%Name=$p(initvalue,":",4)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-3),i%StorageName=$p(initvalue,".",len-2),i%DataName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%DataName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%DataName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,dataname,valuename
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),dataname=$p(id,":",3),valuename=$p(id,":",4)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-3),storagename=$p(id,".",len-2),dataname=$p(id,".",len-1),valuename=$p(id,".",len)
 ;
 s i%ClassName=classname
 s i%StorageName=storagename
 s i%DataName=dataname
 s i%Name=valuename

 Set i%Value=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAvalue,valuename,$$$cSDEFDATAVALvalue)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%DataName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)

 n classname,storagename,mapname,dataname
 s classname=i%ClassName
 s storagename=i%StorageName
 s dataname=i%DataName
 s valuename=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_dataname_":"_valuename) i $$$ISERR(sc) QUIT sc

 #define SAVESUBSUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) i %value'=$$$tableDefaultGet(%subkey,%subsubkey) { $$$defStorageSubSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) } Else { $$$defStorageSubSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey) }

 $$$defStorageSubSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAvalue,valuename,"")
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAvalue,valuename,$$$cSDEFDATAVALvalue,i%Value)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,dataname,valuename
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s dataname=$p(id,":",3)
 s valuename=$p(id,":",4)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i dataname="" q $$$ERROR($$$StorageNameRequired)
 i valuename="" q $$$ERROR($$$StorageNameRequired)

 $$$defStorageSubSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata,dataname,$$$cSDEFDATAvalue,valuename)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageDataValueDefinS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageDefinition">
<Description><![CDATA[
Contains information about a specific storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="DataDefinitions">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Property name="DataLocation">
<Type>%CacheString</Type>
</Property>

<Property name="DefaultData">
<Type>%CacheString</Type>
</Property>

<Property name="Description">
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Type>%CacheString</Type>
</Property>

<Property name="IdLocation">
<Type>%CacheString</Type>
</Property>

<Property name="IndexDefinitions">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Property name="IndexLocation">
<Type>%CacheString</Type>
</Property>

<Property name="StateSerial">
<Type>%CacheString</Type>
</Property>

<Property name="SQLBinding">
<Type>%StorageSQLDefinition</Type>
<InitialExpression>..ClassName_":"_..Name</InitialExpression>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Property name="Type">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%Name=$p(initvalue,":",2)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 ;
 s i%DataDefinitions=$$$oidForm($lb($name($$$defMemberKeyRaw(i%ClassName,$$$cCLASSstorage,i%Name,$$$cSDEFdata)),i%ClassName_":"_i%Name,"%StorageDataDefinition"))
 s i%IndexDefinitions=$$$oidForm($lb($name($$$defMemberKeyRaw(i%ClassName,$$$cCLASSstorage,i%Name,$$$cSDEFindex)),i%ClassName_":"_i%Name,"%StorageIndexDefinition"))
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-1),storagename=$p(id,".",len)

 s i%ClassName=classname
 s i%Name=storagename

 Set i%Description=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdescription)
 Set i%Internal=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFinternal)
 Set i%Type=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFtype)
 Set i%DataLocation=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdatalocation)
 Set i%DefaultData=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFdefaultdata)
 Set i%IdLocation=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFidlocation)
 Set i%IndexLocation=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFindexlocation)
 Set i%StateSerial=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFstate)

 s i%SQLBinding=$$$oidForm(id)

 s i%DataDefinitions=$$$oidForm($lb($name($$$defMemberKeyRaw(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata)),id,"%StorageDataDefinition"))
 s i%IndexDefinitions=$$$oidForm($lb($name($$$defMemberKeyRaw(classname,$$$cCLASSstorage,storagename,$$$cSDEFdata)),id,"%StorageIndexDefinition"))
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)

 n classname,storagename
 s classname=i%ClassName
 s storagename=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename) i $$$ISERR(sc) QUIT sc

 #define SAVEREQUIRED(%class,%kind,%member,%keyword,%value) $$$defMemberKeySet(%class,%kind,%member,%keyword,%value)
 #define SAVEKEYWORD(%class,%kind,%member,%keyword,%value) i %value'=$$$tableDefaultGet(%kind,%keyword) { $$$defMemberKeySet(%class,%kind,%member,%keyword,%value) } Else { $$$defMemberKeyKill(%class,%kind,%member,%keyword) }

 $$$defMemberSet(classname,$$$cCLASSstorage,storagename,"")
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdescription,i%Description)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFinternal,i%Internal)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdatalocation,i%DataLocation)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFdefaultdata,i%DefaultData)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFidlocation,i%IdLocation)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFindexlocation,i%IndexLocation)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFstate,i%StateSerial)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFtype,i%Type)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 $$$defMemberKill(classname,$$$cCLASSstorage,storagename)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageIndexDefinition">
<Description><![CDATA[
Contains information about an index definition within a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="IndexLocation">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%Name=$p(initvalue,":",3)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-2),i%StorageName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,indexname,i
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),indexname=$p(id,":",3)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-2),storagename=$p(id,".",len-1),indexname=$p(id,".",len)

 s i%ClassName=classname
 s i%StorageName=storagename
 s i%Name=indexname

 Set i%IndexLocation=$$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFindex,indexname,$$$cSDEFIDXlocation)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageNameRequired)
 ;
 n classname,storagename,indexname
 s classname=i%ClassName
 s storagename=i%StorageName
 s indexname=i%Name
 ;
 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_indexname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%value) i %value'=$$$tableDefaultGet(%keyword,%subkey) { $$$defStorageSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%value) } Else { $$$defStorageSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey) }

 $$$defStorageSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFindex,indexname,"")
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFindex,indexname,$$$cSDEFIDXlocation,i%IndexLocation)

 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,Indexname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s indexname=$p(id,":",3)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i indexname="" q $$$ERROR($$$StorageNameRequired)

 $$$defStorageSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFindex,indexname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageIndexDefinitioS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLDefinition">
<Description><![CDATA[
Contains SQL storage information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="IdExpression">
<Type>%CacheString</Type>
</Property>

<Property name="RowIdName">
<Type>%CacheString</Type>
</Property>

<Property name="TableNumber">
<Type>%CacheString</Type>
</Property>

<Property name="Maps">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-1),i%StorageName=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)

 #define GR(%kind) $name(^oddDEF(i%ClassName,$$$cCLASSstorage,i%StorageName,%kind))
 s i%Maps=$$$oidForm($lb($$$GR($$$cSDEFsqlmap),i%ClassName_":"_i%StorageName,"%StorageSQLMapDefinition"))

 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-1),storagename=$p(id,".",len)

 s i%ClassName=classname
 s i%StorageName=storagename
 #;
 s i%IdExpression=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlidexpression)
 s i%RowIdName=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlrowidname)
 s i%TableNumber=$$$defMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqltablenumber)

 #define GR(%element) $name(^oddDEF(classname,$$$cCLASSstorage,storagename,%element))
 s i%Maps=$$$oidForm($lb($$$GR($$$cSDEFsqlmap),id,"%StorageSQLMapDefinition"))

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)

 n classname,storagename
 s classname=i%ClassName
 s storagename=i%StorageName

 i id="" n sc s sc=..%IdSet(classname_":"_storagename) i $$$ISERR(sc) QUIT sc

 #define SAVEKEYWORD(%class,%kind,%member,%keyword,%value) i %value'=$$$tableDefaultGet(%kind,%keyword) $$$defMemberKeySet(%class,%kind,%member,%keyword,%value)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlidexpression,i%IdExpression)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlrowidname,i%RowIdName)
 $$$SAVEKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqltablenumber,i%TableNumber)

 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 $$$defMemberKeyKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlidexpression)
 $$$defMemberKeyKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlrowidname)
 $$$defMemberKeyKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqltablenumber)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLMapDataDefinition">
<Description><![CDATA[
Contains SQL mapping information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="MapName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Delimiter">
<Type>%CacheString</Type>
</Property>

<Property name="Node">
<Type>%CacheString</Type>
</Property>

<Property name="Piece">
<Type>%CacheString</Type>
</Property>

<Property name="RetrievalCode">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%MapName=$p(initvalue,":",3),i%Name=$p(initvalue,":",4)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-3),i%StorageName=$p(initvalue,".",len-2),i%MapName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapDataNameRequired)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapDataNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,dataname
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),mapname=$p(id,":",3),dataname=$p(id,":",4)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-3),storagename=$p(id,".",len-2),mapname=$p(id,".",len-1),dataname=$p(id,".",len)

 s i%ClassName=classname
 s i%StorageName=storagename
 s i%MapName=mapname
 s i%Name=dataname


 s i%Delimiter=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAdelimiter)
 s i%Node=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAnode)
 s i%Piece=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATApiece)
 s i%RetrievalCode=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAretrievalcode)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapDataNameRequired)

 n classname,storagename,mapname,dataname
 s classname=i%ClassName
 s storagename=i%StorageName
 s mapname=i%MapName
 s dataname=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_mapname_":"_dataname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBSUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) i %value'=$$$tableDefaultGet(%subkey,%subsubkey) { $$$defStorageSubSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) } Else { $$$defStorageSubSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey) }

 $$$defStorageSubSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,"")
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAdelimiter,i%Delimiter)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAnode,i%Node)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATApiece,i%Piece)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname,$$$cSDEFSQLMAPDATAretrievalcode,i%RetrievalCode)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,dataname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s mapname=$p(id,":",3)
 s dataname=$p(id,":",4)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i mapname="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i dataname="" q $$$ERROR($$$StorageSQLMapDataNameRequired)
 $$$defStorageSubSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPdata,dataname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)

 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLMapDataDefiS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLMapDefinition">
<Description><![CDATA[
Contains SQL mapping information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Condition">
<Type>%CacheString</Type>
</Property>

<Property name="ConditionFields">
<Type>%CacheString</Type>
</Property>

<Property name="ConditionalWithHostVars">
<Type>%CacheString</Type>
</Property>

<Property name="Global">
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Type>%CacheString</Type>
</Property>

<Property name="PopulationPct">
<Type>%CacheString</Type>
</Property>

<Property name="PopulationType">
<Type>%CacheString</Type>
</Property>

<Property name="Structure">
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Property name="RowIdSpec">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Property name="RowReference">
<Type>%CacheString</Type>
</Property>

<Property name="Subscript">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%Name=$p(initvalue,":",3)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-2),i%StorageName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapNameRequired)
 ;
 #define GR(%kind) $name(^oddDEF(i%ClassName,$$$cCLASSstorage,i%StorageName,$$$cSDEFsqlmap,i%Name,%kind))
 s i%Data=$$$oidForm($lb($$$GR($$$cSDEFSQLMAPdata),i%ClassName_":"_i%StorageName_":"_i%Name,"%StorageSQLMapDataDefinition"))
 s i%Subscript=$$$oidForm($lb($$$GR($$$cSDEFSQLMAPsubscript),i%ClassName_":"_i%StorageName_":"_i%Name,"%StorageSQLMapSubscriptDefinition"))
 s i%RowIdSpec=$$$oidForm($lb($$$GR($$$cSDEFSQLMAProwidspec),i%ClassName_":"_i%StorageName_":"_i%Name,"%StorageSQLMapRowIdSpecDefinition"))
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,i
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),mapname=$p(id,":",3)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-2),storagename=$p(id,".",len-1),mapname=$p(id,".",len)

 s i%ClassName=classname
 s i%StorageName=storagename
 s i%Name=mapname

 s i%Condition = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPcondition)
 s i%ConditionFields = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPconditionfields)
 s i%ConditionalWithHostVars = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPconditionalwithhostvars)
 s i%RowReference = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwreference)

 s i%Global = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPglobal)
 s i%Type = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPtype)
 s i%PopulationPct = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPpopulationpct)
 s i%PopulationType = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPpopulationtype)
 s i%Structure = $$$defStorageSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPstructure)

 #define GR(%kind) $name(^oddDEF(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,%kind))
 s i%Data=$$$oidForm($lb($$$GR($$$cSDEFSQLMAPdata),id,"%StorageSQLMapDataDefinition"))
 s i%Subscript=$$$oidForm($lb($$$GR($$$cSDEFSQLMAPsubscript),id,"%StorageSQLMapSubscriptDefinition"))
 s i%RowIdSpec=$$$oidForm($lb($$$GR($$$cSDEFSQLMAProwidspec),id,"%StorageSQLMapRowIdSpecDefinition"))

 #; now swizzle everything in, so that they can be re-saved after the global is killed
 f i=1:1:..Data.Count() d ..Data.GetAt(i)
 f i=1:1:..Subscript.Count() d ..Subscript.GetAt(i)
 f i=1:1:..RowIdSpec.Count() d ..RowIdSpec.GetAt(i)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapNameRequired)
 ;
 n classname,storagename,mapname
 s classname=i%ClassName
 s storagename=i%StorageName
 s mapname=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_mapname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%value) i %value'=$$$tableDefaultGet(%keyword,%subkey) { $$$defStorageSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%value) } Else { $$$defStorageSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey) }

 $$$defStorageSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,"")
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPcondition,i%Condition)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPconditionfields,i%ConditionFields)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPconditionalwithhostvars,i%ConditionalWithHostVars)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwreference,i%RowReference)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPglobal,i%Global)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPtype,i%Type)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPpopulationpct,i%PopulationPct)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPpopulationtype,i%PopulationType)
 $$$SAVESUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPstructure,i%Structure)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s mapname=$p(id,":",3)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i mapname="" q $$$ERROR($$$StorageSQLMapNameRequired)
 $$$defStorageSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)

 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLMapDefinitiS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLMapRowIdSpecDefinition">
<Description><![CDATA[
Contains SQL row Id information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="MapName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Field">
<Type>%CacheString</Type>
</Property>

<Property name="Expression">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%MapName=$p(initvalue,":",3),i%Name=$p(initvalue,":",4)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-3),i%StorageName=$p(initvalue,".",len-2),i%MapName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapRowIdSpecNameRequired)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapRowIdSpecNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,rowspecname
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),mapname=$p(id,":",3),rowspecname=$p(id,":",4)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-3),storagename=$p(id,".",len-2),mapname=$p(id,".",len-1),rowspecname=$p(id,".",len)
 s i%ClassName=classname
 s i%StorageName=storagename
 s i%MapName=mapname
 s i%Name=rowspecname
 s i%Field=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname,$$$cSDEFSQLMAPROWIDSPECfield)
 s i%Expression=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname,$$$cSDEFSQLMAPROWIDSPECexpression)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapRowIdSpecNameRequired)

 n classname,storagename,mapname,rowspecname
 s classname=i%ClassName
 s storagename=i%StorageName
 s mapname=i%MapName
 s rowspecname=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_mapname_":"_rowspecname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBSUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) i %value'=$$$tableDefaultGet(%subkey,%subsubkey) { $$$defStorageSubSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) } Else { $$$defStorageSubSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey) }

 $$$defStorageSubSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname,"")
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname,$$$cSDEFSQLMAPROWIDSPECfield,i%Field)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname,$$$cSDEFSQLMAPROWIDSPECexpression,i%Expression)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,rowspecname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s mapname=$p(id,":",3)
 s rowspecname=$p(id,":",4)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i mapname="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i rowspecname="" q $$$ERROR($$$StorageSQLMapRowIdSpecNameRequired)
 $$$defStorageSubSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAProwidspec,rowspecname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLMapRowIdSpeS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLMapSubInvCondDef">
<Description><![CDATA[
Contains SQL subscript Invalid Condition information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="MapName">
<Type>%CacheString</Type>
</Property>

<Property name="SubscriptName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="Expression">
<Type>%CacheString</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%MapName=$p(initvalue,":",3),i%SubscriptName=$p(initvalue,":",4),i%Name=$p(initvalue,":",5)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-4),i%StorageName=$p(initvalue,".",len-3),i%MapName=$p(initvalue,".",len-2),i%SubscriptName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%SubscriptName="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%SubscriptName="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,subsname,condname
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),mapname=$p(id,":",3),subsname=$p(id,":",4),condname=$p(id,":",5)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-4),storagename=$p(id,".",len-3),mapname=$p(id,".",len-2),subsname=$p(id,".",len-1),condname=$p(id,".",len)

 s i%ClassName=classname
 s i%StorageName=storagename
 s i%MapName=mapname
 s i%SubscriptName=subsname
 s i%Name=condname
 s i%Expression=$$$defStorageSubSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBinvalidcondition,condname,$$$cSDEFSQLMAPSUBINVCONDexpression)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%SubscriptName="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 ;
 n classname,storagename,mapname,subsname,condname
 s classname=i%ClassName
 s storagename=i%StorageName
 s mapname=i%MapName
 s subsname=i%SubscriptName
 s condname=i%Name

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_mapname_":"_subsname_":"_condname) i $$$ISERR(sc) QUIT sc

 #define SAVESUBSUBSUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%subsubsubmember,%subsubsubkey,%value) i %value'=$$$tableDefaultGet(%subsubkey,%subsubsubkey) { $$$defStorageSubSubSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%subsubsubmember,%subsubsubkey,%value) } Else { $$$defStorageSubSubSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%subsubsubmember,%subsubsubkey) }

 $$$SAVESUBSUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBinvalidcondition,condname,$$$cSDEFSQLMAPSUBINVCONDexpression,i%Expression)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,subsname,condname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s mapname=$p(id,":",3)
 s subsname=$p(id,":",4)
 s condname=$p(id,":",5)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i mapname="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i subsname="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 i condname="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 $$$defStorageSubSubSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBinvalidcondition,condname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLMapSubInvCoS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.StorageSQLMapSubscriptDefinition">
<Description><![CDATA[
Contains SQL subscript information for a storage definition for a class within the 
<i>Cach&eacute; Dictionary</i>.]]></Description>
<IncludeCode>%occReferenceStorage</IncludeCode>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%AbstractDefinition</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41416</TimeCreated>

<Property name="ClassName">
<Type>%CacheString</Type>
</Property>

<Property name="StorageName">
<Type>%CacheString</Type>
</Property>

<Property name="MapName">
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Type>%CacheString</Type>
</Property>

<Property name="AccessType">
<Type>%CacheString</Type>
</Property>

<Property name="Delimiter">
<Type>%CacheString</Type>
</Property>

<Property name="Expression">
<Type>%CacheString</Type>
</Property>

<Property name="NextCode">
<Type>%CacheString</Type>
</Property>

<Property name="StartValue">
<Type>%CacheString</Type>
</Property>

<Property name="StopExpression">
<Type>%CacheString</Type>
</Property>

<Property name="StopValue">
<Type>%CacheString</Type>
</Property>

<Property name="InvalidCondition">
<Type>%ListOfPersistentChildObjects</Type>
<Parameter name="CLASSNAME" value="1"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i initvalue[":"
 i  s i%ClassName=$p(initvalue,":",1),i%StorageName=$p(initvalue,":",2),i%MapName=$p(initvalue,":",3),i%Name=$p(initvalue,":",4)
 e  n len s len=$l(initvalue,"."),i%ClassName=$p(initvalue,".",1,len-3),i%StorageName=$p(initvalue,".",len-2),i%MapName=$p(initvalue,".",len-1),i%Name=$p(initvalue,".",len)
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)

 s i%InvalidCondition=$$$oidForm($lb($name(^oddDEF(i%ClassName,$$$cCLASSstorage,i%StorageName,"sql","map",i%MapName,"subscript",i%Name,$$$cSDEFSQLMAPSUBinvalidcondition)),i%ClassName_":"_i%StorageName_":"_i%MapName_":"_i%Name,"%StorageSQLMapSubInvCondDef"))
 ;
 q $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,subsname
 i id[":"
 i  s classname=$p(id,":",1),storagename=$p(id,":",2),mapname=$p(id,":",3),subsname=$p(id,":",4)
 e  n len s len=$l(id,"."),classname=$p(id,".",1,len-3),storagename=$p(id,".",len-2),mapname=$p(id,".",len-1),subsname=$p(id,".",len)
 ;
 s i%ClassName=classname
 s i%StorageName=storagename
 s i%MapName=mapname
 s i%Name=subsname

 s i%AccessType=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBaccesstype)
 s i%Delimiter=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBdelimiter)
 s i%Expression=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBexpression)
 s i%StartValue=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstartvalue)
 s i%StopExpression=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstopexpression)
 s i%NextCode=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBnextcode)
 s i%StopValue=$$$defStorageSubSubMemberKeyGet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstopvalue)

 s i%InvalidCondition=$$$oidForm($lb($name(^oddDEF(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBinvalidcondition)),id,"%StorageSQLMapSubInvCondDef"))

 #; now swizzle everything in, so that they can be re-saved after the global is killed
 f i=1:1:..InvalidCondition.Count() d ..InvalidCondition.GetAt(i)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%ClassName="" q $$$ERROR($$$ClassNameRequired)
 i i%StorageName="" q $$$ERROR($$$StorageNameRequired)
 i i%MapName="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i i%Name="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)
 ;
 n classname,storagename,mapname,subsname
 s classname=i%ClassName
 s storagename=i%StorageName
 s mapname=i%MapName
 s subsname=i%Name

 #define SAVESUBSUBKEYWORD(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) i %value'=$$$tableDefaultGet(%subkey,%subsubkey) { $$$defStorageSubSubMemberKeySet(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey,%value) } Else { $$$defStorageSubSubMemberKeyKill(%class,%kind,%member,%keyword,%submember,%subkey,%subsubmember,%subsubkey) }

 i id="" n sc s sc=..%IdSet(classname_":"_storagename_":"_mapname_":"_subsname) i $$$ISERR(sc) QUIT sc

 $$$defStorageSubSubMemberSet(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,"")
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstartvalue,i%StartValue)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstopexpression,i%StopExpression)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBstopvalue,i%StopValue)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBaccesstype,i%AccessType)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBdelimiter,i%Delimiter)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBexpression,i%Expression)
 $$$SAVESUBSUBKEYWORD(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname,$$$cSDEFSQLMAPSUBnextcode,i%NextCode)

 q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,storagename,mapname,subsname
 s classname=$p(id,":",1)
 s storagename=$p(id,":",2)
 s mapname=$p(id,":",3)
 s subsname=$p(id,":",4)
 i classname="" q $$$ERROR($$$ClassNameRequired)
 i storagename="" q $$$ERROR($$$StorageNameRequired)
 i mapname="" q $$$ERROR($$$StorageSQLMapNameRequired)
 i subsname="" q $$$ERROR($$$StorageSQLMapSubscriptNameRequired)

 $$$defStorageSubSubMemberKill(classname,$$$cCLASSstorage,storagename,$$$cSDEFsqlmap,mapname,$$$cSDEFSQLMAPsubscript,subsname)
 $$$defClassKeySet(classname,$$$cCLASStimechanged,$H)
 q $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Library.StorageSQLMapSubscripS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Library.Stream">
<Description><![CDATA[
Deprecated class, kept for legacy reasons, this now just extends the true stream
root class <class>%Stream.Object</class>. There should be no need
to reference this class with the new stream implementation.]]></Description>
<Abstract>1</Abstract>
<Super>%Stream.Object</Super>
<System>3</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59647,61086.417618</TimeCreated>
</Class>
</Export>
