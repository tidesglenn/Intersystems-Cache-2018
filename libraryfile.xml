<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2018.1.7 (Build 721U)" ts="2025-08-07 11:54:02">
<Class name="%Library.File">
<Description><![CDATA[
The <CLASS>%File</CLASS> class represents a disk file. It contains a
number of class methods that provide a number of file system 
services.

<p>For example,

<EXAMPLE>
If ##class(%File).Exists("file.txt") Write "It exists",!
</EXAMPLE>

<p>You can also create an instance of a <CLASS>%File</CLASS> object that 
represents a particular file. <CLASS>%File</CLASS> makes a number of file 
attributes accessible as properties as well as providing a 
<CLASS>%AbstractStream</CLASS> interface on the file.

<p>For example,
<EXAMPLE>
Set file=##class(%File).%New("file.txt")
Write file.Size
Do file.Open("WSN")
Do file.WriteLine("This is a line of text")
</EXAMPLE>
Note that this class is a fairly simple wrapper around the Cach&eacute;
file commands. For simply reading/writing to a file it is suggested that
you look at the <class>%Stream.FileCharacter</class> and
<class>%Stream.FileBinary</class> classes. These open the file using the
correct mode automatically in order to read or write to the file and so
are simpler to use.]]></Description>
<IncludeCode>%sySystem</IncludeCode>
<Super>%AbstractStream</Super>
<System>2</System>
<TimeChanged>66186,77913</TimeChanged>
<TimeCreated>59241,41414</TimeCreated>

<Property name="Name">
<Description>
The name of this file.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="5000"/>
</Property>

<Property name="CanonicalName">
<Description>
Read only property that returns the canonical filename if the file is open and "" if the file is not open.
On VMS this will include the file version number</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Parameter name="MAXLEN" value="5000"/>
</Property>

<Method name="CanonicalNameGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '..IsOpen Quit ""
	Set io=$IO
	Use ..Name Set name=$zio
	Use io
	Quit name
]]></Implementation>
</Method>

<Property name="DateCreated">
<Description>
The creation date for this file (rounded to the second).</Description>
<Type>%Date</Type>
<Calculated>1</Calculated>
</Property>

<Property name="DateModified">
<Description>
The last modified date for this file (rounded to the second).</Description>
<Type>%Date</Type>
<Calculated>1</Calculated>
</Property>

<Property name="IsOpen">
<Description>
True (1) if this file is currently open, false (0) otherwise.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="openmode">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN" value="5000"/>
</Property>

<Method name="%Load">
<FormalSpec>sid:%String</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>soid:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec><![CDATA[&sid:%String]]></FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Exists">
<Description><![CDATA[
Returns true (1) if <var>filename</var> exists.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set return=$$$FileExistsRet(filename)
	Quit return=0
]]></Implementation>
</Method>

<Method name="DirectoryExists">
<Description><![CDATA[
Tests if <var>filename</var> is a directory.
returns 1 if it is a directory, otherwise, returns 0.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If $$$isVMS {
		If filename'["[",$translate($extract(filename,*),":","\")="\" {
			Quit $zutil(140,13,filename)'<0
		}
		If $piece($piece(filename,"]"),"[",2)="000000",$piece(filename,"]",2,*)="" Quit $zutil(140,13,$piece(filename,":")_":")'<0
		Quit $select($$$FileDirectoryExists(filename):1,1:$piece($piece(filename,".",*),";")="DIR"&&($$$FileExists(filename)))
	} Else {
		Quit $$$FileDirectoryExists(filename)
	}
]]></Implementation>
</Method>

<Method name="NormalizeDirectory">
<Description><![CDATA[
Returns the normalized form of the directory name <var>filename</var>.
If you pass <var>directory</var> then it will normalize this filename relative to the provided directory,
if no <var>directory</var> is supplied then it is relative to the current default directory.
<var>addnull</var> is set to true on VMS if normalizing the directory involves adding [000000] the the name]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,directory:%String="",addnull:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$data(filename) Quit ""
	If directory'="" {
		Try {
			Set olddir=$$$FileSetCurrentDir(directory)
			Set return=..NormalizeDirectory(filename,,.addnull)
		} Catch {
			Set return=""
		}
		If $get(olddir)'="" Do $$$FileSetCurrentDir(olddir)
		Quit return
	}
	Set addnull=0
	If filename="" Quit $$$FileNormalizeDirectory($$$FileCurrentDir)
	If $$$isVMS {
		If filename'["[",$translate($extract(filename,*),":","\")="\" {
			Set tmp=$zutil(12,$extract(filename,1,*-1),4)
			If tmp=""||($extract(tmp,*-1,*)=".]") {
				Set filename=filename_"[000000]",addnull=1
			} Else {
				Set filename=tmp
			}
		}
		Quit $$$FileNormalizeDirectory($s($e(filename,*)="]":filename,1:"[."_filename_"]"))
	} ElseIf $$$isUNIX {
		Quit $$$FileNormalizeDirectory($translate(filename,"\","/"))
	} ElseIf $$$isWINDOWS {
		Quit $$$FileNormalizeDirectory($select($translate(filename,"/","\")'["\":filename_"\",1:filename))
	}
	Quit ""
]]></Implementation>
</Method>

<Method name="NormalizeFilename">
<Description><![CDATA[
Returns the normalized form of the <var>filename</var>.
If you pass <var>directory</var> then it will normalize this filename relative to the provided directory,
if no <var>directory</var> is supplied then it is relative to the current default directory. If the
<var>directory</var> does not exist then this method will return the empty string. Otherwise, this method
returns the normalized full path name of the specified file.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,directory:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$data(filename) Quit ""
	If directory="" Quit $$$FileNormalizeFilename(filename)
	Try {
		Set olddir=$$$FileSetCurrentDir(directory)
		Set name=$$$FileNormalizeFilename(filename)
	} Catch {
		Set name=""
	}
	If $get(olddir)'="" Do $$$FileSetCurrentDir(olddir)
	Quit name
]]></Implementation>
</Method>

<Method name="CanonicalFilename">
<Description><![CDATA[
VMS specific function, returns the canonical form of the <var>filename</var>, on VMS this will include the version number.
If the file can not be opened then it will return ""]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set opened=0,io=$IO,name=""
	Try {
		If ","_$translate($piece($View(-1,$job),"^",3),"*")_","'[(","_$ZU(12,filename)_",") {
			Open filename:"R":0 Else  Quit
			Set opened=1
		}
		Use filename Set name=$zio
	} Catch {}
	Use io
	If opened Close filename
	Quit name
]]></Implementation>
</Method>

<Method name="ManagerDirectory">
<Description><![CDATA[
Returns the path of the Cach&eacute; manager directory.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FileNormalizeDirectory($$$FileMgrDir)
]]></Implementation>
</Method>

<Method name="Delete">
<Description><![CDATA[
Deletes the file <var>filename</var>. Returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,*return:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If filename["*" {
		Quit ..ComplexDelete(.filename,.return)
	} Else {
		Set return=$$$FileDeleteRet(filename)
		Quit 'return
	}
]]></Implementation>
</Method>

<Method name="ReadOnly">
<Description>
Return true if the file is read only and false if it is writable</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$$$FileReadOnly(filename)
]]></Implementation>
</Method>

<Method name="ComplexDelete">
<Description><![CDATA[
Handle delete of cases where <var>filename</var> contains a wildcard.
Note: this does not delete subdirectories in the given directory; only files are removed.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,*return:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set resultset=##class(%ResultSet).%New("%File:FileSet"),return=0
	Do resultset.Execute(..GetDirectory(filename),..GetFilename(filename))
	Set exit=1
	For {
		Quit:'resultset.Next()
		Set file=resultset.Data("Name")
		Set r=$$$FileDeleteRet(file) If r,exit Set exit=0,return=r
	}
	Quit exit
]]></Implementation>
</Method>

<Method name="ComputeFullDBDir">
<Description><![CDATA[
Return the canonical form of the directory name <var>filename</var>.
When <var>filename</var> is a non-full path directory, it will prefix
the <var>filename</var> with Manager Path instead of current directory.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $$ComputeFullDBDir^%SYS.API(filename)
]]></Implementation>
</Method>

<Method name="CreateDirectory">
<Description><![CDATA[
Creates a directory with name <var>name</var>. Returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set return=$$$FileCreateDirectoryRet(name)
	Quit 'return
]]></Implementation>
</Method>

<Method name="CreateNewDir">
<Description><![CDATA[
Given a directory name and the name of a new directory create this directory inside
the given directory. Return true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String,name:%String,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set directory=..NormalizeDirectory(directory),return=0
	If directory="" Quit 0
	If $$$isVMS {
		Set newdir=$piece(directory,"]")_"."_name_"]"
	} ElseIf $$$isWINDOWS {
		Set directory=$translate(directory,"/","\")
		If $extract(directory,*)'="\" Set directory=directory_"\"
		Set newdir=directory_name
	} ElseIf $$$isUNIX {
		Set directory=$translate(directory,"\","/")
		If $extract(directory,*)'="/" Set directory=directory_"/"
		Set newdir=directory_name
	}
	Set return=$$$FileCreateDirectoryRet(newdir)
	Quit 'return
]]></Implementation>
</Method>

<Method name="CreateDirectoryChain">
<Description><![CDATA[
Create this directory and all the parent directories if they do not exist. This differs from
<method>CreateDirectory</method> as that method only creates one new directory where as
this will create the entire chain of directories. Returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set name=..NormalizeDirectory(name),return=0
	If name="" Quit 0
	If $$$FileDirectoryExists(name) Quit 1
	If $$$isVMS {
		Set tmp=$piece($piece(name,"[",2,*),"]")
		For i=1:1:$length(tmp,".") {
			Set dir=$piece(name,"[")_"["_$piece(tmp,".",1,i)_"]"
			If '$$$FileDirectoryExists(dir) Set return=$$$FileCreateDirectoryRet(dir) If return Quit
		}
		QUIT 'return
	}
	Set dirchar=$select($$$isWINDOWS:"\",1:"/")
	#; Loop backward to find the directory that does not exist in case the user does not have permissions on a parent directory
	#; but they do have permissions on the subdirectory
	For i=$length(name,dirchar)-1:-1:$s($$$isUNIX:1,$e(name,1,2)="\\":4,1:1) { 
	   Set dir=$piece(name,dirchar,1,i) 
	   If $$$FileDirectoryExists(dir) { 
	       For j=i+1:1:$length(name,dirchar)-1 { 
	           Set dir=$piece(name,dirchar,1,j) 
	           Set return=$$$FileCreateDirectoryRet(dir)
	           If return Quit 
	       } 
	       Quit 
	   } 
	} 
	Quit 'return
]]></Implementation>
</Method>

<Method name="SubDirectoryName">
<Description>
Given a directory name and the name of a sub directory create the name for the
subdirectory inside the given directory. Return the new directory name.
This is useful as the parsing of filenames on Unix/Windows/VMS is
different.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String,name:%String,normalized:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set newdir=..NormalizeDirectory(directory)
	If newdir="" Quit ""
	If $$$isVMS {
		If newdir="",directory'["[",directory[":" Set newdir=directory
		Set newdir=$select(name="":newdir,newdir'["[":newdir_"["_name_"]",1:$piece(newdir,"]")_"."_name_"]")
	} ElseIf $$$isWINDOWS {
		Set newdir=$translate(newdir,"/","\")
		If $extract(newdir,*)'="\" Set newdir=newdir_"\"
		Set newdir=newdir_name_$select(normalized:"\",1:"")
	} Else {
		Set newdir=$translate(newdir,"\","/")
		If $extract(newdir,*)'="/" Set newdir=newdir_"/"
		Set newdir=newdir_name_$select(normalized:"/",1:"")
	}
	Quit newdir
]]></Implementation>
</Method>

<Method name="ParentDirectoryName">
<Description><![CDATA[
Given a directory name, return the name of its parent directory.<br>
If the directory is already the root (e.g., "/" on Unix, "c:\" on Windows or "dka1:" on VMS), return the root.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set directory=..NormalizeDirectory(directory)
	If directory="" Quit ""
	If $$$isVMS {
		// for directory names like "dka1:[000000]", return itself
		// NB: "dka1:" is not considered a valid directory name per $zu(12,dir,1))
		i $p(directory,":",2)="[000000]" s newdir=directory
		e  s newdir=..SubDirectoryName(directory,"-")
	} Else { // Windows or Unix
		s newdir=..SubDirectoryName(directory,"..")
	}	
	// SubDirectoryName() doesn't normalize its return
	Quit ..NormalizeDirectory(newdir)
]]></Implementation>
</Method>

<Method name="Construct">
<Description><![CDATA[
Pass in an array of paths you want to turn into a filename, for example:
<example>Set dirs($i(dirs))=$system.Util.DataDirectory()
Set dirs($i(dirs))="httpd"
Set dirs($i(dirs))="logs"
Set filename=##class(%File).ConstructFilename(dirs...)</example>
If you want the name returned to be a directory terminated with a '/' or '\' then
pass in a null <var>dirs</var> entry as the last piece. You can also call
<method>Deconstruct</method> with the returned filename to turn this back into
an array like <var>dirs</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dirs...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $$$isUNIX {
		Set from="\",to="/",filename="/"
	} Else {
		Set from="/",to="\",filename=""
	}
	Set i=""
	For num=1:1 {
		Set i=$order(dirs(i),1,path) Quit:i=""
		Set path=$translate(path,from,to)
		Set filename=filename_path_$select($e(path,*)=to:"",1:to)
	}
	Set filename=$e(filename,1,*-1)
	Quit $select($s($e(filename,*)=to:1,1:0):$$$FileNormalizeDirectory(filename),1:$$$FileNormalizeFilename(filename))
]]></Implementation>
</Method>

<Method name="Deconstruct">
<Description><![CDATA[
Pass in a full <var>filename</var> and it will decompose it into the <var>dirs</var> array
with each integer subscript being a part of the path, this array can then be passed into
<method>Construct</method> to reconstruct the filename again.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filename:%String,&dirs:%String]]></FormalSpec>
<Implementation><![CDATA[
	Kill dirs
	Set hasterm=$case($e(filename,*),"/":1,"\":1,:0)
	Set filename=$select(hasterm:$$$FileNormalizeDirectory(filename),1:$$$FileNormalizeFilename(filename))
	Set filename=$translate(filename,"/","\")
	If $$$isWINDOWS {
		If $length($piece(filename,":"))=1 {
			Set item=$piece(filename,":")_":"
			Set dirs($i(dirs))=item,filename=$e($piece(filename,":",2,*),2,*)
		} ElseIf $extract(filename,1,2)="\\" {
			Set item=$piece(filename,"\",1,3)
			Set dirs($i(dirs))=item,filename=$piece(filename,"\",4,*)
		} Else {
			Set filename=""
		}
	} Else {
		Set filename=$extract(filename,2,*)
	}
	For i=1:1:$length(filename,"\") {
		Set dirs($i(dirs))=$piece(filename,"\",i)
	}
]]></Implementation>
</Method>

<Method name="GetFilename">
<Description>
Given a full directory and filename this will return just the filename portion of this name.
This is useful as the parsing of filenames on Unix/Windows/VMS is different.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $piece($translate(name,"/","\"),"\",*)
]]></Implementation>
</Method>

<Method name="GetDirectory">
<Description>
Given a full directory and filename this will return just the directory portion of this name.
This is useful as the parsing of filenames on Unix/Windows/VMS is different.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,keepterm:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $get(name)="" Set name=$$$FileCurrentDir
	If $$$isWINDOWS {
		Set name=$translate(name,"/","\"),name=$piece(name,"\",1,$length(name,"\")-1)
		If name'["\" Quit name_$select(name="":"",keepterm:"\",1:"")
		Quit $$$FileNormalizeDirectory(name_$select(keepterm:"\",1:""))
	} ElseIf $$$isVMS {
		If name["::" Set node=$piece(name,"::"),name=$piece(name,"::",2,*) If node'="" Set node=node_"::"
		If name'["[",$translate($extract(name,*),":","\")="\" Quit $get(node)_name
		If (name'["["),(name[":") q $zu(12,$p(name,":"))
		Quit $get(node)_$$$FileNormalizeDirectory($piece(name,"]")_$select(name["]":"]",1:""))
	} ElseIf $$$isUNIX {
		Set name=$translate(name,"\","/"),name=$piece(name,"/",1,*-1)
		If name'["/" Quit name_$select(keepterm:"/",1:"")
		Quit $$$FileNormalizeDirectory(name_$select(keepterm:"/",1:""))
	} Else {
		Quit ""
	}
]]></Implementation>
</Method>

<Method name="GetDirectoryLength">
<Description>
Return the number of pieces in this directory name</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If $get(name)="" Set name=$$$FileCurrentDir
	Do ..ParseDirectoryExecute(.qhandle,$select($$$isVMS:..NormalizeDirectory(name),1:..SubDirectoryName(name,"dummy")))
	If qhandle="" Quit 0
	Quit $listlength($list(qhandle))
]]></Implementation>
</Method>

<Method name="GetDirectoryPiece">
<Description>
Return the piece of a directory name</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[name:%String,piece:%Integer,&fullpath:%String,&IsDrive:%Boolean]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $get(name)="" Set name=$$$FileCurrentDir
	Do ..ParseDirectoryExecute(.qhandle,$select($$$isVMS:..NormalizeDirectory(name),1:..SubDirectoryName(name,"dummy")))
	If qhandle="" Quit ""
	Set tmp=$listget($list(qhandle),piece),fullpath=$listget(tmp,3),IsDrive=$listget(tmp,2)
	Quit $listget(tmp)
]]></Implementation>
</Method>

<Method name="GetDirectorySpace">
<Description><![CDATA[
Return the amount of total space and free space in either Bytes,MB,GB on a drive or directory
<br>
Name = Valid Drive or directory specification<br>
Flag = 0 - Return bytes<br>
Flag = 1 - Return MB (Default)<br>
Flag = 2 - Return GB<br>
<br>
MB and GB returned are rounded to 2 decimal places.<br>
Any error status returned is O/S level error. Note that on Windows
only drives have a measurement for free space and directories can not so
the <var>FreeSpace</var> is only returned for drives.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Name:%String,&FreeSpace:%String,&TotalSpace:%String,Flag:%Integer=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $get(Name)="" Set Name=$$$FileCurrentDir
	Set $ztrap="Error"
	Set FreeSpace=0,TotalSpace=0
	Set Status=$zutil(140,13,Name)
	If +Status<0 Quit $$$ERROR($$$ErrorCodeIs,$zabs(Status))
	Set BlockSize=$piece(Status,",",4)
	If $$$isUNIX {
		Set FreeSpace=$piece(Status,",",1)*BlockSize
	} Else {
		Set FreeSpace=$piece(Status,",",2)*BlockSize
	}
	Set TotalSpace=$piece(Status,",",3)*BlockSize
	If Flag=1 Set Div=1024*1024
	If Flag=2 Set Div=1024*1024*1024
	If Flag'=0 {
		Set FreeSpace=$fn(FreeSpace/Div,"",2)
		Set TotalSpace=$fn(TotalSpace/Div,"",2)
	}
	Quit $$$OK
Error Set $ztrap=""
	Quit $$$ERROR($$$CacheError,$zerror)
]]></Implementation>
</Method>

<Query name="ParseDirectory">
<Description>
Given a directory name return it pulled apart into individual subdirectories starting at the root node
and working down to the last directory name</Description>
<Type>%Query</Type>
<FormalSpec>directory:%String(MAXLEN="")</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,IsDrive:%Boolean,Directory:%String"/>
</Query>

<Method name="ParseDirectoryExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,directory:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	If directory="" Quit $$$OK
	If $extract(directory,*)'="\"&&($extract(directory,*)'="/") { Set directory=..GetDirectory(directory) } Else { Set directory=$$$FileNormalizeDirectory(directory) }
	If $$$isVMS {
		If directory[":" {
			Set item=$piece(directory,":")_":"
			Set QHandle=$listbuild($listbuild(item,1,item_"[000000]")),directory=$piece($piece(directory,":",2,*),"]")
		}
		If $extract(directory)="[" {
			Set directory=$extract(directory,2,*)
			Set item=item_"["
			For i=1:1:$length(directory,".") {
				If $piece(directory,".",i)'="" {
					Set item=item_$piece(directory,".",i)_"."
					Set QHandle=QHandle_$listbuild($listbuild($piece(directory,".",i),0,$extract(item,1,*-1)_"]"))
				}
			}
		}
	} ElseIf $$$isWINDOWS {
		Set directory=$translate(directory,"/","\")
		If $length($piece(directory,":"))=1 {
			Set item=$piece(directory,":")_":"
			Set QHandle=$listbuild($listbuild(item,1,item_"\")),directory=$piece(directory,":",2,*)
		} ElseIf $extract(directory,1,2)="\\" {
			Set item=$piece(directory,"\",1,3)
			Set QHandle=$listbuild($listbuild(item,0,item_"\")),directory=$piece(directory,"\",4,*)
		} Else {
			Quit $$$OK
		}
		For i=1:1:$length(directory,"\") {
			If $piece(directory,"\",i)'="" {
				Set item=item_"\"_$piece(directory,"\",i)
				Set QHandle=QHandle_$listbuild($listbuild($piece(directory,"\",i),0,item_"\"))
			}
		}
	} ElseIf $$$isUNIX {
		Set QHandle=$listbuild($listbuild("/",0,"/"))
		Set directory=$translate(directory,"\","/"),item=""
		For i=1:1:$length(directory,"/") {
			If $piece(directory,"/",i)'="" {
				Set item=item_"/"_$piece(directory,"/",i)
				Set QHandle=QHandle_$listbuild($listbuild($piece(directory,"/",i),0,item_"/"))
			}
		}
	}
	Set QHandle=$listbuild(QHandle,0)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ParseDirectoryClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ParseDirectoryFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set item=$listget(QHandle,2)+1
	If QHandle=""||(item>$listlength($list(QHandle))) Set AtEnd=1,QHandle="",Row="" Quit $$$OK
	Set Row=$list($list(QHandle),item)
	Set $list(QHandle,2)=item
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveDirectory">
<Description><![CDATA[
Removes directory <var>name</var>. Returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,*return:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set return=$$$FileRemoveDirectoryRet(name)
	Quit 'return
]]></Implementation>
</Method>

<Method name="RemoveDirectoryTree">
<Description><![CDATA[
Recursively remove directory <var>pTarget</var>. Returns true if it succeeds and false otherwise.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTarget:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
#define RDTREE	RDTree
#define RDTREETEMP $$$ISCQUERYTEMP$$$RDTREE

	Set %objlasterror=$$$OK,$ZT="Trap"

	// Directory Name cannot be ""
	If $Get(pTarget)="" Set %objlasterror=$$$ERROR($$$DirectoryNameRequired) Quit 0

	// If the target doesn't exist, then we're done
	If '..DirectoryExists(pTarget) Set %objlasterror = $$$ERROR($$$DirectoryNotExist,pTarget) Quit 0

	// Normalize the input directory names
	Set pTarget = ..NormalizeDirectory(pTarget)
	
	// Directory Name cannot be ""
	If $Get(pTarget)="" Set %objlasterror=$$$ERROR($$$DirectoryNameRequired) Quit 0

	// Set up an entry in CacheTemp
	Set tNode = $I($$$RDTREETEMP)
	Kill $$$RDTREETEMP(tNode)

	// Start by removing pTarget
	Set $$$RDTREETEMP(tNode,0) = pTarget
	
	While(1) {
		// Keep searching for work until there's nothing left.
		// We use a temp global to avoid being recursive in case of deep directory structures
		
		Set tIndex = $O($$$RDTREETEMP(tNode,""))
		Quit:tIndex=""
		
		// Grab the directory name to process next
		Set tNext = $$$RDTREETEMP(tNode,tIndex)
		
		// We must search this directory for:
		//	1) Additional directories to schedule for removal
		//	2) Files to delete


		// NOTE: If we ever implement a system level wildcard delete (i.e. not using a query to iterate) then
		//       we should delete files that way here, so the subsequent query will only return subdirectories
		//		 to be processed.  It's much faster to issue "rm *" to the OS (through an OS system call) than
		//		 to iterate.
		

		// Open a fileset on the directory
		Set tRS = ##class(%ResultSet).%New($classname()_":FileSet")
		If '$IsObject(tRS) ZTRAP "ERR"
		
		// Execute ...
		If 'tRS.Execute(tNext) ZTRAP "ERR"
		
		// Reset the "more work added" flag
		Set tMoreWorkAdded = 0
		
		// Now iterate over what's in the directory.  Note, if we don't have permissions to access this
		// directory, then the Next() returns 0 immediately since we can't "see" into the directory.
		While (tRS.Next()) {
			
			Set tType = tRS.Data("Type")
			Set tName = tRS.Data("Name")
			Set tItem = tRS.Data("ItemName")
			
			If tType = "D" {
				// Let's mark this directory for termination
				Set tDir = ..SubDirectoryName(tNext,tItem)
				Set $$$RDTREETEMP(tNode,$I($$$RDTREETEMP(tNode),-1)) = tDir  // Depth first, insert new dirs in front
				
				// But now we've added more work, so we can't remove this directory until it's empty of subdirs
				Set tMoreWorkAdded = 1
			} Else {
				// Delete the file
				If '$$$FileDelete(tName) Set %objlasterror = $$$ERROR($$$FileCanNotDelete,tName) ZTRAP "ERR"
			}
		}
		
		// At this point, we've removed any files from tNext and scheduled any subdirectories for removal
		// When the subdirectories have all been removed, we'll process this directory again and if it's
		// empty, we'll finally remove it
		
		If 'tMoreWorkAdded {
			
			// Remove the directory now that it is empty
			If '$$$FileRemoveDirectory(tNext) {
				// Failed ... probably a permissions problem or the directory could be in use (on Windows)
				Set %objlasterror = $$$ERROR($$$FileCanNotDelete,tNext) ZTRAP "ERR"
			}
			
			// Clean out this directory now it's been searched
			Kill $$$RDTREETEMP(tNode,tIndex)
		}
		
		// Loop again looking for more work
	}
	
Exit
	Kill $$$RDTREETEMP(tNode)
	
	// We return 0/1, but also set %objlasterror for the curious
	Quit $$$ISOK(%objlasterror)
	
Trap
	Set:$$$ISOK(%objlasterror) %objlasterror = $$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="Rename">
<Description><![CDATA[
Rename file <var>oldname</var> to <var>newname</var>. Returns true if it succeeds and false otherwise.
The rename subfunction is only intended for changing the name of a regular file, not directories or other types of files.
In particular, renaming a file across filesystems results in copying and deleting the original file,
but this will not work for a directory. Renaming a directory within a file system does work.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oldname:%String,newname:%String,*return:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set return=$$$FileRenameRet(oldname,newname)
	Quit 'return
]]></Implementation>
</Method>

<Method name="CopyFile">
<Description><![CDATA[
Copy a host file <var>from</var> to host file <var>to</var>. <br>
Parameter <var>pDeleteBeforeCopy</var> may be used to specify that if the target file already exists then it should be deleted before being overwritten 
with the source file. The default is 0 or false. <br>
This method returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>from:%String,to:%String,pDeleteBeforeCopy:%Boolean=0,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tRet = 1,return=0
	If pDeleteBeforeCopy {
		If $$$isVMS {
			// On VMS, remove version in order to purge all versions and create target file with version ;1
			Set to = $P(to,";",1)
		}
		If $$$FileExists(to) {
			Set return=$$$FileDeleteRet(to)
			If return {
				Set tRet = 0
				Set %objlasterror = $$$ERROR($$$FileCanNotDelete,to)
			}
		}
	}
	If tRet {
		Set return = $$$FileCopyRet(from,to)
		Set tRet='return
	}
	Quit tRet
]]></Implementation>
</Method>

<Method name="CopyDir">
<Description><![CDATA[
Copy a host directory from <var>pSource</var> to <var>pTarget</var>. <br>
Parameter <var>pOverlay</var>
Parameter <var>pDeleteBeforeCopy</var> may be used to specify that any file that already exists in the target directory should be deleted before
being overwritten with the source file. The default is 0 or false.<br>
This method returns true if it succeeds and false otherwise. <br>
Note: (1) If the target directory exists and <var>pOverlay</var> is false (default), then the operation fails. Also, if any of the target files exist 
and <var>pDeleteBeforeCopy</var> is false (default), then the operation may fail usually due to operating system characteristics. 
(2) The total number of files or directories created/copied during the operation can be gotten by passing a byref value in <var>pCreated</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSource:%String,pTarget:%String,pOverlay:%Boolean=0,&pCreated=0,pDeleteBeforeCopy:%Boolean=0]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
#define COPYDIR CopyDir
#define COPYDIRTEMP $$$ISCQUERYTEMP$$$COPYDIR

	Set pCreated = 0

	// Check source & target, source *must* exist and target must *not* exist
	If '..DirectoryExists(pSource) Set %objlasterror = $$$ERROR($$$DirectoryNotExist,pSource) Quit 0
	If 'pOverlay,..DirectoryExists(pTarget) Set %objlasterror = $$$ERROR($$$FileExists,pTarget) Quit 0

	// Normalize the input directory names
	Set pSource = ..NormalizeDirectory(pSource)
	Set pTarget = ..NormalizeDirectory(pTarget)
	
	// Set up an entry in CacheTemp
	Set tNode = $I($$$COPYDIRTEMP)
	Kill $$$COPYDIRTEMP(tNode)
	
	Set $ZT="Trap"
	Set %objlasterror = $$$OK
	Set $$$COPYDIRTEMP(tNode,pSource) = pTarget
	
	While(1) {
		// Keep searching until we're done
		Set tSrc = $O($$$COPYDIRTEMP(tNode,""))
		Quit:tSrc=""
		
		// Ensure the destination directory has been normalized
		Set tDest = ..NormalizeDirectory($$$COPYDIRTEMP(tNode,tSrc))
			
		// Firstly, we create the target dir
		If '..DirectoryExists(tDest)||'pOverlay {
			If '..CreateDirectoryChain(tDest) Set %objlasterror = $$$ERROR($$$CreateFailedBecause,tDest) ZTRAP "ERR"
			Set pCreated = pCreated + 1
		}
		
		// We must search this directory for:
		//	1) Additional directories to search
		//	2) Files to copy

		// Open a fileset on the source directory
		Set tRS = ##class(%ResultSet).%New($classname()_":FileSet")
		If '$IsObject(tRS) ZTRAP "ERR"
		
		// Execute ...
		If 'tRS.Execute(tSrc) ZTRAP "ERR"
		
		// Now iterate over what's in the directory
		While (tRS.Next()) {
			
			Set tType = tRS.Data("Type")
			Set tName = tRS.Data("Name")
			Set tItem = tRS.Data("ItemName")
			
			If tType = "F" {
				// Copy the file
				If '..CopyFile(tName,tDest_tItem,pDeleteBeforeCopy) Set %objlasterror = $$$ERROR($$$FileCanNotCopy,tName,tDest_tItem) ZTRAP "ERR"
				Set pCreated = pCreated + 1
			}
			
			If tType = "D" {
				// Let's mark this directory for searching
				Set tDir = ..SubDirectoryName(tDest,tItem)
				Set $$$COPYDIRTEMP(tNode,tName) = tDir
			}
			
			// Anything other than F or D, we ignore (e.g. symlinks etc)
		}
		
		// Clean out this directory now it's been searched
		Kill $$$COPYDIRTEMP(tNode,tSrc)
	}
	
Exit
	Kill $$$COPYDIRTEMP(tNode)
	
	Quit $$$ISOK(%objlasterror)
	
Trap
	Set:$$$ISOK(%objlasterror) %objlasterror = $$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetFileSize">
<Description><![CDATA[
Return the size of file <var>filename</var> in bytes.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$$$FileSize(filename)
]]></Implementation>
</Method>

<Method name="GetFileDateCreated">
<Description><![CDATA[
Return the date created of file <var>filename</var> in $H format.
By default this is local time, if you pass <var>utc</var> as true it returns it in UTC time.
The value is rounded to second precision.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String,utc:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FileDateCreated(filename,utc)
]]></Implementation>
</Method>

<Method name="GetFileDateModified">
<Description><![CDATA[
Return the date last modified of file <var>filename</var> in $H format.
By default this is local time, if you pass <var>utc</var> as true it returns it in UTC time.
The value is rounded to second precision.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String,utc:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FileDateModified(filename,utc)
]]></Implementation>
</Method>

<Method name="Writeable">
<Description>
Return true if the file/directory is writable and false if it is not</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$$$FileWritable(filename)
]]></Implementation>
</Method>

<Method name="Attributes">
<Description><![CDATA[
Return the attributes of the file.
The format of the returned value depends on the underlying operating system.
<p>
Microsoft Windows&reg; returns a value as a combination of bits whose meaning is:
<br>
<ul>
<li>1: 0x00001 - Read-only</li>
<li>2: 0x00002 -  Hidden</li>
<li>4: 0x00004 -  System</li>
<li>8:  0x00008 - Unused</li>
<li>16: 0x00010 -  Directory</li>
<li>32: 0x00020 -  Archive</li>
<li>64: 0x00040 -  Device</li>
<li>128: 0x00080 -  Normal</li>
<li>256: 0x00100 -  Temporary</li>
<li>512: 0x00200-  Sparse File</li>
<li>1024: 0x00400 -  Reparse Point</li>
<li>2048: 0x00800 -  Compressed</li>
<li>4096: 0x01000 -  Offline</li>
<li>8192: 0x02000 -  Content Not Indexed</li>
<li>16384: 0x04000 -  Encrypted</li>
<li>32768: 0x08000 -  Unused</li>
<li>65536: 0x10000 -  Virtual</li>
</ul>
<p>
In UNIX&reg;, the returned value represents the mode map:
<br>
<ul>
<li>1: 0x0001 - execute permission for others</li>
<li>2: 0x0002 -  write permission for others</li>
<li>4: 0x0004 -  read permission for others</li>
<li>7: 0x0007 - mask for others permissions
<li>8: 0x0008 -  execute permission for group</li>
<li>16: 0x0010 -  write permission for group</li>
<li>32: 0x0020 -  read permission for group</li>
<li>56: 0x0038 - mask for group  permissions
<li>64: 0x0040 -  execute permission for owner</li>
<li>128: 0x0080 -  write permission for owner</li>
<li>256: 0x0100 -  read permission for owner</li>
<li>448: 0x01C0 - mask for file owner permissions
<li>512: 0x0200 -  sticky bit</li>
<li>1024: 0x0400 -  set groupid</li>
<li>2048: 0x0800 -  set userid</li>
<li>4096: 0x1000 -  fifo</li>
<li>8192: 0x2000 -  character device</li>
<li>16384: 0x4000 -  directory</li>
<li>24576: 0x6000 - block device
<li>32768: 0x8000 -  regular file</li>
<li>40960: 0xA000 - symbolic link</li>
<li>49152: 0xC000 - socket</li>
<li>61440: 0xF000 - mask for file type</li>
</ul>
<p>
On OpenVMS, this is the file protection presented
as four 4-bit fields, accessed by the following hexadecimal masks:
<br>
<ul>
<li>000F: system privileges</li>
<li>00F0: owner privileges</li>
<li>0F00: group privileges</li>
<li>F000: world privileges</li>
</ul>
where each of these subfields has bit values with the following
meanings:
<br>
<ul>
<li>1: no read access</li>
<li>2: no write access</li>
<li>4: no execute access</li>
<li>8: no delete access</li>
</ul>
<p>
Note: Individual Operating System vendor differences may exist. 
The relevant man/help pages or other associated documentation 
should be consulted for a definitive description of the file attributes
on a given system.
]]></Description>
<ClassMethod>1</ClassMethod>
<ClientName>FileAttributes</ClientName>
<CodeMode>expression</CodeMode>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FileAttributes(filename)
]]></Implementation>
</Method>

<Method name="VMSRecordFormat">
<Description>
Return information on the VMS record format for this file.
This function only works on VMS and returns one of returns one of the following strings: "UDF", "FIX", "VAR", "VFC", "STM", "STMLF", "STMCR".
This allows a user to determine what OPEN mode should be used to read an unknown file from Cache. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $$$FileVMSRecordFormat(filename)
]]></Implementation>
</Method>

<Method name="SetAttributes">
<Description><![CDATA[
Set the OS specific attributes of the file.
See the Attribute method in this class for file attribute values.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,attributes:%String,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set return=$$$FileSetAttributesRet(filename,attributes)
	Quit return=1
]]></Implementation>
</Method>

<Method name="SetWriteable">
<Description><![CDATA[
Make this file/directory writable (if we can). The <var>writeonly</var>
defaults to true in which case this makes the file write only, if you just
want to add writable to the existing permissions without modifying the
other permissions pass <var>writeonly</var>=0. The <var>writeonly</var>
has no effect on Windows so you do not need to pass this argument on this platform.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,writeonly:%Boolean=1,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set existing=$$$FileAttributes(filename),new=existing,return=1
	If existing<0 Quit 0
	If $$$isWINDOWS {
        #; new attribute-set is old minus "read-only"
		Set new=$zboolean(existing,1,2)
	} ElseIf $$$isUNIX {
        #; existing PLUS [146 = 128/u+w + 16/g+w + 2/o+w]
        If writeonly Set new=$zboolean(existing,292,2)
        Set new=$zboolean(new,146,7)
	} Else {
        #; VMS new file protection value removes all no-writes x2222
		Set new=$zboolean(existing,8738,2)
        If writeonly Set new=$zboolean(new,4369,7)
	}
	If existing=new Quit 1
	Set return=$$$FileSetAttributesRet(filename,new)
	Quit return=1
]]></Implementation>
</Method>

<Method name="SetReadOnly">
<Description><![CDATA[
Make this file/directory read only (if we can).
If <var>leaveexisting</var> is true then it will add read permissions to the
file/directory without changing the existing permissions, by default
it will remove all other permissions other than read only flags. The <var>leaveexisting</var>
has no effect on Windows so you do not need to pass this argument on this platform.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,leaveexisting:%Boolean=0,*return:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set existing=$$$FileAttributes(filename),new=existing,return=1
	If existing<0 Quit 0
	If $$$isWINDOWS {
		Set new=$zboolean(existing,1,7)
	} ElseIf $$$isUNIX {
        If 'leaveexisting Set new=$zboolean(existing,292,7)
        Set new=$zboolean(new,146,2)
	} Else {
		Set new=$zboolean(existing,8738,7)
        If 'leaveexisting Set new=$zboolean(new,4369,2)
	}
	If existing=new Quit 1
	Set return=$$$FileSetAttributesRet(filename,new)
	Quit return=1
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// instance methods

]]></Content>
</UDLText>

<Method name="%OnNew">
<FormalSpec>initval:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; pass filename via %New()
	Set:initval'="" ..Name=initval
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; close the file if open
	Do:..IsOpen ..Close()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Open">
<Description><![CDATA[
Open the current file with mode <var>mode</var>.

<p><var>mode</var> is a string containing one or more file modes including:
<table COLS=2>
<tr><TD><B>R</B></TD><TD>Read</TD></tr>
<tr><TD><B>W</B></TD><TD>Write</TD></tr>
<tr><TD><B>S</B></TD><TD>Stream mode</TD></tr>
<tr><TD><B>N</B></TD><TD>Create a new file (overwrite existing file)</TD></tr>
</table>
Note that if the <var>mode</var> contains ':' characters this is a delimiter.
For example if the mode="RN:/SHARED" then it will open the file with the equivalent
of the COS command 'Open name:("RN":/SHARED):0'. The first piece before the
':' is quoted and the subsequent pieces are not.
<P>
A complete discussion of the available options for <var>mode</var> can 
be found in the online documentation in the book,
<B>Cach&eacute; I/O Devices Guide</B>, specifically the chapter on Sequential File I/O.
]]></Description>
<FormalSpec>mode:%String="",timeout:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:..IsOpen $$$ERROR($$$FileAlreadyOpen,..Name)
	Set devices=","_$TR($P($View(-1,$j),"^",3),"*","")_","
	If devices[(","_$ZU(12,..Name)_",") Quit $$$ERROR($$$FileAlreadyOpen,..Name)
	
	If mode'[":" {
		Open ..Name:(mode):timeout Else  Set i%IsOpen=0 Quit $$$ERROR($$$FileCanNotOpen,..Name)
	} Else {
		Set open="Open ..Name:("""_$piece(mode,":")_""""
		For i=2:1:$length(mode,":") Set open=open_":"_$piece(mode,":",i)
		Set open=open_"):"_timeout
		Xecute open Set opened=$test
		If opened=0 Set i%IsOpen=0 Quit $$$ERROR($$$FileCanNotOpen,..Name)
	}
	
	Set i%IsOpen=1,i%openmode=mode
	Set ..AtEnd=0
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Close">
<Description>
Close the current file.</Description>
<Implementation><![CDATA[
	If ..IsOpen {
		Close ..Name
		Set i%IsOpen=0,..AtEnd=0
	}
	Quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// stream interface

]]></Content>
</UDLText>

<Method name="Rewind">
<Description>
Moves the current location to the beginning of the stream.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsOpen $$$ERROR($$$FileNotOpen,..Name)
	
	#; rewind the device
	If $$$isVMS {
		Do ..Close()
		Quit ..Open(i%openmode)
	} Else {
		Set io=$io Use ..Name:0 Use io
	}
	Set ..AtEnd=0
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Clear">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Get rid of the attributes first
	Kill i%Attributes
	
	Quit:'..IsOpen $$$ERROR($$$FileNotOpen,..Name)
	
	If $$$ISERR(..Write("")) Quit $$$ERROR($$$FileNotOpen,..Name)
	Do ..Close()
	Set sc=$$$FileDelete(..Name) Quit:$$$ISERR(sc) sc
	Set ..AtEnd=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Read">
<Description><![CDATA[
Read up to <var>len</var> characters from this <b>File</b>.]]></Description>
<FormalSpec><![CDATA[&len:%Integer=32000,&sc:%Status]]></FormalSpec>
<ReturnType>%CacheString</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK
	#; file not open?
	If '..IsOpen Set len=-1,..AtEnd=1 Quit ""
	
	#; don't allow reads of more than $$$MaxStringLength
	Set:len>$$$MaxStringLength len=$$$MaxStringLength
	
	#; test for end of file and other errors
	Set out="",$ZTRAP="ReadError"
	
	Set io=$io
	Use ..Name
	Read:len out#len
	If $ZEOF Set $ZE="<ENDOFFILE>" Goto ReadError
	Use io
	Set len=$l(out)
	Quit out

ReadError	Set $ZTRAP=""
	Use io
	
	; test for non-end-of-file error
	If $E($ze,1,11)'="<ENDOFFILE>" Set sc=$$$ERROR($$$CacheError,$zerror) Close ..Name Set i%IsOpen=0,..AtEnd=1,len=-1 Quit ""
	
	; we're at the end
	Set ..AtEnd=1
	Set len=$l(out)
	Set:len=0 len=-1 ;if we are at the end with no data return -1
	
	Quit out
]]></Implementation>
</Method>

<Method name="Write">
<Description><![CDATA[
Write <var>data</var> to this <CLASS>%File</CLASS> object.]]></Description>
<FormalSpec>data:%CacheString=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsOpen $$$ERROR($$$FileNotOpen,..Name)
	
	Set ..AtEnd=0
	
	Set $ZTRAP="WriteError"
	Set io=$io Use ..Name Write data Use io
	Quit $$$OK

WriteError	Set $ZTRAP=""
	Use io
	Close ..Name
	Set i%IsOpen=0
	Quit $$$ERROR($$$CacheError,$ze)
]]></Implementation>
</Method>

<Method name="WriteLine">
<Description><![CDATA[
Write <var>data</var> with a carriage return to this <CLASS>%File</CLASS> object.]]></Description>
<FormalSpec>data:%CacheString=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsOpen $$$ERROR($$$FileNotOpen,..Name)
	
	Set ..AtEnd=1
	
	Set $ZTRAP="WriteLineError"
	Set io=$io Use ..Name Write data,! Use io
	Quit $$$OK

WriteLineError	Set $ZTRAP=""
	Use io
	Close ..Name
	Set i%IsOpen=0
	Quit $$$ERROR($$$CacheError,$ze)
]]></Implementation>
</Method>

<Method name="IsOpenSet">
<FormalSpec>%val:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DateCreatedGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[$$$FileDateCreated(..Name)
]]></Implementation>
</Method>

<Method name="DateModifiedGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[$$$FileDateModified(..Name)
]]></Implementation>
</Method>

<Method name="SizeGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$$$FileSize(..Name)
]]></Implementation>
</Method>

<Query name="DriveList">
<Description><![CDATA[
This query was originally created to return Windows drive letters, hence its name.
Later it was extended to work on VMS and Unix.<ul>
<li>Windows: return a list of available drives</li>
<li>Unix: return a list of mounted file systems</li>
<li>VMS: return a list of available disk devices</li></ul>
On Windows, if <var>fullyqualified</var> is true then the drive letters include the
trailing '\' character.  The default is false; this is backward compatible and returns
'c:' on Windows. This does not affect the behavior on VMS or Unix.]]></Description>
<Type>%Query</Type>
<FormalSpec>fullyqualified:%Boolean=0</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Drive:%String"/>
</Query>

<Method name="DriveListExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,fullyqualified:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $zt="Error",d=""
 If $$$isVMS Do
 . Set i=$ZU(108,"DISK",0,0)
 . For  Quit:i=""  Do
 . . Set dev=$p(i,"^"),mnt=+$p($ZU(108,"INFO",dev,100,"l"),"^",2)
 . . If mnt Do
 . . . If (d[(","_dev_","))!($p(d,",",1)=dev) Quit
 . . . Set d=d_dev_","
 . . Set i=$ZU(108,"DISK",$p(i,"^",2),$p(i,"^",3))
 Else  If $$$isWINDOWS Do
 . Set drv=$zu(108),j=1
 . For i=97:1:122 Set:i'=97 j=j*2 Quit:j>drv  Set:drv\j#2 d=d_$c(i)_":"_$select(fullyqualified:"\,",1:",")
 Else  If $$$isUNIX Do
 . Set d=$ZU(108)
 . If $$$isMACOSX Do
 . . Set i=$ZSEARCH("/Volumes/*")
 . . For  Quit:i=""  Set:i'="/Volumes/.DS_Store" d=d_i_"," Set i=$ZSEARCH("")
 s QHandle=d
 Quit $$$OK
Error s $zt=""
 Quit $$$ERROR($$$CacheError,$ze)
]]></Implementation>
</Method>

<Method name="DriveListClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DriveListFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Row=$Piece(QHandle,",")
	Set QHandle=$Piece(QHandle,",",2,*)
	Set AtEnd=(QHandle="")
	If Row'="" Set Row=$listbuild(Row)
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="FileSet">
<Description><![CDATA[
Return the list of files in <var>directory</var> matching the pattern <var>wildcards</var>.
The <var>sortby</var> can be one of:<ul>
<li>Name - the name of the file (the default)</li>
<li>Type - file type</li>
<li>DateCreated - the date the file was created (rounded to second)</li>
<li>DateModified - the date the file was last modified (rounded to second)</li>
<li>Size - the file size</li></ul>
The <var>includedirs</var> if true (default is 0) will force the list
of all directories to be returned before any files, the directories will ignore the pattern you supplied so it returns them all.
If it is false it will
return any files that match the pattern you give it, this may include directories if they match the pattern as well.
So true forces any directory to be included, but false does not exclude directories.
You may also specify the <var>delimiter</var> that is used to separate the <var>wildcards</var>
from each other, this defaults to ";".]]></Description>
<Type>%Query</Type>
<FormalSpec>directory:%String(MAXLEN=""),wildcards:%String,sortby:%String="",includedirs:%Boolean=0,delimiter:%String=";"</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,Type:%String,Size:%BigInt,DateCreated:%TimeStamp,DateModified:%TimeStamp,ItemName:%String"/>
</Query>

<Method name="FileSetExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,directory:%String,wildcards:%String,sortby:%String="",includedirs:%Boolean=0,delimiter:%String=";"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set directory=$get(directory),stripnull=0
	#; Work around Studio adding '\' to the end of drives on VMS
	If $$$isVMS,$extract(directory,*-1,*)=":\" Set directory=$extract(directory,1,*-1)
	If directory="" Set directory=..NormalizeDirectory("")
	If '..DirectoryExists(directory) Quit $$$ERROR($$$DirectoryNotExist,directory)
	Set QHandle=""
	Set dir=..NormalizeDirectory(directory,,.stripnull)
	If $$$isUNIX {
		If '$$$FileExists(dir_".") Quit $$$ERROR($$$DirectoryPermission,directory)
	}
	
	#; create temp node of filenames in this directory
	Set tempnode = $increment(^||%FileList) Kill ^||%FileList(tempnode)
	Set index=0,dirinplace=0
	If $get(wildcards)="" Set wildcards=$select($$$isVMS:"*.*",1:"*")
	
	#; build the list of files
	#; optional temp is pre-sorted list of files
	#; if includedirs, we force a list of directories to be returned first
	#; for all queries
	If includedirs {
		If (wildcards="*"&&('$$$isVMS))||(wildcards="*.*"&&('$$$isUNIX)) {
			Set dirinplace=1
		} Else {
			#; find all the directories first
			Set f = $zsearch(dir_$select($$$isVMS:"*.*",1:"*"))
			While (f '= "") {
				If $select($$$isVMS:..DirectoryExists(f),1:$$$FileDirectoryExists(f)) {
					Set filename=..GetFilename(f)
					If filename'=".",filename'="..",filename'="000000.DIR;1",filename'="" {
						Set filelist(filename)=""
						Set ^||%FileList(tempnode,0," "_$zconvert(filename,"l"),$increment(index))=$listbuild(f,filename)
					}
				}
				Set f = $zsearch("")
			}
		}
	}
	
	For i=1:1:$length(wildcards,delimiter) {
		Set wildcard=$piece(wildcards,delimiter,i)
		If $$$isWINDOWS {
			Set wildcard=$zconvert(wildcard,"l")
			If $data(wildcard(wildcard)) Continue
			Set wildcard(wildcard)=""
		}
		Set f = $zsearch(dir_wildcard)
		While (f '= "") {
			Set filename=..GetFilename(f)
			If filename="."||(filename="..")||(filename="000000.DIR;1")||(filename="") Goto cont
			If $data(filelist(filename)) Goto cont
			Set filelist(filename)=""
			If dirinplace,$select($$$isVMS:..DirectoryExists(f),1:$$$FileDirectoryExists(f)) {
				Set ^||%FileList(tempnode,0," "_$zconvert(filename,"l"),$increment(index))=$listbuild(f,filename)
				Goto cont
			}
			If sortby="DateCreated" {
				Set sort=$$$FileDateCreated(f),sort=$piece(sort,",")*86400+$piece(sort,",",2)
			} ElseIf (sortby = "DateModified") {
				Set sort=$$$FileDateModified(f),sort=$piece(sort,",")*86400+$piece(sort,",",2)
			} ElseIf (sortby = "Size") {
				Set sort=$$$FileSize(f)
			} ElseIf (sortby = "Type") {
				If includedirs {
					Set sort=" "_$zconvert($piece(f,".",*),"l")
				} ElseIf $select($$$isVMS:..DirectoryExists(f),1:$$$FileDirectoryExists(f)) {
					Set ^||%FileList(tempnode,0," "_$zconvert(filename,"l"),$increment(index))=$listbuild(f,filename) Goto cont
				} Else {
					Set sort=" "_$zconvert($piece(f,".",*),"l")
				}
			} Else {
				Set sort=" "_$zconvert(filename,"l")
			}
			Set ^||%FileList(tempnode,1,sort,$increment(index))=$listbuild(f,filename)
cont		Set f = $zsearch("")
		}
	}
	Set ^||%FileList(tempnode)=index
	Set index="",sort=""
	Set type=$order(^||%FileList(tempnode,"")) If type'="" Set sort=$order(^||%FileList(tempnode,type,"")) If sort'="" Set index=$order(^||%FileList(tempnode,type,sort,""),1,data)
	Set QHandle=$LB(tempnode,type,sort,index,stripnull,data)
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FileSetClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; close the collection
	Set tempnode=$listget(QHandle)
	If tempnode'="" Kill ^||%FileList(tempnode)
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FileSetFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Row="",AtEnd=0
	
	Set tempnode=$listget(QHandle,1),type=$listget(QHandle,2),sort=$listget(QHandle,3),index=$listget(QHandle,4),stripnull=$listget(QHandle,5),data=$listget(QHandle,6)
	If (tempnode="")||(sort="")||(index="")||(type="") Set AtEnd=1 Quit $$$OK
	Set filename=$list(data,2),f=$list(data)
	
	; name,type,size,create,modify
	Set size = $$$FileSize(f),created=$$$FileDateCreated(f),modified=$$$FileDateModified(f)
	Set:size<0 size = "" ; don't return size for directories
	Set created=$zdt(created,3,,$l($p(created,".",2)),,,,,,,""),modified=$zdt(modified,3,,$l($p(modified,".",2)),,,,,,,"")
	If $$$isVMS {
		If $piece($piece(f,".",*),";")="DIR" {
			Set nkey=$piece($piece(f,"]",2),";"),nkey=$piece(nkey,".",1,*-1),nf=$piece(f,"]")_"."_nkey_"]"
			Set Row=$listbuild($select(stripnull:$replace(nf,"[000000.","["),1:nf),"D","",created,modified,nkey)
		} Else {
			Set Row=$listbuild($select(stripnull:$replace(f,"[000000.","["),1:f),$select(type=0:"D",..DirectoryExists(f):"D",1:"F"),size,created,modified,filename)
		}
	} Else {
		Set Row=$listbuild(f,$select(type=0:"D",$$$FileDirectoryExists(f):"D",1:"F"),size,created,modified,filename)
	}
	Set index=$order(^||%FileList(tempnode,type,sort,index),1,data)
	If index="" {
		Set sort=$order(^||%FileList(tempnode,type,sort))
		If sort="" {
			Set type=$order(^||%FileList(tempnode,type))
			If type="" {
				Set AtEnd=1
			} Else {
				Set sort=$order(^||%FileList(tempnode,type,"")),index=$order(^||%FileList(tempnode,type,sort,""),1,data)
			}
		} Else {
			Set index=$order(^||%FileList(tempnode,type,sort,""),1,data)
		}
	}
	Set QHandle=$listbuild(tempnode,type,sort,index,stripnull,data)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="LastModifiedGet">
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[
	Set timestamp=$$$FileDateModified(..Name)
	Quit $zdt($S(timestamp<1:$H,1:timestamp),3)
]]></Implementation>
</Method>

<Method name="CopyFromAndSave">
<Description>
Method not implemented as it does not make sense in context of %File interface</Description>
<FormalSpec>source:%AbstractStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$NotImplemented,"%Library.File::CopyFromAndSave")
]]></Implementation>
</Method>

<Method name="TempFilename">
<Description><![CDATA[
Return a temporary filename in the temp directory.
If you specify <var>ext</var> the temp filename will have this extension else it will
default to 'tmp'.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>ext:%String="tmp"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FileNormalizeDirectory($get(^%SYS("TempDir",$namespace),$get($$$SYSTempDir)))_##class(%FileBinaryStream).NewFileName(ext)
]]></Implementation>
</Method>

<Method name="SetUMask">
<Description>
Set umask to the given value and return the previous umask value</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>NewMask:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$zu(47,NewMask)
]]></Implementation>
</Method>

<Method name="Compare">
<Description>
Compare two files and return 1 if they are identical and 0 otherwise</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>file1:%String,file2:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If file1=""||(file2="") Quit 0
	If $zutil(140,1,file1)'=$zutil(140,1,file2) Quit 0
	Set io=$IO
	Open file1:("RUK\RAW\"):0 Else  Quit 0
	Open file2:("RUK\RAW\"):0 Else  Close file1 Quit 0
	Set same=1,exit=0
	Do {
		Try {
			Use file1 Read tmp1#32000 Use file2 Read tmp2#32000
			If tmp1'=tmp2 Set same=0,exit=1
			If $zeof Set exit=1
		} Catch {
			Set exit=1
		}
	} While 'exit
	Use io
	Close file1,file2
	Quit same
]]></Implementation>
</Method>

<Method name="SHA1Hash">
<Description><![CDATA[
Return binary form of SHA1 hash on the <var>file</var> if <var>type</var> is 0 (the default).
If you want the string version then pass in <var>type</var> as 1. Note that if you already
have the file open in this process calling this function will close this file.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>file:%String,type:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If file="" Quit ""
	Set io=$IO
	Close file
	Open file:("RUK\RAW\"):0 Else  Quit ""
	Set exit=0
	Do $System.Encryption.SHA1HashResult()
	Do {
		Try {
			Use file Read tmp#32000
			Do $system.Encryption.SHA1HashInput(tmp)
			If $zeof Set exit=1
		} Catch {
			Set exit=1
		} 
	} While 'exit
	Use io
	Close file
	Set value=$System.Encryption.SHA1HashResult()
	If type=0 Quit value
	Set str="" For i=1:1:$length(value) {
		Set str=str_$translate($justify($zhex($ascii(value,i)),2)," ",0)
	}
	Quit str
]]></Implementation>
</Method>

<Method name="NormalizeFilenameWithSpaces">
<Description><![CDATA[
Normalize filenames containing spaces for the host platform.<br>
<br>
Parameter<br>
pathname : A filename or pathname, specified as a quoted string. You cannot supply
a Windows pathname as a doubly-quoted string.<br>
<br>
Description<br>
The NormalizeFilenameWithSpaces class method handles spaces in pathnames as appropriate
to the host platform. If the pathname contains a space character, pathname handling is
platform-dependent.<br>
<br>
OpenVMS permits space characters in pathnames; NormalizeFilenameWithSpaces
performs no special processing and returns the pathname unchanged.<br>
<br>
UNIX only permits space characters in quoted pathnames; if a pathname containing
spaces NormalizeFilenameWithSpaces returns the pathname enclosed in double quotes ("pathname").
If a pathname does not contain spaces, the method returns it
unchanged.  NormalizeFilenameWithSpaces performs no other pathname validation.<br>
<br>
On Windows systems, NormalizeFilenameWithSpaces strips spaces
from the supplied pathname of an existing file.
If a pathname does not contain spaces, the method returns
it unchanged in all cases. On Windows systems, the method validates pathnames
that contain spaces. If a pathname containing spaces does not exist,
NormalizeFilenameWithSpaces returns the pathname unchanged (with its blank
spaces), with the entire pathname enclosed in double quotes ("pathname").
If a pathname containing spaces exists, the method returns the short form
pathname with spaces removed, such as the following:<br>
<EXAMPLE>
WRITE ##class(%File).NormalizeFilenameWithSpaces("C:\My Test File.txt")
C:\MYTEST~1.TXT
</EXAMPLE>
In this case, the filename is truncated to the first six non-blank characters,
and a tilde (~) and an ordinal number are appending to distinguish similarly
named files. For further details on Windows handling of pathname characters,
specify cmd /? at the Windows command prompt.<br>
<br>
NormalizefilenameWithSpaces is commonly used with the $ZF(-1) and $ZF(-2) functions. 
]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pathname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$ZU(147,pathname)
]]></Implementation>
</Method>
</Class>
</Export>
