ExportDynamic ; ExportDynamic.INT — v7.8 docs+instrumentation restored (Caché 2018.1.7-safe)
 ; ------------------------------------------------------------------------------
 ; PURPOSE
 ;   Export mapped data from a storage global into per-class CSV files.
 ;   This build restores and expands documentation, URLs, and terminal
 ;   instrumentation while keeping the exact logic changes from v7.7:
 ;     - De-dupe header by printed label
 ;     - Rename Key_1..Key_N via parm("KeyName",n)
 ;     - Append UniqueID column (key parts joined by "|")
 ;     - Emit rows strictly in header order
 ;     - Suppress raw whole-node output when piece mappings exist
 ;
 ; VERSION NOTES
 ;   v7.8 (this file) — Adds back doc blocks and URL pointers per section.
 ;   v7.7 — Header/row alignment + key names + UniqueID.
 ;   Target runtime: InterSystems Caché 2018.1.7 (Build 721U) on Windows x86_64.
 ;
 ; ENTRY POINTS
 ;   DO ExportBySchema^ExportDynamic(.parm)      ; main export
 ;   DO ExportAllLevels^ExportDynamic(.parm)     ; diagnostic full traversal dump
 ;
 ; REQUIRED PARAMS (by name in parm())
 ;   parm("Schema")     : schema prefix (e.g., "Referrals")
 ;   parm("GlobalRef")  : root global (supports extended refs), e.g. "^|""NS""|HMOREF" or "^^NS^HMOREF"
 ;   parm("OutputDir")  : directory for CSV output
 ; OPTIONAL PARAMS
 ;   parm("Verbose")    : 0/1 (default 1) — print instrumentation
 ;   parm("MaxDepth")   : recursion cap (default 200)
 ;   parm("MaxNodes")   : node count cap (0 = unlimited)
 ;   parm("OneClass")   : limit export to a single fully qualified class
 ;   parm("KeyName",n)  : real header names for Key_1..Key_n (e.g., "CaseID","ReferralID",...)
 ;
 ; ------------------------------------------------------------------------------
 ; DOCUMENTATION INDEX — Caché 2018.1.7
 ;   Reference index (all) .................................. https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=ALL
 ;   ObjectScript: WRITE / strings / CSV quoting ............ https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_cwrite
 ;   Functions: $GET / $PIECE / $ORDER / $LENGTH ............ https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fget
 ;                                                           https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_fpiece
 ;                                                           https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_forder
 ;   Operators: Indirection @ ................................ https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_op_indirection
 ;   Globals: syntax and extended references ................. https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_using
 ;                                                           https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_extended
 ;   Dynamic SQL / %SQL.Statement ............................ https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GSQL_dynsql
 ;                                                           https://docs.intersystems.com/cache2018.1/csp/documatic/%25CSP.Documatic.cls?CLASSNAME=%25SQL.Statement&LIBRARY=%25SYS
 ;   %Dictionary classes (metadata) .......................... https://docs.intersystems.com/cache2018.1/csp/documatic/%25CSP.Documatic.cls?LIBRARY=%25SYS&PRIVATE=1&SEARCH=%25Dictionary
 ;   Streams: %Stream.FileCharacter .......................... https://docs.intersystems.com/cache2018.1/csp/documatic/%25CSP.Documatic.cls?CLASSNAME=%25Stream.FileCharacter&LIBRARY=%25SYS
 ;   Error handling: $ETRAP / $ZERROR ........................ https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_vetrap
 ;                                                           https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_vzerror
 ;
 ; SAFETY BOUNDARIES (Caché 2018.1.7)
 ;   - No IRIS-only APIs. No ClassDefinition.Properties array usage.
 ;   - No access to Type/Collection/Relationship multidimensional fields.
 ;   - %Dictionary access is limited to safe scalar columns listed inline.
 ;   - Traversal honors "0" subscripts and mixed numeric/string subscripts.
 ;   - Depth and node caps are enforced.
 ; ------------------------------------------------------------------------------
 Q
 ;
 ; ==============================================================================
 ; [ENTRY] ExportBySchema — Orchestrate full export
 ;   Reads schema metadata, traverses mapped globals, and writes per-class CSVs.
 ;   Key steps are instrumented with WRITE messages.
 ;   DOCS: Dynamic SQL / $ETRAP / extended refs
 ;     https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GSQL_dynsql
 ;     https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_vetrap
 ;     https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_extended
 ;
ExportBySchema(parm)
    NEW $ETRAP SET $ETRAP="GOTO ERR^ExportDynamic"
    NEW Schema,GlobalRef,OutputDir,Verbose,MaxDepth,MaxNodes
    NEW CurrentClass,CurrentMapID
    SET Schema=$GET(parm("Schema"))
    SET GlobalRef=$GET(parm("GlobalRef"))
    SET OutputDir=$GET(parm("OutputDir"))
    SET Verbose=+$GET(parm("Verbose"),1)
    SET MaxDepth=+$GET(parm("MaxDepth"),200)
    SET MaxNodes=+$GET(parm("MaxNodes"),0)
    IF Schema="" WRITE !,"*** ERROR: parm(""Schema"") is required" QUIT
    IF GlobalRef="" WRITE !,"*** ERROR: parm(""GlobalRef"") is required" QUIT
    SET OutputDir=$$NormalizeDir(OutputDir)
    DO ##class(%Library.File).CreateDirectoryChain(OutputDir)
    WRITE !,"=== [ENTER] ExportBySchema ==="
    WRITE !,"[PARAM] Schema=",Schema," GlobalRef=",GlobalRef," OutputDir=",OutputDir," Verbose=",Verbose," MaxDepth=",MaxDepth," MaxNodes=",MaxNodes
    NEW rootRef SET rootRef=GlobalRef DO NormalizeGlobalRef(.rootRef,"",1)
    WRITE !,"[NS] rootRef=",rootRef
    ;
    ; Build class set for schema
    NEW classSet DO BuildClassSet(.classSet,Schema,Verbose)
    IF '$DATA(classSet) WRITE !,"*** No classes found for schema: ",Schema QUIT
    WRITE !,"[INFO] Classes=",$$CountParents(.classSet)
    ;
    ; Load storage maps (Subscript and Piece definitions)
    NEW subMap,dataMap DO LoadStorageMeta(.subMap,.dataMap,Schema,Verbose)
    WRITE !,"[INFO] SubMap IDs=",$$CountParents(.subMap)," DataMap IDs=",$$CountParents(.dataMap)
    ;
    ; Build piece spec/order
    NEW pieceSpec,pieceOrd DO BuildPieceMap(.dataMap,.pieceSpec,.pieceOrd,Verbose)
    ;
    ; Determine tables by class + map ID presence
    NEW tableSet DO BuildTableSet(.tableSet,.classSet,.subMap,Verbose,.dataMap)
    WRITE !,"[INFO] TableSet entries=",$$CountParents(.tableSet)
    ;
    ; Property names, FK map, and IdKey names
    NEW propMap,fkMap,idKeyMap DO BuildPropertyMap(.propMap,.fkMap,.idKeyMap,.classSet,Verbose)
    ;
    ; Traverse the data global by subscript patterns from subMap
    NEW tableRows SET tableRows(0)=0
    NEW className SET className=""
    FOR  SET className=$ORDER(tableSet(className)) QUIT:className=""  DO
    . IF $L($GET(parm("OneClass"))),className'=$GET(parm("OneClass")) QUIT
    . WRITE !,"[CLASS] ",className
    . NEW id SET id=""
    . FOR  SET id=$ORDER(tableSet(className,id)) QUIT:id=""  DO
    . . WRITE !,"  [MAPID] ",id
    . . NEW subsSpec SET subsSpec=""
    . . FOR  SET subsSpec=$ORDER(subMap(id,subsSpec)) QUIT:subsSpec=""  DO
    . . . WRITE !,"    [SUBS] ",subsSpec
    . . . NEW base SET base=$$MakeBase(rootRef)
    . . . NEW outcnt SET outcnt=0
    . . . SET CurrentClass=className,CurrentMapID=id
    . . . NEW arity SET arity=$L(subsSpec,",")
    . . . DO ReadGlobal(base,"",0,arity,.tableRows,.dataMap,.pieceSpec,.pieceOrd,.fkMap,.idKeyMap,.propMap,.outcnt,MaxNodes,Verbose,MaxDepth)
    . . . WRITE !,"    [DONE] rows added so far=",+$GET(tableRows(0))
    ;
    ; Write per-class CSVs
    WRITE !,"[WRITE] emitting CSVs to: ",OutputDir
    DO WriteAllCSVs(.tableSet,.pieceSpec,.pieceOrd,.propMap,.fkMap,.idKeyMap,OutputDir,Verbose,.tableRows,.dataMap)
    WRITE !,"=== [DONE] ExportBySchema ==="
    QUIT
 ;
 ; ==============================================================================
 ; [ERROR] ERR — Global error trap (prints $ZERROR)
 ;   DOCS: $ZERROR format
 ;     https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_vzerror
 ;
ERR NEW err SET err=$ZERROR WRITE !,"*** UNEXPECTED ERROR: ",err,! SET $ECODE="" QUIT
 ;
 ; ==============================================================================
 ; Utility helpers
 ;
RSGetData(rs,n) NEW v SET v="" TRY { SET v=rs.%GetData(n) } CATCH ex {} QUIT v
RSGet(rs,name)  NEW v SET v="" TRY { SET v=rs.%Get(name)   } CATCH ex {} QUIT v
Log(v,msg) IF +$GET(v) WRITE !,msg QUIT
 ;
NormalizeDir(dir)
    NEW d SET d=$GET(dir) IF d="" QUIT ""
    NEW l SET l=$L(d)
    IF $EXTRACT(d,l)'="\",$EXTRACT(d,l)'="/" SET d=d_"\\"
    QUIT d
 ;
 ; NormalizeGlobalRef — supports ^^NS^Global and ^Global -> ^|"NS"|Global
 ;   DOCS: extended refs and $ZUTIL(5) for current namespace
 ;     https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=GGBL_extended
 ;     (user asserts $ZUTIL(5) acceptable to get namespace in this environment)
 ;
NormalizeGlobalRef(rootRef,ns,Verbose)
    NEW g SET g=$GET(rootRef) IF g="" QUIT
    IF $EXTRACT(g,1,2)="^^" DO  DO Log(1,"[NS] ^^ form -> "_rootRef) QUIT
    . NEW rest SET rest=$EXTRACT(g,3,$L(g))
    . NEW nsn SET nsn=$PIECE(rest,"^",1)
    . NEW glb SET glb=$PIECE(rest,"^",2,999)
    . SET rootRef="^|"""_nsn_"""|"_$SELECT(glb'="":glb,1:$PIECE(rest,"^",2))
    IF $EXTRACT(g,1)="^",g'?1"^|".E DO
    . NEW curNS SET curNS=$ZUTIL(5)  ; current namespace
    . SET rootRef="^|"""_curNS_"""|"_$EXTRACT(g,2,$L(g))
    DO Log(1,"[NS] normalized="_rootRef)
    QUIT
 ;
 ; ==============================================================================
 ; Dictionary loaders (safe scalar fields only)
 ;
BuildClassSet(classSet,Schema,Verbose)
    DO Log(Verbose,"--- [ENTER] BuildClassSet ---")
    K classSet NEW sc,stmt,rs,sql,prefix SET prefix=Schema_"."
    SET sql="SELECT Name FROM %Dictionary.ClassDefinition WHERE Name LIKE '"_prefix_"%'"
    SET stmt=##class(%SQL.Statement).%New()
    TRY {
        SET sc=stmt.%Prepare(sql) DO Log(Verbose,"[SQL] Prepare="_sc) QUIT:$SYSTEM.Status.IsError(sc)
        SET rs=stmt.%Execute() DO Log(Verbose,"[SQL] Execute ok")
        FOR  QUIT:'rs.%Next()  DO
        . NEW name SET name=$$RSGet(rs,"Name") QUIT:name=""
        . IF $L(name,".")=2 SET classSet(name)=""
    } CATCH ex { DO Log(1,"*** ERROR: BuildClassSet: "_$ZERROR) }
    DO Log(Verbose,"[DICT] classes found="_$$CountParents(.classSet))
    QUIT
 ;
LoadStorageMeta(subMap,dataMap,Schema,Verbose)
    ; Only uses StorageSQLMapSubDefinition(ID,Name) and StorageSQLMapDataDefinition(ID,Name,Piece,Delimiter)
    K subMap,dataMap NEW sc,stmt,rs,sql,cntS,cntP SET cntS=0,cntP=0
    DO Log(Verbose,"--- [ENTER] LoadStorageMeta ---")
    SET sql="SELECT ID,Name FROM %Dictionary.StorageSQLMapSubDefinition WHERE ID LIKE '"_Schema_".%' ORDER BY ID,Name"
    SET stmt=##class(%SQL.Statement).%New()
    SET sc=stmt.%Prepare(sql) DO Log(Verbose,"[SubDef] Prepare="_sc) IF $SYSTEM.Status.IsError(sc) QUIT
    SET rs=stmt.%Execute()
    FOR  QUIT:'rs.%Next()  DO
    . NEW id SET id=$$RSGetData(rs,1) QUIT:id=""
    . NEW name SET name=$$RSGetData(rs,2) QUIT:name=""
    . NEW base SET base=$PIECE(id,"||",1,3)
    . SET subMap(base,name)=id,cntS=cntS+1
    DO Log(Verbose,"[INFO] SubDef rows="_cntS)
    SET sql="SELECT ID,Name,Piece,Delimiter FROM %Dictionary.StorageSQLMapDataDefinition WHERE ID LIKE '"_Schema_".%' ORDER BY ID,Name"
    SET stmt=##class(%SQL.Statement).%New()
    SET sc=stmt.%Prepare(sql) DO Log(Verbose,"[DataDef] Prepare="_sc) IF $SYSTEM.Status.IsError(sc) QUIT
    SET rs=stmt.%Execute()
    FOR  QUIT:'rs.%Next()  DO
    . NEW id SET id=$$RSGetData(rs,1) QUIT:id=""
    . NEW name SET name=$$RSGetData(rs,2) QUIT:name=""
    . NEW piece SET piece=$$RSGetData(rs,3)
    . NEW delim SET delim=$$RSGetData(rs,4)
    . NEW fullID SET fullID=id
    . IF fullID="" QUIT
    . SET id=$PIECE(id,"||",1,3)
    . SET dataMap(id,name)=piece_"|"_delim_"|"_fullID
    . SET cntP=cntP+1
    DO Log(Verbose,"[INFO] DataDef rows="_cntP)
    QUIT
 ;
BuildPieceMap(dataMap,pieceSpec,pieceOrd,Verbose)
    ; Build first and second-level piece selectors and a storage-order index.
    DO Log(Verbose,"--- [ENTER] BuildPieceMap ---")
    K pieceSpec,pieceOrd
    NEW id,name,raw,p,p1,p2
    SET id=""
    FOR  SET id=$ORDER(dataMap(id)) QUIT:id=""  DO
    . SET name=""
    . FOR  SET name=$ORDER(dataMap(id,name)) QUIT:name=""  DO
    . . SET raw=$GET(dataMap(id,name)) QUIT:raw=""
    . . SET p=$PIECE(raw,"|",1)
    . . SET p1=+$PIECE(p,",",1)
    . . SET p2=+$PIECE(p,",",2)
    . . IF 'p1 SET p1=1
    . . SET pieceSpec(id,name,1)=p1
    . . SET pieceSpec(id,name,2)=p2
    . . SET pieceOrd(id,$$ZFill(p1,5)_"_"_name)=""
    DO Log(Verbose,"[DICT] pieceSpec/pieceOrd ready")
    QUIT
 ;
BuildTableSet(tableSet,classSet,subMap,Verbose,dataMap)
    ; A table is present when its class has subscript and data map entries.
    DO Log(Verbose,"--- [ENTER] BuildTableSet ---")
    K tableSet NEW id,cls SET cls=""
    FOR  SET cls=$ORDER(classSet(cls)) QUIT:cls=""  DO
    . SET id=""
    . FOR  SET id=$ORDER(subMap(id)) QUIT:id=""  DO
    . . NEW p SET p=$PIECE(id,"||",1) IF p'=cls QUIT
    . . IF $DATA(dataMap(id)) SET tableSet(cls,id)=id
    DO Log(Verbose,"[DICT] tableSet entries="_$$CountParents(.tableSet))
    QUIT
 ;
BuildPropertyMap(propMap,fkMap,idKeyMap,classSet,Verbose)
    ; Property labels, FK relationships (Properties list), and IdKey SQL name.
    DO Log(Verbose,"--- [ENTER] BuildPropertyMap ---")
    K propMap,fkMap,idKeyMap
    NEW stmt,rs,sc
    ; PropertyDefinition: Parent,Name,SqlFieldName (use SqlFieldName as display label if present)
    SET stmt=##class(%SQL.Statement).%New()
    SET sc=stmt.%Prepare("SELECT Parent,Name,SqlFieldName FROM %Dictionary.PropertyDefinition ORDER BY Parent,Name")
    IF '$SYSTEM.Status.IsError(sc) DO
    . SET rs=stmt.%Execute()
    . FOR  QUIT:'rs.%Next()  DO
    . . NEW par SET par=$$RSGet(rs,"Parent") QUIT:par=""
    . . IF '$DATA(classSet(par)) QUIT
    . . NEW nm SET nm=$$RSGet(rs,"Name")
    . . NEW sfn SET sfn=$$RSGet(rs,"SqlFieldName") IF sfn="" SET sfn=nm
    . . SET propMap(par,nm)=sfn
    ; IndexDefinition: IdKey=1 gives the SQL column name for RowID-like output
    SET stmt=##class(%SQL.Statement).%New()
    SET sc=stmt.%Prepare("SELECT Parent,SqlName,Name,IdKey FROM %Dictionary.IndexDefinition WHERE IdKey=1")
    IF '$SYSTEM.Status.IsError(sc) DO
    . SET rs=stmt.%Execute()
    . FOR  QUIT:'rs.%Next()  DO
    . . NEW par SET par=$$RSGet(rs,"Parent") QUIT:par=""
    . . IF '$DATA(classSet(par)) QUIT
    . . NEW nm SET nm=$$RSGet(rs,"SqlName") IF nm'="" SET idKeyMap(par)=nm
    . . IF $GET(idKeyMap(par))="" NEW nn SET nn=$$RSGet(rs,"Name") IF nn'="" SET idKeyMap(par)=nn
    ; ForeignKeyDefinition: Parent, Properties (CSV), ReferencedClass
    SET stmt=##class(%SQL.Statement).%New()
    SET sc=stmt.%Prepare("SELECT Parent,Properties,ReferencedClass FROM %Dictionary.ForeignKeyDefinition ORDER BY Parent,Properties")
    IF '$SYSTEM.Status.IsError(sc) DO
    . SET rs=stmt.%Execute()
    . FOR  QUIT:'rs.%Next()  DO
    . . NEW par SET par=$$RSGet(rs,"Parent") QUIT:par=""
    . . IF '$DATA(classSet(par)) QUIT
    . . NEW props SET props=$$RSGet(rs,"Properties")
    . . NEW rc SET rc=$$RSGet(rs,"ReferencedClass")
    . . IF +Verbose WRITE !,"[FK] ",par," props=",props," -> ",rc
    . . NEW i FOR i=1:1:$L(props,",") DO
    . . . NEW p SET p=$ZSTRIP($PIECE(props,",",i),"<W") QUIT:p=""
    . . . SET fkMap(par,p)=rc
    DO Log(Verbose,"[DICT] propMap="_$$CountParents(.propMap)_" idKeyMap="_$$CountParents(.idKeyMap)_" fkMap="_$$CountParents(.fkMap))
    QUIT
 ;
 ; ==============================================================================
 ; Traversal and node capture
 ;
ReadGlobal(base,subsList,depth,subsCount,tableRows,dataMap,pieceSpec,pieceOrd,fkMap,idKeyMap,propMap,cnt,maxnodes,Verbose,MaxDepth)
    ; Recursively walk all children from 'base'. At each node, if value exists, record it.
    ; DOCS: $ORDER and indirection patterns
    ;   https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_forder
    ;   https://docs.intersystems.com/cache2018.1/csp/docbook/DocBook.UI.Page.cls?KEY=RCOS_op_indirection
    IF depth>+MaxDepth QUIT
    IF +maxnodes,+(+cnt)>=+maxnodes QUIT
    IF Verbose WRITE !,"[RG] depth=",depth," have=",$S(subsList="":0,1:$L(subsList,","))," subs='",subsList,"' base='",base,"'"
    ; Capture value at current node if any
    NEW val 
    IF subsList="" SET val="" ELSE  SET val=$GET(@(base_")"))
    IF val'="" DO
    . IF Verbose WRITE !,"[RG] VALUE depth=",depth," len=",$L(val)," subs='",subsList,"'"
    . DO RecordNode(subsList,val,.tableRows,.dataMap,.pieceSpec,.pieceOrd,.fkMap,.idKeyMap,.propMap,Verbose)
    . SET cnt=$GET(cnt)+1
    ; Enumerate children
    NEW sep SET sep=$SELECT($EXTRACT(base,$L(base))="(":"",1:",")
    NEW childSub SET childSub=$ORDER(@(base_sep_""""_""""_")"))
    IF Verbose WRITE !,"[RG] first child=",$SELECT(childSub="":"<none>",1:childSub)
    FOR  QUIT:childSub=""  DO
    . NEW qChild,nextBase,nextList
    . SET qChild=$REPLACE(childSub,"""","""""")
    . IF childSub=+childSub SET nextBase=base_sep_childSub,nextList=$S(subsList="":childSub,1:subsList_","_childSub)
    . ELSE  SET nextBase=base_sep_""""_qChild_"""",nextList=$S(subsList="":childSub,1:subsList_","_childSub)
    . DO ReadGlobal(nextBase,nextList,depth+1,subsCount,.tableRows,.dataMap,.pieceSpec,.pieceOrd,.fkMap,.idKeyMap,.propMap,.cnt,maxnodes,Verbose,MaxDepth)
    . IF childSub=+childSub SET childSub=$ORDER(@(base_sep_childSub_")"))
    . ELSE  SET childSub=$ORDER(@(base_sep_""""_qChild_""""_")"))
    QUIT
 ;
RecordNode(subsList,val,tableRows,dataMap,pieceSpec,pieceOrd,fkMap,idKeyMap,propMap,Verbose)
    ; Convert node into a row(label->value) using storage piece map for the current class+map
    NEW className SET className=$GET(CurrentClass) QUIT:className=""
    NEW mapId SET mapId=$GET(CurrentMapID) QUIT:mapId=""
    NEW keyCSV SET keyCSV=""
    NEW i FOR i=1:1:$L(subsList,",") SET keyCSV=keyCSV_$$CSVQ($PIECE(subsList,",",i))_","
    SET keyCSV=$SELECT(keyCSV'="":$EXTRACT(keyCSV,1,$L(keyCSV)-1),1:"")
    NEW node K node SET node(1,"@")=val
    NEW row K row DO BuildRow(.row,className,mapId,.node,.dataMap,.pieceSpec,.pieceOrd,.fkMap,.idKeyMap,.propMap,Verbose)
    IF $DATA(row) DO
    . K tableRows(className,mapId,keyCSV)  ; remove any prior positional payload
    . MERGE tableRows(className,mapId,keyCSV,"@row")=row  ; store label->value map
    . SET tableRows(0)=$GET(tableRows(0))+1
    QUIT
 ;
 ; ==============================================================================
 ; [ROW] BuildRow — populate row(label)=CSVQ(value) in storage order
 ;   - Uses pieceOrd to control order but stores by label so emission can follow header order
 ;   - Adds %SqlRowID value if an IdKey column is known
 ;   - Adds FK ID values when their pieces are mappable
 ;
BuildRow(row,parent,id,node,dataMap,pieceSpec,pieceOrd,fkMap,idKeyMap,propMap,Verbose)
    DO Log(Verbose,"        [ENTER] BuildRow parent="_parent_" id="_id)
    K row NEW head SET head=$GET(node(1,"@")) IF head="" QUIT
    ; %ID -> SqlRowID if mappable
    IF $GET(idKeyMap(parent))'="" DO
    . NEW meta SET meta=$GET(dataMap(id,"%ID")) QUIT:meta=""
    . NEW dspec SET dspec=$PIECE(meta,"|",2)
    . NEW p1 SET p1=+$GET(pieceSpec(id,"%ID",1)) IF 'p1 SET p1=1
    . NEW p2 SET p2=+$GET(pieceSpec(id,"%ID",2))
    . NEW SqlRowID SET SqlRowID=$$BRSplit2(dspec,head,p1,p2)
    . SET row("%SqlRowID")=$$CSVQ(SqlRowID)
    ; mapped storage props in storage order
    NEW ord SET ord=""
    FOR  SET ord=$ORDER(pieceOrd(id,ord)) QUIT:ord=""  DO
    . NEW name SET name=$PIECE(ord,"_",2) IF name="%ID" QUIT
    . NEW p1 SET p1=+$GET(pieceSpec(id,name,1)) IF 'p1 SET p1=1
    . NEW p2 SET p2=+$GET(pieceSpec(id,name,2))
    . NEW dspec SET dspec=$PIECE($GET(dataMap(id,name)),"|",2)
    . NEW v SET v=$$BRSplit2(dspec,head,p1,p2)
    . SET row(name)=$$CSVQ(v)
    ; FK raw IDs only when property is mappable
    NEW fkprop SET fkprop=""
    FOR  SET fkprop=$ORDER(fkMap(parent,fkprop)) QUIT:fkprop=""  DO
    . NEW spec SET spec=$GET(dataMap(id,fkprop)) QUIT:spec=""
    . NEW fp1 SET fp1=+$GET(pieceSpec(id,fkprop,1)) IF 'fp1 SET fp1=1
    . NEW fp2 SET fp2=+$GET(pieceSpec(id,fkprop,2))
    . NEW dspec2 SET dspec2=$PIECE(spec,"|",2)
    . NEW fv SET fv=$$BRSplit2(dspec2,head,fp1,fp2)
    . SET row(fkprop)=$$CSVQ(fv)
    QUIT
 ;
 ; ==============================================================================
 ; [WRITE] Emit per-class CSVs in header order
 ;
WriteAllCSVs(tableSet,pieceSpec,pieceOrd,propMap,fkMap,idKeyMap,OutputDir,Verbose,tableRows,dataMap)
    DO Log(Verbose,"--- [ENTER] WriteAllCSVs ---")
    NEW className SET className=""
    FOR  SET className=$ORDER(tableRows(className)) QUIT:className=""  DO
    . IF $L($GET(parm("OneClass"))),$GET(parm("OneClass"))'=className QUIT
    . NEW filename SET filename=$$FileForClass(OutputDir,className) WRITE !,filename
    . DO WriteOneClassCSV(className,.tableSet,.pieceOrd,.propMap,.fkMap,.idKeyMap,filename,Verbose,.tableRows,.dataMap)
    QUIT
 ;
WriteOneClassCSV(parent,tableSet,pieceOrd,propMap,fkMap,idKeyMap,filename,Verbose,tableRows,dataMap)
    IF parent="" QUIT
    DO Log(Verbose,"[FILE] -> "_filename)
    NEW s SET s=##class(%Stream.FileCharacter).%New()
    NEW sc SET sc=s.LinkToFile(filename) IF $SYSTEM.Status.IsError(sc) DO $SYSTEM.Status.DisplayError(sc) QUIT
    NEW headers DO BuildClassHeaders(.headers,parent,.tableRows,.pieceOrd,.propMap,.fkMap,.idKeyMap,Verbose)
    DO WriteLine(s,$$JoinCSV(.headers))
    NEW id SET id=""
    FOR  SET id=$ORDER(tableRows(parent,id)) QUIT:id=""  DO
    . NEW subs SET subs=""
    . FOR  SET subs=$ORDER(tableRows(parent,id,subs)) QUIT:subs=""  DO
    . . NEW line K line
    . . NEW tokens SET tokens=$$SplitCSVKeys(subs)  ; array(1..n)
    . . NEW keysMax SET keysMax=+$GET(tokens(0),$L(subs,","))
    . . NEW i,lab,val SET i=""
    . . FOR  SET i=$ORDER(headers(i)) QUIT:i=""  DO
    . . . SET lab=$GET(headers(i)) QUIT:lab=""
    . . . ; Keys (rename-aware)
    . . . IF $$IsKeyLabel(lab,.parm) DO  SET line(i)=$$CSVQ($GET(tokens($$KeyIndexForLabel(lab,.parm)))) QUIT
    . . . ; UniqueID
    . . . IF lab="UniqueID" DO  SET line(i)=$$CSVQ($$JoinPipe(.tokens)) QUIT
    . . . ; SqlRowID column
    . . . IF $GET(idKeyMap(parent))'="",lab=$GET(idKeyMap(parent)) DO  SET line(i)=$GET(tableRows(parent,id,subs,"@row","%SqlRowID")) QUIT
    . . . ; Properties by pretty label -> raw name
    . . . NEW raw SET raw=$$RawForPretty(parent,lab,.propMap)
    . . . IF raw'="" SET val=$GET(tableRows(parent,id,subs,"@row",raw)) SET line(i)=$GET(val) QUIT
    . . . ; FK columns were added by raw prop name, so lab equals the raw name
    . . . SET line(i)=$GET(tableRows(parent,id,subs,"@row",lab))
    . . NEW out SET out=$$JoinCSV(.line)
    . . DO WriteLine(s,out)
    SET sc=s.%Save() IF $SYSTEM.Status.IsError(sc) DO $SYSTEM.Status.DisplayError(sc)
    DO s.%Close()
    QUIT
 ;
 ; ==============================================================================
 ; [HEADERS] BuildClassHeaders — Keys (rename-aware), SqlRowID, properties, FKs, + UniqueID
 ;   - De-dupe by printed label (pretty) to avoid duplicates
 ;   - Append UniqueID as last column
 ;   - Key labels can be replaced via parm("KeyName",n)
 ;
BuildClassHeaders(headers,parent,tableRows,pieceOrd,propMap,fkMap,idKeyMap,Verbose)
    K headers NEW i SET i=1
    ; Detect max keys for this parent by examining captured rows
    NEW maxk SET maxk=1
    NEW id SET id=""
    FOR  SET id=$ORDER(tableRows(parent,id)) QUIT:id=""  DO
    . NEW subs SET subs=""
    . FOR  SET subs=$ORDER(tableRows(parent,id,subs)) QUIT:subs=""  DO
    . . NEW n SET n=$S(subs="":1,1:$L(subs,",")) IF n>maxk SET maxk=n
    ; Key labels with rename support
    NEW k FOR k=1:1:maxk DO
    . NEW old SET old="Key_"_k
    . NEW new SET new=$GET(parm("KeyName",k),old)
    . SET headers(i)=new,i=i+1
    ; Optional SqlRowID
    IF $GET(idKeyMap(parent))'="" SET headers(i)=idKeyMap(parent),i=i+1
    ; Properties by storage order, de-dup by printed label
    NEW seen SET seen=""
    NEW id2 SET id2=""
    FOR  SET id2=$ORDER(pieceOrd(id2)) QUIT:id2=""  DO
    . IF $PIECE(id2,"||",1)'=parent QUIT
    . NEW ord SET ord=""
    . FOR  SET ord=$ORDER(pieceOrd(id2,ord)) QUIT:ord=""  DO
    . . NEW name SET name=$PIECE(ord,"_",2) IF name="%ID" QUIT
    . . NEW pretty SET pretty=$GET(propMap(parent,name)) IF pretty="" SET pretty=name
    . . IF $DATA(seen(pretty)) QUIT  SET seen(pretty)=""
    . . SET headers(i)=pretty,i=i+1
    ; FK ID columns only when extractable
    NEW fkprop SET fkprop=""
    FOR  SET fkprop=$ORDER(fkMap(parent,fkprop)) QUIT:fkprop=""  DO
    . NEW hasMap SET hasMap=0
    . NEW chkId SET chkId=""
    . FOR  SET chkId=$ORDER(pieceOrd(chkId)) QUIT:chkId=""  DO
    . . IF $PIECE(chkId,"||",1)'=parent QUIT
    . . IF $GET(dataMap(chkId,fkprop))'="",$GET(pieceSpec(chkId,fkprop,1))'="" SET hasMap=1 QUIT
    . IF hasMap,'$DATA(seen(fkprop)) SET seen(fkprop)="",headers(i)=fkprop,i=i+1
    ; Append UniqueID
    SET headers(i)="UniqueID",i=i+1
    DO Log(Verbose,"[HEAD] cols="_(i-1)_" keys="_(maxk))
    QUIT
 ;
 ; ==============================================================================
 ; CSV utilities
 ;
WriteLine(stream,text) DO stream.Write(text),stream.Write($CHAR(13,10)) QUIT
CSVQ(x) NEW s SET s=$GET(x) IF ((s[",")||(s["""")||(s[$CHAR(10))||(s[$CHAR(13)))) SET s=""""_$REPLACE(s,"""","""""")_"""" QUIT s
JoinCSV(arr) NEW out SET out="",j SET j="" FOR  SET j=$ORDER(arr(j)) QUIT:j=""  SET out=out_$GET(arr(j))_"," QUIT $EXTRACT(out,1,$L(out)-1)
JoinCSVKeys(subs) NEW out SET out="",i FOR i=1:1:$L($GET(subs),",") SET out=out_$$CSVQ($PIECE(subs,",",i))_"," QUIT $SELECT(out'="":$EXTRACT(out,1,$L(out)-1),1:"")
SplitCSVKeys(subs) NEW a K a NEW i FOR i=1:1:$L($GET(subs),",") SET a(i)=$PIECE(subs,",",i) SET a(0)=i QUIT a
JoinPipe(tokens) NEW i,out SET out="" FOR i=1:1:+$GET(tokens(0)) SET out=$SELECT(i=1:$GET(tokens(1)),1:out_"|"_$GET(tokens(i))) QUIT out
 ;
FileForClass(dir,parent) NEW safe SET safe=$ZCONVERT(parent,"O","JSON") QUIT $$NormalizeDir(dir)_safe_".csv"
FileForAll(dir,rootRef) NEW g SET g=rootRef IF (g?1"^|".E){ SET g=$PIECE(g,"|",3,99) } IF g?1"^".E SET g=$EXTRACT(g,2,$L(g)) NEW safe SET safe=$TRANSLATE(g,":/\\()"" ","_____") QUIT $$NormalizeDir(dir)_safe_"__ALL.csv"
 ;
CountParents(arr) NEW n SET n=0 NEW k SET k="" FOR  SET k=$ORDER(arr(k)) QUIT:k=""  SET n=n+1 QUIT n
ZFill(n,w) NEW s SET s=+$GET(n) NEW width SET width=+$GET(w) IF (width<1){ SET width=1} NEW pad SET pad=$EXTRACT($TRANSLATE($JUSTIFY("",width)," ","0")_$GET(s),$L($GET(s))+1,width+$L($GET(s))) QUIT pad
 ;
 ; Header/row helpers
 ;
RawForPretty(parent,pretty,propMap)
    NEW nm SET nm="" NEW hit SET hit=""
    FOR  SET nm=$ORDER(propMap(parent,nm)) QUIT:nm=""  DO  QUIT:$GET(hit)'=""
    . IF $GET(propMap(parent,nm))=pretty SET hit=nm
    QUIT $GET(hit)
 ;
IsKeyLabel(lab,parm)
    NEW k FOR k=1:1:32 DO  QUIT:$GET(%done)
    . IF lab=$GET(parm("KeyName",k),"Key_"_k) SET %done=1
    QUIT +$GET(%done)
 ;
KeyIndexForLabel(lab,parm)
    NEW k FOR k=1:1:32 DO  QUIT:$GET(%done)
    . IF lab=$GET(parm("KeyName",k),"Key_"_k) SET %val=k,%done=1
    QUIT +$GET(%val)
 ;
 ; ==============================================================================
 ; Diagnostics — optional full traversal dump (unchanged)
 ;   Walks every node from a root and prints depth, first 10 subs, and value.
 ;   Useful to confirm delimiter usage and exact node locations before mapping.
 ;
ExportAllLevels(parm)
    NEW $ETRAP SET $ETRAP="GOTO ERR^ExportDynamic"
    NEW GlobalRef,OutputDir,Verbose,MaxDepth,MaxNodes
    SET GlobalRef=$GET(parm("GlobalRef"))
    SET OutputDir=$GET(parm("OutputDir"))
    SET Verbose=+$GET(parm("Verbose"),1)
    SET MaxDepth=+$GET(parm("MaxDepth"),200)
    SET MaxNodes=+$GET(parm("MaxNodes"),0)
    IF GlobalRef="" WRITE !,"*** ERROR: parm(""GlobalRef"") is required" QUIT
    SET OutputDir=$$NormalizeDir(OutputDir)
    DO ##class(%Library.File).CreateDirectoryChain(OutputDir)
    NEW rootRef SET rootRef=GlobalRef DO NormalizeGlobalRef(.rootRef,"",1)
    NEW base SET base=$$MakeBase(rootRef)
    NEW out SET out=$$FileForAll(OutputDir,rootRef)
    NEW s SET s=##class(%Stream.FileCharacter).%New()
    NEW sc SET sc=s.LinkToFile(out) IF $SYSTEM.Status.IsError(sc) DO $SYSTEM.Status.DisplayError(sc) QUIT
    DO WriteLine(s,"Level,Sub1,Sub2,Sub3,Sub4,Sub5,Sub6,Sub7,Sub8,Sub9,Sub10,Value")
    NEW cnt SET cnt=0
    DO DumpAll(.s,base,0,MaxDepth,.cnt,MaxNodes,Verbose)
    SET sc=s.%Save() IF $SYSTEM.Status.IsError(sc) DO $SYSTEM.Status.DisplayError(sc)
    DO s.%Close()
    WRITE !,"=== [DONE] Dumped ",cnt," nodes -> ",out," ==="
    QUIT
 ;
DumpAll(s,base,depth,maxdepth,cnt,maxnodes,Verbose)
    IF depth>maxdepth QUIT
    IF +maxnodes,+(+cnt)>=+maxnodes QUIT
    NEW val SET val=$GET(@(base_")"))
    IF val'="" DO
    . NEW row K row SET row(1)=depth
    . NEW i FOR i=1:1:10 SET row(1+i)=$$CSVQ($$SubAt(base,i))
    . SET row(12)=$$CSVQ(val)
    . DO WriteLine(s,$$JoinCSV(.row))
    . SET cnt=$GET(cnt)+1 IF +cnt#100=0 DO Log(Verbose,"[DUMP] rows="_cnt)
    NEW childSub SET childSub=$ORDER(@(base_","_""""))
    FOR  QUIT:childSub=""  DO
    . NEW nextBase SET nextBase=$S(childSub=+childSub:base_","_childSub,1:base_","""_$$Q(childSub)_"""")
    . DO DumpAll(.s,nextBase,depth+1,maxdepth,.cnt,maxnodes,Verbose)
    . SET childSub=$S(childSub=+childSub:$ORDER(@(base_","_childSub)),1:$ORDER(@(base_","""_$$Q(childSub)_"""")))
    QUIT
 ;
SubAt(base,i) NEW arg SET arg=$PIECE(base,"(",2) NEW n SET n=$L(arg,",") IF i>n QUIT "" NEW p SET p=$PIECE(arg,",",i) IF p=+p QUIT p IF $EXTRACT(p)=$CHAR(34),$EXTRACT(p,$L(p))=$CHAR(34) SET p=$EXTRACT(p,2,$L(p)-1) QUIT $REPLACE(p,"""","""""")
MakeBase(ref) NEW b SET b=$GET(ref) IF b="" QUIT b IF ($FIND(b,"(")=0){ SET b=b_"(" QUIT b } IF $EXTRACT(b,$L(b))=")" SET b=$EXTRACT(b,1,$L(b)-1) QUIT b
Q(x) QUIT $ZCONVERT($ZSTRIP($GET(x),"<>W"),"O","JSON")
 ;
 ; ------------------------------------------------------------------------------
 ; [HELPER] BRGetDelims / BRSplit2 — delimiters and two-stage split
 ;   The StorageSQLMapDataDefinition.Delimiter may define primary and secondary
 ;   separators, e.g., "^" then "*" for horizontal value sets. We split in two
 ;   stages using p1 and p2 indices.
 ;
BRGetDelims(dspec,d1,d2)
    NEW s SET s=$GET(dspec)
    SET d1=$TRANSLATE($PIECE(s,",",1),"""","") IF d1="" SET d1="^"
    SET d2=$TRANSLATE($PIECE(s,",",2),"""","")
    QUIT
 ;
BRSplit2(dspec,head,p1,p2)
    NEW d1,d2,v DO BRGetDelims(dspec,.d1,.d2)
    SET v=$PIECE($GET(head),d1,+$GET(p1))
    IF +$GET(p2) SET v=$PIECE(v,$SELECT(d2'="":d2,1:"*"),p2)
    QUIT v
 ;
 ; ==============================================================================
 ; End of file — v7.8
