<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2018.1.7 (Build 721U)" ts="2025-08-07 12:06:43">
<Class name="%Dictionary.CacheClassname">
<Super>%DataType</Super>
<System>2</System>
<TimeChanged>66186,77919</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Method name="IsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 If $length(%val)>220 Quit $$$ERROR($$$DatatypeValidationError,"%Dictionary.CacheClassname",%val)
 Set v=1
 For i=1:1:$l(%val,".") Set p=$p(%val,".",i),v=$select(i=1:$zname(p),1:$extract(p)'="%"&$zname(p)) Quit:v=0
 Quit $select(v:$$$OK,1:$$$ERROR($$$DatatypeValidationError,"%Dictionary.CacheClassname",%val))
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CacheIdentifier">
<Super>%DataType</Super>
<System>2</System>
<TimeChanged>66186,77919</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Method name="IsValid">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$select($length(%val)'>$$$MAXNAMELENGTH&&(%val'="")||(%val["||")||(%val["."):$$$OK,1:$$$ERROR($$$DatatypeValidationError,"%Dictionary.CacheIdentifier",%val))
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.ClassDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.ClassDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.309538</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="%isDefined">
<Description>
Stores the DEFINED state of each attribute.</Description>
<Type>%CacheString</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="ClassVersion">
<Description>
The class dictionary version to define new classes with, defaults to 23.
If you set it to 25 or more for a new class it will also use ProcedureBlocks as well unless you have manually changed the ProcedureBlock setting.</Description>
<Type>%Integer</Type>
<InitialExpression>23</InitialExpression>
<Transient>1</Transient>
</Property>

<Method name="ClassVersionSet">
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s i%ClassVersion=val
 i val'<25,i%%isDefined("ProcedureBlock")=-1 d ..ProcedureBlockReset()
 q $$$OK
]]></Implementation>
</Method>

<Method name="%IsClsOpen">
<ClassMethod>1</ClassMethod>
<FormalSpec>cls:%String</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
 Set oid=$$$oidCompose(cls,$classname())
 $$$ActiveOidSearch(oid,oref)
 q oref
]]></Implementation>
</Method>

<Property name="Abstract">
<Description>
Specifies that the class cannot have instances; for datatypes, specifies that the class cannot be used as an attribute type.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ClassDefinitionError">
<Description>
Set to true if there is a problem serializing the class so the compiler knows not to compile this.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ClassType">
<Description>
Specifies how this class is to be used.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientDataType">
<Description>
In the case of a datatype class, specifies the type used when exposed via ActiveX or Java. Datatype classes must specify a client datatype. </Description>
<Type>%CacheString</Type>
<InitialExpression>"VARCHAR"</InitialExpression>
</Property>

<Property name="ClientName">
<Description>
This gives an alternate name for the class if it projected, for example, to Java.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompileAfter">
<Description>
Indicates that the class compiler should compile this class after the specified classes.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ConstraintClass">
<Description>
Additional constraint member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DdlAllowed">
<Description>
In the case of a persistent class, indicates whether or not DDL statements can be used to alter or delete the class definition. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="DependsOn">
<Description>
List of classes that this class depends on being runable in order for this class to compile.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deployed">
<Description>
Indicates whether the class has been deployed, that is, disassociated from the source that was used to build it.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Deprecated">
<Description>
True if this class is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Dynamic">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="EmbeddedClass">
<Description>
If specified in a member type class is the name of the class which forms the embedded superclass</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that the class cannot have subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ForeignKeys">
<Description>
ForeignKey</Description>
<Type>%Dictionary.ForeignKeyDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="GeneratedBy">
<Description>
If this class is generated by some other component then this is the name of the item that generated this class</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hidden">
<Description>
Specifies that this class is not typically listed when viewing the contents of the class dictionary.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Import">
<Description>
Supplies a list of class packages to import for this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IncludeCode">
<Description>
Specifies an optional list of Cache include files used when compiling this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IncludeGenerator">
<Description>
Specifies an optional list of Cache include files used when compiling the method generator methods of this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Indices">
<Description>
Index</Description>
<Type>%Dictionary.IndexDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="IndexClass">
<Description>
Additional index member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Inheritance">
<Description>
Define the inheritance order when using multiple inheritance, if a member exists in multiple superclasses which one will take precedence.</Description>
<Type>%CacheString</Type>
<InitialExpression>"left"</InitialExpression>
</Property>

<Property name="Language">
<Description>
The default language used to implement methods for this class.</Description>
<Type>%CacheString</Type>
<InitialExpression>"cache"</InitialExpression>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="LegacyInstanceContext">
<Description>
If true then pass %this as first argument of all instance methods</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="MemberSuper">
<Description>
This is the class to inherit if this class is used as a member class in member inheritance</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.MethodDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ModificationAuxiliary">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ModificationLevel">
<Description>
Deprecated.</Description>
<Type>%Integer</Type>
<InitialExpression>9</InitialExpression>
</Property>

<Property name="Modified">
<Description>
If set to 0 then class is always modified, and so it is always saved.</Description>
<Type>%CacheString</Type>
<InitialExpression>3</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the class.</Description>
<Type>%Dictionary.CacheClassname</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description>
NoContext</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NoExtent">
<Description>
If TRUE will prevent this class from instantiating a persistent extent.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="OdbcType">
<Description>
In the case of a datatype class, specifies the type used when exposed via ODBC or JDBC. Datatype classes must specify an ODBC type. </Description>
<Type>%CacheString</Type>
<InitialExpression>"VARCHAR"</InitialExpression>
</Property>

<Property name="Owner">
<Description>
Specifies the owner of the class and its corresponding table. By default, classes and tables are owned by _SYSTEM.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%Dictionary.ParameterDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that the class uses procedure block for method code.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Projections">
<Description>
Projection</Description>
<Type>%Dictionary.ProjectionDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ProjectionClass">
<Description>
Additional projection member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Properties">
<Description>
Property</Description>
<Type>%Dictionary.PropertyDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PropertyClass">
<Description>
Additional property member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Queries">
<Description>
Query</Description>
<Type>%Dictionary.QueryDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="QueryClass">
<Description>
Additional query member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ServerOnly">
<Description>
ServerOnly</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies the SOAP Binding used by this class when it is used to send and receive mnessages via SOAP.</Description>
<Type>%CacheString</Type>
<InitialExpression>"document"</InitialExpression>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies the encoding used for SOAP messages.</Description>
<Type>%CacheString</Type>
<InitialExpression>"literal"</InitialExpression>
</Property>

<Property name="SqlCategory">
<Description>
In the case of a datatype class, specifies a type to use for calculations in SQL. Datatype classes must specify an SQL Category.</Description>
<Type>%CacheString</Type>
<InitialExpression>"STRING"</InitialExpression>
</Property>

<Property name="SqlRoutinePrefix">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdName">
<Description>
In the case of a persistent class, specifies an altername field name used for the ID column. By default the ID is called ID.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdPrivate">
<Description>
In the case of a persistent class, specifies whether the ID column is projected to ODBC as a hidden field.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlTableName">
<Description>
In the case of a persistent class, specifies the table name used to identify the class in its SQL projection. By default, the SQL table name is the same as the class name.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Storages">
<Description>
Storage</Description>
<Type>%Dictionary.StorageDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="StorageStrategy">
<Description>
Specifies the name of the storage strategy used to control persistence for this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Super">
<Description>
Specifies one or more superclasses for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="System">
<Description>
Specifies that the class is internal to the implementation of Cache. Users should not mark their classes with this keyword.</Description>
<Type>%CacheString</Type>
<ClientName>_System</ClientName>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="TimeChanged">
<Description>
Gives the time the last change was made to the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TimeCreated">
<Description>
Gives the time the class was first created.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Triggers">
<Description>
Trigger</Description>
<Type>%Dictionary.TriggerDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TriggerClass">
<Description>
Additional trigger member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UDLTexts">
<Description>
UDLText</Description>
<Type>%Dictionary.UDLTextDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ViewQuery">
<Description>
Gives the SQL query used for View definition of this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="XDatas">
<Description>
XData</Description>
<Type>%Dictionary.XDataDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="ClientDataTypeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="BIGINT" q $$$OK
 i val="BINARY" q $$$OK
 i val="BINARYSTREAM" q $$$OK
 i val="BOOLEAN" q $$$OK
 i val="CHARACTERSTREAM" q $$$OK
 i val="CURRENCY" q $$$OK
 i val="DATE" q $$$OK
 i val="DOUBLE" q $$$OK
 i val="HANDLE" q $$$OK
 i val="INTEGER" q $$$OK
 i val="LIST" q $$$OK
 i val="LONGVARCHAR" q $$$OK
 i val="NUMERIC" q $$$OK
 i val="STATUS" q $$$OK
 i val="TIME" q $$$OK
 i val="TIMESTAMP" q $$$OK
 i val="VARCHAR" q $$$OK
 i val="FDATE" q $$$OK
 i val="FTIMESTAMP" q $$$OK
 i val="DECIMAL" q $$$OK
 i val="MVDATE" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:ClientDataType",val)
]]></Implementation>
</Method>

<Method name="InheritanceIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="left" q $$$OK
 i val="right" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:Inheritance",val)
]]></Implementation>
</Method>

<Method name="ModifiedIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="0" q $$$OK
 i val="1" q $$$OK
 i val="2" q $$$OK
 i val="3" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:Modified",val)
]]></Implementation>
</Method>

<Method name="OdbcTypeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="BIGINT" q $$$OK
 i val="BIT" q $$$OK
 i val="DATE" q $$$OK
 i val="DOUBLE" q $$$OK
 i val="GUID" q $$$OK
 i val="INTEGER" q $$$OK
 i val="LONGVARBINARY" q $$$OK
 i val="LONGVARCHAR" q $$$OK
 i val="NUMERIC" q $$$OK
 i val="POSIXTIME" q $$$OK
 i val="SMALLINT" q $$$OK
 i val="TIME" q $$$OK
 i val="TIMESTAMP" q $$$OK
 i val="TINYINT" q $$$OK
 i val="VARBINARY" q $$$OK
 i val="VARCHAR" q $$$OK
 i val="RESULTSET" q $$$OK
 i val="STRUCT" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:OdbcType",val)
]]></Implementation>
</Method>

<Method name="ServerOnlyIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="0" q $$$OK
 i val="1" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:ServerOnly",val)
]]></Implementation>
</Method>

<Method name="SoapBindingStyleIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="document" q $$$OK
 i val="rpc" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:SoapBindingStyle",val)
]]></Implementation>
</Method>

<Method name="SoapBodyUseIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="literal" q $$$OK
 i val="encoded" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:SoapBodyUse",val)
]]></Implementation>
</Method>

<Method name="SqlCategoryIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="DATE" q $$$OK
 i val="DOUBLE" q $$$OK
 i val="FMDATE" q $$$OK
 i val="FMTIMESTAMP" q $$$OK
 i val="INTEGER" q $$$OK
 i val="MVDATE" q $$$OK
 i val="NAME" q $$$OK
 i val="NUMERIC" q $$$OK
 i val="POSIXTS" q $$$OK
 i val="STRING" q $$$OK
 i val="TIME" q $$$OK
 i val="TIMESTAMP" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:SqlCategory",val)
]]></Implementation>
</Method>

<Method name="SystemIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="0" q $$$OK
 i val="1" q $$$OK
 i val="2" q $$$OK
 i val="3" q $$$OK
 i val="4" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ClassDefinition:System",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> do RebuildItemIndex^%R({Name},"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String,classversion:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s i%%isDefined("Abstract")=0
 s i%%isDefined("ClassDefinitionError")=0
 s i%%isDefined("ClassType")=0
 s i%%isDefined("ClientDataType")=0
 s i%%isDefined("ClientName")=0
 s i%%isDefined("CompileAfter")=0
 s i%%isDefined("ConstraintClass")=0
 s i%%isDefined("DdlAllowed")=0
 s i%%isDefined("DependsOn")=0
 s i%%isDefined("Deployed")=0
 s i%%isDefined("Deprecated")=0
 s i%%isDefined("Description")=0
 s i%%isDefined("Dynamic")=0
 s i%%isDefined("EmbeddedClass")=0
 s i%%isDefined("Final")=0
 s i%%isDefined("GeneratedBy")=0
 s i%%isDefined("Hidden")=0
 s i%%isDefined("Import")=0
 s i%%isDefined("IncludeCode")=0
 s i%%isDefined("IncludeGenerator")=0
 s i%%isDefined("IndexClass")=0
 s i%%isDefined("Inheritance")=0
 s i%%isDefined("Language")=0
 s i%%isDefined("LegacyInstanceContext")=0
 s i%%isDefined("MemberSuper")=0
 s i%%isDefined("ModificationAuxiliary")=0
 s i%%isDefined("ModificationLevel")=0
 s i%%isDefined("Modified")=0
 s i%%isDefined("Name")=0
 s i%%isDefined("NoContext")=0
 s i%%isDefined("NoExtent")=0
 s i%%isDefined("OdbcType")=0
 s i%%isDefined("Owner")=0
 s i%%isDefined("ProcedureBlock")=-1
 s i%%isDefined("ProjectionClass")=0
 s i%%isDefined("PropertyClass")=0
 s i%%isDefined("QueryClass")=0
 s i%%isDefined("ServerOnly")=0
 s i%%isDefined("SoapBindingStyle")=0
 s i%%isDefined("SoapBodyUse")=0
 s i%%isDefined("SqlCategory")=0
 s i%%isDefined("SqlRoutinePrefix")=0
 s i%%isDefined("SqlRowIdName")=0
 s i%%isDefined("SqlRowIdPrivate")=0
 s i%%isDefined("SqlTableName")=0
 s i%%isDefined("StorageStrategy")=0
 s i%%isDefined("Super")=0
 s i%%isDefined("System")=0
 s i%%isDefined("TimeChanged")=0
 s i%%isDefined("TimeCreated")=0
 s i%%isDefined("TriggerClass")=0
 s i%%isDefined("ViewQuery")=0
 s ..TimeCreated=$zutil(188),..Name=""
 s genby=$$GeneratedBy^%occName() i genby'="" s ..GeneratedBy=genby
 i $g(classversion)'="" s ..ClassVersion=classversion
 i $g(name)="" q $$$OK
 s i%Name=$$$NormalizeClassname(name)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 i (name1="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 QUIT 1
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=id
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||('$$$defClassDefined(name1)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%ClassVersion=$$$CLASSDEFINITIONVERSION
 . s i%Name=name1
 . s i%Abstract=$$$defClassKeyGet(name1,$$$cCLASSabstract),i%%isDefined("Abstract")=$$$defClassKeyDefined(name1,$$$cCLASSabstract)
 . s i%ClassDefinitionError=$$$defClassKeyGet(name1,$$$cCLASSclassdefinitionerror),i%%isDefined("ClassDefinitionError")=$$$defClassKeyDefined(name1,$$$cCLASSclassdefinitionerror)
 . s i%ClassType=$$$defClassKeyGet(name1,$$$cCLASSclasstype),i%%isDefined("ClassType")=$$$defClassKeyDefined(name1,$$$cCLASSclasstype)
 . s i%ClientDataType=$$$defClassKeyGet(name1,$$$cCLASSclientdatatype),i%%isDefined("ClientDataType")=$$$defClassKeyDefined(name1,$$$cCLASSclientdatatype)
 . s i%ClientName=$$$defClassKeyGet(name1,$$$cCLASSclientname),i%%isDefined("ClientName")=$$$defClassKeyDefined(name1,$$$cCLASSclientname)
 . s i%CompileAfter=$$$defClassKeyGet(name1,$$$cCLASScompileafter),i%%isDefined("CompileAfter")=$$$defClassKeyDefined(name1,$$$cCLASScompileafter)
 . s i%ConstraintClass=$$$defClassKeyGet(name1,$$$cCLASSconstraintclass),i%%isDefined("ConstraintClass")=$$$defClassKeyDefined(name1,$$$cCLASSconstraintclass)
 . s i%DdlAllowed=$$$defClassKeyGet(name1,$$$cCLASSddlallowed),i%%isDefined("DdlAllowed")=$$$defClassKeyDefined(name1,$$$cCLASSddlallowed)
 . s i%DependsOn=$$$defClassKeyGet(name1,$$$cCLASSdependson),i%%isDefined("DependsOn")=$$$defClassKeyDefined(name1,$$$cCLASSdependson)
 . s i%Deployed=$$$defClassKeyGet(name1,$$$cCLASSdeployed),i%%isDefined("Deployed")=$$$defClassKeyDefined(name1,$$$cCLASSdeployed)
 . s i%Deprecated=$$$defClassKeyGet(name1,$$$cCLASSdeprecated),i%%isDefined("Deprecated")=$$$defClassKeyDefined(name1,$$$cCLASSdeprecated)
 . s i%Description=$$$defClassKeyGet(name1,$$$cCLASSdescription),i%%isDefined("Description")=$$$defClassKeyDefined(name1,$$$cCLASSdescription)
 . s i%Dynamic=$$$defClassKeyGet(name1,$$$cCLASSdynamic),i%%isDefined("Dynamic")=$$$defClassKeyDefined(name1,$$$cCLASSdynamic)
 . s i%EmbeddedClass=$$$defClassKeyGet(name1,$$$cCLASSembeddedclass),i%%isDefined("EmbeddedClass")=$$$defClassKeyDefined(name1,$$$cCLASSembeddedclass)
 . s i%Final=$$$defClassKeyGet(name1,$$$cCLASSfinal),i%%isDefined("Final")=$$$defClassKeyDefined(name1,$$$cCLASSfinal)
 . s i%GeneratedBy=$$$defClassKeyGet(name1,$$$cCLASSgeneratedby),i%%isDefined("GeneratedBy")=$$$defClassKeyDefined(name1,$$$cCLASSgeneratedby)
 . s i%Hidden=$$$defClassKeyGet(name1,$$$cCLASShidden),i%%isDefined("Hidden")=$$$defClassKeyDefined(name1,$$$cCLASShidden)
 . s i%Import=$$$defClassKeyGet(name1,$$$cCLASSimport),i%%isDefined("Import")=$$$defClassKeyDefined(name1,$$$cCLASSimport)
 . s i%IncludeCode=$$$defClassKeyGet(name1,$$$cCLASSincludecode),i%%isDefined("IncludeCode")=$$$defClassKeyDefined(name1,$$$cCLASSincludecode)
 . s i%IncludeGenerator=$$$defClassKeyGet(name1,$$$cCLASSincludegenerator),i%%isDefined("IncludeGenerator")=$$$defClassKeyDefined(name1,$$$cCLASSincludegenerator)
 . s i%IndexClass=$$$defClassKeyGet(name1,$$$cCLASSindexclass),i%%isDefined("IndexClass")=$$$defClassKeyDefined(name1,$$$cCLASSindexclass)
 . s i%Inheritance=$$$defClassKeyGet(name1,$$$cCLASSinheritance),i%%isDefined("Inheritance")=$$$defClassKeyDefined(name1,$$$cCLASSinheritance)
 . s i%Language=$$$defClassKeyGet(name1,$$$cCLASSlanguage),i%%isDefined("Language")=$$$defClassKeyDefined(name1,$$$cCLASSlanguage)
 . s i%LegacyInstanceContext=$$$defClassKeyGet(name1,$$$cCLASSlegacyinstancecontext),i%%isDefined("LegacyInstanceContext")=$$$defClassKeyDefined(name1,$$$cCLASSlegacyinstancecontext)
 . s i%MemberSuper=$$$defClassKeyGet(name1,$$$cCLASSmembersuper),i%%isDefined("MemberSuper")=$$$defClassKeyDefined(name1,$$$cCLASSmembersuper)
 . s i%ModificationAuxiliary=$$$defClassKeyGet(name1,$$$cCLASSmodificationauxiliary),i%%isDefined("ModificationAuxiliary")=$$$defClassKeyDefined(name1,$$$cCLASSmodificationauxiliary)
 . s i%ModificationLevel=$$$defClassKeyGet(name1,$$$cCLASSmodificationlevel),i%%isDefined("ModificationLevel")=$$$defClassKeyDefined(name1,$$$cCLASSmodificationlevel)
 . s i%Modified=$$$defClassKeyGet(name1,$$$cCLASSmodified),i%%isDefined("Modified")=$$$defClassKeyDefined(name1,$$$cCLASSmodified)
 . s i%Name=$$$defClassKeyGet(name1,$$$cCLASSname),i%%isDefined("Name")=$$$defClassKeyDefined(name1,$$$cCLASSname)
 . s i%NoContext=$$$defClassKeyGet(name1,$$$cCLASSnocontext),i%%isDefined("NoContext")=$$$defClassKeyDefined(name1,$$$cCLASSnocontext)
 . s i%NoExtent=$$$defClassKeyGet(name1,$$$cCLASSnoextent),i%%isDefined("NoExtent")=$$$defClassKeyDefined(name1,$$$cCLASSnoextent)
 . s i%OdbcType=$$$defClassKeyGet(name1,$$$cCLASSodbctype),i%%isDefined("OdbcType")=$$$defClassKeyDefined(name1,$$$cCLASSodbctype)
 . s i%Owner=$$$defClassKeyGet(name1,$$$cCLASSowner),i%%isDefined("Owner")=$$$defClassKeyDefined(name1,$$$cCLASSowner)
 . s i%ProcedureBlock=$$$defClassKeyGet(name1,$$$cCLASSprocedureblock),i%%isDefined("ProcedureBlock")=$$$defClassKeyDefined(name1,$$$cCLASSprocedureblock)
 . s i%ProjectionClass=$$$defClassKeyGet(name1,$$$cCLASSprojectionclass),i%%isDefined("ProjectionClass")=$$$defClassKeyDefined(name1,$$$cCLASSprojectionclass)
 . s i%PropertyClass=$$$defClassKeyGet(name1,$$$cCLASSpropertyclass),i%%isDefined("PropertyClass")=$$$defClassKeyDefined(name1,$$$cCLASSpropertyclass)
 . s i%QueryClass=$$$defClassKeyGet(name1,$$$cCLASSqueryclass),i%%isDefined("QueryClass")=$$$defClassKeyDefined(name1,$$$cCLASSqueryclass)
 . s i%ServerOnly=$$$defClassKeyGet(name1,$$$cCLASSserveronly),i%%isDefined("ServerOnly")=$$$defClassKeyDefined(name1,$$$cCLASSserveronly)
 . s i%SoapBindingStyle=$$$defClassKeyGet(name1,$$$cCLASSsoapbindingstyle),i%%isDefined("SoapBindingStyle")=$$$defClassKeyDefined(name1,$$$cCLASSsoapbindingstyle)
 . s i%SoapBodyUse=$$$defClassKeyGet(name1,$$$cCLASSsoapbodyuse),i%%isDefined("SoapBodyUse")=$$$defClassKeyDefined(name1,$$$cCLASSsoapbodyuse)
 . s i%SqlCategory=$$$defClassKeyGet(name1,$$$cCLASSsqlcategory),i%%isDefined("SqlCategory")=$$$defClassKeyDefined(name1,$$$cCLASSsqlcategory)
 . s i%SqlRoutinePrefix=$$$defClassKeyGet(name1,$$$cCLASSsqlroutineprefix),i%%isDefined("SqlRoutinePrefix")=$$$defClassKeyDefined(name1,$$$cCLASSsqlroutineprefix)
 . s i%SqlRowIdName=$$$defClassKeyGet(name1,$$$cCLASSsqlrowidname),i%%isDefined("SqlRowIdName")=$$$defClassKeyDefined(name1,$$$cCLASSsqlrowidname)
 . s i%SqlRowIdPrivate=$$$defClassKeyGet(name1,$$$cCLASSsqlrowidprivate),i%%isDefined("SqlRowIdPrivate")=$$$defClassKeyDefined(name1,$$$cCLASSsqlrowidprivate)
 . s i%SqlTableName=$$$defClassKeyGet(name1,$$$cCLASSsqltablename),i%%isDefined("SqlTableName")=$$$defClassKeyDefined(name1,$$$cCLASSsqltablename)
 . s i%StorageStrategy=$$$defClassKeyGet(name1,$$$cCLASSstoragestrategy),i%%isDefined("StorageStrategy")=$$$defClassKeyDefined(name1,$$$cCLASSstoragestrategy)
 . s i%Super=$$$defClassKeyGet(name1,$$$cCLASSsuper),i%%isDefined("Super")=$$$defClassKeyDefined(name1,$$$cCLASSsuper)
 . s i%System=$$$defClassKeyGet(name1,$$$cCLASSsystem),i%%isDefined("System")=$$$defClassKeyDefined(name1,$$$cCLASSsystem)
 . s i%TimeChanged=$$$defClassKeyGet(name1,$$$cCLASStimechanged),i%%isDefined("TimeChanged")=$$$defClassKeyDefined(name1,$$$cCLASStimechanged)
 . s i%TimeCreated=$$$defClassKeyGet(name1,$$$cCLASStimecreated),i%%isDefined("TimeCreated")=$$$defClassKeyDefined(name1,$$$cCLASStimecreated)
 . s i%TriggerClass=$$$defClassKeyGet(name1,$$$cCLASStriggerclass),i%%isDefined("TriggerClass")=$$$defClassKeyDefined(name1,$$$cCLASStriggerclass)
 . s i%ViewQuery=$$$defClassKeyGet(name1,$$$cCLASSviewquery),i%%isDefined("ViewQuery")=$$$defClassKeyDefined(name1,$$$cCLASSviewquery)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 s ..TimeChanged=$zutil(188)
 i 'insert DO
 . i i%Name'=id s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=id
 . i '($$$defClassDefined(name1)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defClassSet(name1,"")
 . i 'i%%isDefined("Abstract") { $$$defClassKeyKill(name1,$$$cCLASSabstract) } else { $$$defClassKeySet(name1,$$$cCLASSabstract,i%Abstract) }
 . i 'i%%isDefined("ClassDefinitionError") { $$$defClassKeyKill(name1,$$$cCLASSclassdefinitionerror) } else { $$$defClassKeySet(name1,$$$cCLASSclassdefinitionerror,i%ClassDefinitionError) }
 . i 'i%%isDefined("ClassType") { $$$defClassKeyKill(name1,$$$cCLASSclasstype) } else { $$$defClassKeySet(name1,$$$cCLASSclasstype,i%ClassType) }
 . i 'i%%isDefined("ClientDataType") { $$$defClassKeyKill(name1,$$$cCLASSclientdatatype) } else { $$$defClassKeySet(name1,$$$cCLASSclientdatatype,i%ClientDataType) }
 . i 'i%%isDefined("ClientName") { $$$defClassKeyKill(name1,$$$cCLASSclientname) } else { $$$defClassKeySet(name1,$$$cCLASSclientname,i%ClientName) }
 . i 'i%%isDefined("CompileAfter") { $$$defClassKeyKill(name1,$$$cCLASScompileafter) } else { $$$defClassKeySet(name1,$$$cCLASScompileafter,i%CompileAfter) }
 . i 'i%%isDefined("ConstraintClass") { $$$defClassKeyKill(name1,$$$cCLASSconstraintclass) } else { $$$defClassKeySet(name1,$$$cCLASSconstraintclass,i%ConstraintClass) }
 . i 'i%%isDefined("DdlAllowed") { $$$defClassKeyKill(name1,$$$cCLASSddlallowed) } else { $$$defClassKeySet(name1,$$$cCLASSddlallowed,i%DdlAllowed) }
 . i 'i%%isDefined("DependsOn") { $$$defClassKeyKill(name1,$$$cCLASSdependson) } else { $$$defClassKeySet(name1,$$$cCLASSdependson,i%DependsOn) }
 . i 'i%%isDefined("Deployed") { $$$defClassKeyKill(name1,$$$cCLASSdeployed) } else { $$$defClassKeySet(name1,$$$cCLASSdeployed,i%Deployed) }
 . i 'i%%isDefined("Deprecated") { $$$defClassKeyKill(name1,$$$cCLASSdeprecated) } else { $$$defClassKeySet(name1,$$$cCLASSdeprecated,i%Deprecated) }
 . i 'i%%isDefined("Description") { $$$defClassKeyKill(name1,$$$cCLASSdescription) } else { $$$defClassKeySet(name1,$$$cCLASSdescription,i%Description) }
 . i 'i%%isDefined("Dynamic") { $$$defClassKeyKill(name1,$$$cCLASSdynamic) } else { $$$defClassKeySet(name1,$$$cCLASSdynamic,i%Dynamic) }
 . i 'i%%isDefined("EmbeddedClass") { $$$defClassKeyKill(name1,$$$cCLASSembeddedclass) } else { $$$defClassKeySet(name1,$$$cCLASSembeddedclass,i%EmbeddedClass) }
 . i 'i%%isDefined("Final") { $$$defClassKeyKill(name1,$$$cCLASSfinal) } else { $$$defClassKeySet(name1,$$$cCLASSfinal,i%Final) }
 . i 'i%%isDefined("GeneratedBy") { $$$defClassKeyKill(name1,$$$cCLASSgeneratedby) } else { $$$defClassKeySet(name1,$$$cCLASSgeneratedby,i%GeneratedBy) }
 . i 'i%%isDefined("Hidden") { $$$defClassKeyKill(name1,$$$cCLASShidden) } else { $$$defClassKeySet(name1,$$$cCLASShidden,i%Hidden) }
 . i 'i%%isDefined("Import") { $$$defClassKeyKill(name1,$$$cCLASSimport) } else { $$$defClassKeySet(name1,$$$cCLASSimport,i%Import) }
 . i 'i%%isDefined("IncludeCode") { $$$defClassKeyKill(name1,$$$cCLASSincludecode) } else { $$$defClassKeySet(name1,$$$cCLASSincludecode,i%IncludeCode) }
 . i 'i%%isDefined("IncludeGenerator") { $$$defClassKeyKill(name1,$$$cCLASSincludegenerator) } else { $$$defClassKeySet(name1,$$$cCLASSincludegenerator,i%IncludeGenerator) }
 . i 'i%%isDefined("IndexClass") { $$$defClassKeyKill(name1,$$$cCLASSindexclass) } else { $$$defClassKeySet(name1,$$$cCLASSindexclass,i%IndexClass) }
 . i 'i%%isDefined("Inheritance") { $$$defClassKeyKill(name1,$$$cCLASSinheritance) } else { $$$defClassKeySet(name1,$$$cCLASSinheritance,i%Inheritance) }
 . i 'i%%isDefined("Language") { $$$defClassKeyKill(name1,$$$cCLASSlanguage) } else { $$$defClassKeySet(name1,$$$cCLASSlanguage,i%Language) }
 . i 'i%%isDefined("LegacyInstanceContext") { $$$defClassKeyKill(name1,$$$cCLASSlegacyinstancecontext) } else { $$$defClassKeySet(name1,$$$cCLASSlegacyinstancecontext,i%LegacyInstanceContext) }
 . i 'i%%isDefined("MemberSuper") { $$$defClassKeyKill(name1,$$$cCLASSmembersuper) } else { $$$defClassKeySet(name1,$$$cCLASSmembersuper,i%MemberSuper) }
 . i 'i%%isDefined("ModificationAuxiliary") { $$$defClassKeyKill(name1,$$$cCLASSmodificationauxiliary) } else { $$$defClassKeySet(name1,$$$cCLASSmodificationauxiliary,i%ModificationAuxiliary) }
 . i 'i%%isDefined("ModificationLevel") { $$$defClassKeyKill(name1,$$$cCLASSmodificationlevel) } else { $$$defClassKeySet(name1,$$$cCLASSmodificationlevel,i%ModificationLevel) }
 . i 'i%%isDefined("Modified") { $$$defClassKeyKill(name1,$$$cCLASSmodified) } else { $$$defClassKeySet(name1,$$$cCLASSmodified,i%Modified) }
 . i 'i%%isDefined("Name") { $$$defClassKeyKill(name1,$$$cCLASSname) } else { $$$defClassKeySet(name1,$$$cCLASSname,i%Name) }
 . i 'i%%isDefined("NoContext") { $$$defClassKeyKill(name1,$$$cCLASSnocontext) } else { $$$defClassKeySet(name1,$$$cCLASSnocontext,i%NoContext) }
 . i 'i%%isDefined("NoExtent") { $$$defClassKeyKill(name1,$$$cCLASSnoextent) } else { $$$defClassKeySet(name1,$$$cCLASSnoextent,i%NoExtent) }
 . i 'i%%isDefined("OdbcType") { $$$defClassKeyKill(name1,$$$cCLASSodbctype) } else { $$$defClassKeySet(name1,$$$cCLASSodbctype,i%OdbcType) }
 . i 'i%%isDefined("Owner") { $$$defClassKeyKill(name1,$$$cCLASSowner) } else { $$$defClassKeySet(name1,$$$cCLASSowner,i%Owner) }
 . i 'i%%isDefined("ProcedureBlock") { $$$defClassKeyKill(name1,$$$cCLASSprocedureblock) } else { $$$defClassKeySet(name1,$$$cCLASSprocedureblock,i%ProcedureBlock) }
 . i 'i%%isDefined("ProjectionClass") { $$$defClassKeyKill(name1,$$$cCLASSprojectionclass) } else { $$$defClassKeySet(name1,$$$cCLASSprojectionclass,i%ProjectionClass) }
 . i 'i%%isDefined("PropertyClass") { $$$defClassKeyKill(name1,$$$cCLASSpropertyclass) } else { $$$defClassKeySet(name1,$$$cCLASSpropertyclass,i%PropertyClass) }
 . i 'i%%isDefined("QueryClass") { $$$defClassKeyKill(name1,$$$cCLASSqueryclass) } else { $$$defClassKeySet(name1,$$$cCLASSqueryclass,i%QueryClass) }
 . i 'i%%isDefined("ServerOnly") { $$$defClassKeyKill(name1,$$$cCLASSserveronly) } else { $$$defClassKeySet(name1,$$$cCLASSserveronly,i%ServerOnly) }
 . i 'i%%isDefined("SoapBindingStyle") { $$$defClassKeyKill(name1,$$$cCLASSsoapbindingstyle) } else { $$$defClassKeySet(name1,$$$cCLASSsoapbindingstyle,i%SoapBindingStyle) }
 . i 'i%%isDefined("SoapBodyUse") { $$$defClassKeyKill(name1,$$$cCLASSsoapbodyuse) } else { $$$defClassKeySet(name1,$$$cCLASSsoapbodyuse,i%SoapBodyUse) }
 . i 'i%%isDefined("SqlCategory") { $$$defClassKeyKill(name1,$$$cCLASSsqlcategory) } else { $$$defClassKeySet(name1,$$$cCLASSsqlcategory,i%SqlCategory) }
 . i 'i%%isDefined("SqlRoutinePrefix") { $$$defClassKeyKill(name1,$$$cCLASSsqlroutineprefix) } else { $$$defClassKeySet(name1,$$$cCLASSsqlroutineprefix,i%SqlRoutinePrefix) }
 . i 'i%%isDefined("SqlRowIdName") { $$$defClassKeyKill(name1,$$$cCLASSsqlrowidname) } else { $$$defClassKeySet(name1,$$$cCLASSsqlrowidname,i%SqlRowIdName) }
 . i 'i%%isDefined("SqlRowIdPrivate") { $$$defClassKeyKill(name1,$$$cCLASSsqlrowidprivate) } else { $$$defClassKeySet(name1,$$$cCLASSsqlrowidprivate,i%SqlRowIdPrivate) }
 . i 'i%%isDefined("SqlTableName") { $$$defClassKeyKill(name1,$$$cCLASSsqltablename) } else { $$$defClassKeySet(name1,$$$cCLASSsqltablename,i%SqlTableName) }
 . i 'i%%isDefined("StorageStrategy") { $$$defClassKeyKill(name1,$$$cCLASSstoragestrategy) } else { $$$defClassKeySet(name1,$$$cCLASSstoragestrategy,i%StorageStrategy) }
 . i 'i%%isDefined("Super") { $$$defClassKeyKill(name1,$$$cCLASSsuper) } else { $$$defClassKeySet(name1,$$$cCLASSsuper,i%Super) }
 . i 'i%%isDefined("System") { $$$defClassKeyKill(name1,$$$cCLASSsystem) } else { $$$defClassKeySet(name1,$$$cCLASSsystem,i%System) }
 . i 'i%%isDefined("TimeChanged") { $$$defClassKeyKill(name1,$$$cCLASStimechanged) } else { $$$defClassKeySet(name1,$$$cCLASStimechanged,i%TimeChanged) }
 . i 'i%%isDefined("TimeCreated") { $$$defClassKeyKill(name1,$$$cCLASStimecreated) } else { $$$defClassKeySet(name1,$$$cCLASStimecreated,i%TimeCreated) }
 . i 'i%%isDefined("TriggerClass") { $$$defClassKeyKill(name1,$$$cCLASStriggerclass) } else { $$$defClassKeySet(name1,$$$cCLASStriggerclass,i%TriggerClass) }
 . i 'i%%isDefined("ViewQuery") { $$$defClassKeyKill(name1,$$$cCLASSviewquery) } else { $$$defClassKeySet(name1,$$$cCLASSviewquery,i%ViewQuery) }
 i insert DO
 . i 'idassigned s id=$$$NormalizeClassname(i%Name) s sc=$$IsClassnameConflict^%occName(id) q:$$$ISERR(sc)  i 1
 . e  i i%Name'=id s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=id
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defClassDefined(name1) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.ClassDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defClassSet(name1,"")
 . i 'i%%isDefined("Abstract") { $$$defClassKeyKill(name1,$$$cCLASSabstract) } else { $$$defClassKeySet(name1,$$$cCLASSabstract,i%Abstract) }
 . i 'i%%isDefined("ClassDefinitionError") { $$$defClassKeyKill(name1,$$$cCLASSclassdefinitionerror) } else { $$$defClassKeySet(name1,$$$cCLASSclassdefinitionerror,i%ClassDefinitionError) }
 . i 'i%%isDefined("ClassType") { $$$defClassKeyKill(name1,$$$cCLASSclasstype) } else { $$$defClassKeySet(name1,$$$cCLASSclasstype,i%ClassType) }
 . i 'i%%isDefined("ClientDataType") { $$$defClassKeyKill(name1,$$$cCLASSclientdatatype) } else { $$$defClassKeySet(name1,$$$cCLASSclientdatatype,i%ClientDataType) }
 . i 'i%%isDefined("ClientName") { $$$defClassKeyKill(name1,$$$cCLASSclientname) } else { $$$defClassKeySet(name1,$$$cCLASSclientname,i%ClientName) }
 . i 'i%%isDefined("CompileAfter") { $$$defClassKeyKill(name1,$$$cCLASScompileafter) } else { $$$defClassKeySet(name1,$$$cCLASScompileafter,i%CompileAfter) }
 . i 'i%%isDefined("ConstraintClass") { $$$defClassKeyKill(name1,$$$cCLASSconstraintclass) } else { $$$defClassKeySet(name1,$$$cCLASSconstraintclass,i%ConstraintClass) }
 . i 'i%%isDefined("DdlAllowed") { $$$defClassKeyKill(name1,$$$cCLASSddlallowed) } else { $$$defClassKeySet(name1,$$$cCLASSddlallowed,i%DdlAllowed) }
 . i 'i%%isDefined("DependsOn") { $$$defClassKeyKill(name1,$$$cCLASSdependson) } else { $$$defClassKeySet(name1,$$$cCLASSdependson,i%DependsOn) }
 . i 'i%%isDefined("Deployed") { $$$defClassKeyKill(name1,$$$cCLASSdeployed) } else { $$$defClassKeySet(name1,$$$cCLASSdeployed,i%Deployed) }
 . i 'i%%isDefined("Deprecated") { $$$defClassKeyKill(name1,$$$cCLASSdeprecated) } else { $$$defClassKeySet(name1,$$$cCLASSdeprecated,i%Deprecated) }
 . i 'i%%isDefined("Description") { $$$defClassKeyKill(name1,$$$cCLASSdescription) } else { $$$defClassKeySet(name1,$$$cCLASSdescription,i%Description) }
 . i 'i%%isDefined("Dynamic") { $$$defClassKeyKill(name1,$$$cCLASSdynamic) } else { $$$defClassKeySet(name1,$$$cCLASSdynamic,i%Dynamic) }
 . i 'i%%isDefined("EmbeddedClass") { $$$defClassKeyKill(name1,$$$cCLASSembeddedclass) } else { $$$defClassKeySet(name1,$$$cCLASSembeddedclass,i%EmbeddedClass) }
 . i 'i%%isDefined("Final") { $$$defClassKeyKill(name1,$$$cCLASSfinal) } else { $$$defClassKeySet(name1,$$$cCLASSfinal,i%Final) }
 . i 'i%%isDefined("GeneratedBy") { $$$defClassKeyKill(name1,$$$cCLASSgeneratedby) } else { $$$defClassKeySet(name1,$$$cCLASSgeneratedby,i%GeneratedBy) }
 . i 'i%%isDefined("Hidden") { $$$defClassKeyKill(name1,$$$cCLASShidden) } else { $$$defClassKeySet(name1,$$$cCLASShidden,i%Hidden) }
 . i 'i%%isDefined("Import") { $$$defClassKeyKill(name1,$$$cCLASSimport) } else { $$$defClassKeySet(name1,$$$cCLASSimport,i%Import) }
 . i 'i%%isDefined("IncludeCode") { $$$defClassKeyKill(name1,$$$cCLASSincludecode) } else { $$$defClassKeySet(name1,$$$cCLASSincludecode,i%IncludeCode) }
 . i 'i%%isDefined("IncludeGenerator") { $$$defClassKeyKill(name1,$$$cCLASSincludegenerator) } else { $$$defClassKeySet(name1,$$$cCLASSincludegenerator,i%IncludeGenerator) }
 . i 'i%%isDefined("IndexClass") { $$$defClassKeyKill(name1,$$$cCLASSindexclass) } else { $$$defClassKeySet(name1,$$$cCLASSindexclass,i%IndexClass) }
 . i 'i%%isDefined("Inheritance") { $$$defClassKeyKill(name1,$$$cCLASSinheritance) } else { $$$defClassKeySet(name1,$$$cCLASSinheritance,i%Inheritance) }
 . i 'i%%isDefined("Language") { $$$defClassKeyKill(name1,$$$cCLASSlanguage) } else { $$$defClassKeySet(name1,$$$cCLASSlanguage,i%Language) }
 . i 'i%%isDefined("LegacyInstanceContext") { $$$defClassKeyKill(name1,$$$cCLASSlegacyinstancecontext) } else { $$$defClassKeySet(name1,$$$cCLASSlegacyinstancecontext,i%LegacyInstanceContext) }
 . i 'i%%isDefined("MemberSuper") { $$$defClassKeyKill(name1,$$$cCLASSmembersuper) } else { $$$defClassKeySet(name1,$$$cCLASSmembersuper,i%MemberSuper) }
 . i 'i%%isDefined("ModificationAuxiliary") { $$$defClassKeyKill(name1,$$$cCLASSmodificationauxiliary) } else { $$$defClassKeySet(name1,$$$cCLASSmodificationauxiliary,i%ModificationAuxiliary) }
 . i 'i%%isDefined("ModificationLevel") { $$$defClassKeyKill(name1,$$$cCLASSmodificationlevel) } else { $$$defClassKeySet(name1,$$$cCLASSmodificationlevel,i%ModificationLevel) }
 . i 'i%%isDefined("Modified") { $$$defClassKeyKill(name1,$$$cCLASSmodified) } else { $$$defClassKeySet(name1,$$$cCLASSmodified,i%Modified) }
 . i 'i%%isDefined("Name") { $$$defClassKeyKill(name1,$$$cCLASSname) } else { $$$defClassKeySet(name1,$$$cCLASSname,i%Name) }
 . i 'i%%isDefined("NoContext") { $$$defClassKeyKill(name1,$$$cCLASSnocontext) } else { $$$defClassKeySet(name1,$$$cCLASSnocontext,i%NoContext) }
 . i 'i%%isDefined("NoExtent") { $$$defClassKeyKill(name1,$$$cCLASSnoextent) } else { $$$defClassKeySet(name1,$$$cCLASSnoextent,i%NoExtent) }
 . i 'i%%isDefined("OdbcType") { $$$defClassKeyKill(name1,$$$cCLASSodbctype) } else { $$$defClassKeySet(name1,$$$cCLASSodbctype,i%OdbcType) }
 . i 'i%%isDefined("Owner") { $$$defClassKeyKill(name1,$$$cCLASSowner) } else { $$$defClassKeySet(name1,$$$cCLASSowner,i%Owner) }
 . i 'i%%isDefined("ProcedureBlock") { $$$defClassKeyKill(name1,$$$cCLASSprocedureblock) } else { $$$defClassKeySet(name1,$$$cCLASSprocedureblock,i%ProcedureBlock) }
 . i 'i%%isDefined("ProjectionClass") { $$$defClassKeyKill(name1,$$$cCLASSprojectionclass) } else { $$$defClassKeySet(name1,$$$cCLASSprojectionclass,i%ProjectionClass) }
 . i 'i%%isDefined("PropertyClass") { $$$defClassKeyKill(name1,$$$cCLASSpropertyclass) } else { $$$defClassKeySet(name1,$$$cCLASSpropertyclass,i%PropertyClass) }
 . i 'i%%isDefined("QueryClass") { $$$defClassKeyKill(name1,$$$cCLASSqueryclass) } else { $$$defClassKeySet(name1,$$$cCLASSqueryclass,i%QueryClass) }
 . i 'i%%isDefined("ServerOnly") { $$$defClassKeyKill(name1,$$$cCLASSserveronly) } else { $$$defClassKeySet(name1,$$$cCLASSserveronly,i%ServerOnly) }
 . i 'i%%isDefined("SoapBindingStyle") { $$$defClassKeyKill(name1,$$$cCLASSsoapbindingstyle) } else { $$$defClassKeySet(name1,$$$cCLASSsoapbindingstyle,i%SoapBindingStyle) }
 . i 'i%%isDefined("SoapBodyUse") { $$$defClassKeyKill(name1,$$$cCLASSsoapbodyuse) } else { $$$defClassKeySet(name1,$$$cCLASSsoapbodyuse,i%SoapBodyUse) }
 . i 'i%%isDefined("SqlCategory") { $$$defClassKeyKill(name1,$$$cCLASSsqlcategory) } else { $$$defClassKeySet(name1,$$$cCLASSsqlcategory,i%SqlCategory) }
 . i 'i%%isDefined("SqlRoutinePrefix") { $$$defClassKeyKill(name1,$$$cCLASSsqlroutineprefix) } else { $$$defClassKeySet(name1,$$$cCLASSsqlroutineprefix,i%SqlRoutinePrefix) }
 . i 'i%%isDefined("SqlRowIdName") { $$$defClassKeyKill(name1,$$$cCLASSsqlrowidname) } else { $$$defClassKeySet(name1,$$$cCLASSsqlrowidname,i%SqlRowIdName) }
 . i 'i%%isDefined("SqlRowIdPrivate") { $$$defClassKeyKill(name1,$$$cCLASSsqlrowidprivate) } else { $$$defClassKeySet(name1,$$$cCLASSsqlrowidprivate,i%SqlRowIdPrivate) }
 . i 'i%%isDefined("SqlTableName") { $$$defClassKeyKill(name1,$$$cCLASSsqltablename) } else { $$$defClassKeySet(name1,$$$cCLASSsqltablename,i%SqlTableName) }
 . i 'i%%isDefined("StorageStrategy") { $$$defClassKeyKill(name1,$$$cCLASSstoragestrategy) } else { $$$defClassKeySet(name1,$$$cCLASSstoragestrategy,i%StorageStrategy) }
 . i 'i%%isDefined("Super") { $$$defClassKeyKill(name1,$$$cCLASSsuper) } else { $$$defClassKeySet(name1,$$$cCLASSsuper,i%Super) }
 . i 'i%%isDefined("System") { $$$defClassKeyKill(name1,$$$cCLASSsystem) } else { $$$defClassKeySet(name1,$$$cCLASSsystem,i%System) }
 . i 'i%%isDefined("TimeChanged") { $$$defClassKeyKill(name1,$$$cCLASStimechanged) } else { $$$defClassKeySet(name1,$$$cCLASStimechanged,i%TimeChanged) }
 . i 'i%%isDefined("TimeCreated") { $$$defClassKeyKill(name1,$$$cCLASStimecreated) } else { $$$defClassKeySet(name1,$$$cCLASStimecreated,i%TimeCreated) }
 . i 'i%%isDefined("TriggerClass") { $$$defClassKeyKill(name1,$$$cCLASStriggerclass) } else { $$$defClassKeySet(name1,$$$cCLASStriggerclass,i%TriggerClass) }
 . i 'i%%isDefined("ViewQuery") { $$$defClassKeyKill(name1,$$$cCLASSviewquery) } else { $$$defClassKeySet(name1,$$$cCLASSviewquery,i%ViewQuery) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 $$$defClassVersionSet(name1,i%ClassVersion)
 i ..GeneratedBy'="" d GeneratedBySave^%occName(..Name,..GeneratedBy)
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Quit $$Delete^%apiOBJ(id,"-d "_$select(concurrency:"l",1:"-l"),,$$$GetddlNo30)
]]></Implementation>
</Method>

<Method name="AbstractSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Abstract=value,i%%isDefined("Abstract")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="AbstractReset">
<Implementation><![CDATA[ set i%Abstract=0 set i%%isDefined("Abstract")=0 quit
]]></Implementation>
</Method>

<Method name="AbstractIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Abstract")
]]></Implementation>
</Method>

<Method name="ClassDefinitionErrorSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ClassDefinitionError=value,i%%isDefined("ClassDefinitionError")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ClassDefinitionErrorReset">
<Implementation><![CDATA[ set i%ClassDefinitionError=0 set i%%isDefined("ClassDefinitionError")=0 quit
]]></Implementation>
</Method>

<Method name="ClassDefinitionErrorIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ClassDefinitionError")
]]></Implementation>
</Method>

<Method name="ClassTypeSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ClassType=value,i%%isDefined("ClassType")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ClassTypeReset">
<Implementation><![CDATA[ set i%ClassType="" set i%%isDefined("ClassType")=0 quit
]]></Implementation>
</Method>

<Method name="ClassTypeIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ClassType")
]]></Implementation>
</Method>

<Method name="ClientDataTypeSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ClientDataType=value,i%%isDefined("ClientDataType")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientDataTypeReset">
<Implementation><![CDATA[ set i%ClientDataType="VARCHAR" set i%%isDefined("ClientDataType")=0 quit
]]></Implementation>
</Method>

<Method name="ClientDataTypeIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ClientDataType")
]]></Implementation>
</Method>

<Method name="ClientNameSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ClientName=value,i%%isDefined("ClientName")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientNameReset">
<Implementation><![CDATA[ set i%ClientName="" set i%%isDefined("ClientName")=0 quit
]]></Implementation>
</Method>

<Method name="ClientNameIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ClientName")
]]></Implementation>
</Method>

<Method name="CompileAfterSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%CompileAfter=value,i%%isDefined("CompileAfter")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="CompileAfterReset">
<Implementation><![CDATA[ set i%CompileAfter="" set i%%isDefined("CompileAfter")=0 quit
]]></Implementation>
</Method>

<Method name="CompileAfterIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("CompileAfter")
]]></Implementation>
</Method>

<Method name="ConstraintClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ConstraintClass=value,i%%isDefined("ConstraintClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ConstraintClassReset">
<Implementation><![CDATA[ set i%ConstraintClass="" set i%%isDefined("ConstraintClass")=0 quit
]]></Implementation>
</Method>

<Method name="ConstraintClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ConstraintClass")
]]></Implementation>
</Method>

<Method name="DdlAllowedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%DdlAllowed=value,i%%isDefined("DdlAllowed")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DdlAllowedReset">
<Implementation><![CDATA[ set i%DdlAllowed=0 set i%%isDefined("DdlAllowed")=0 quit
]]></Implementation>
</Method>

<Method name="DdlAllowedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("DdlAllowed")
]]></Implementation>
</Method>

<Method name="DependsOnSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%DependsOn=value,i%%isDefined("DependsOn")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DependsOnReset">
<Implementation><![CDATA[ set i%DependsOn="" set i%%isDefined("DependsOn")=0 quit
]]></Implementation>
</Method>

<Method name="DependsOnIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("DependsOn")
]]></Implementation>
</Method>

<Method name="DeployedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Deployed=value,i%%isDefined("Deployed")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DeployedReset">
<Implementation><![CDATA[ set i%Deployed=0 set i%%isDefined("Deployed")=0 quit
]]></Implementation>
</Method>

<Method name="DeployedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Deployed")
]]></Implementation>
</Method>

<Method name="DeprecatedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Deprecated=value,i%%isDefined("Deprecated")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DeprecatedReset">
<Implementation><![CDATA[ set i%Deprecated=0 set i%%isDefined("Deprecated")=0 quit
]]></Implementation>
</Method>

<Method name="DeprecatedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Deprecated")
]]></Implementation>
</Method>

<Method name="DescriptionSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Description=value,i%%isDefined("Description")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DescriptionReset">
<Implementation><![CDATA[ set i%Description="" set i%%isDefined("Description")=0 quit
]]></Implementation>
</Method>

<Method name="DescriptionIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Description")
]]></Implementation>
</Method>

<Method name="DynamicSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Dynamic=value,i%%isDefined("Dynamic")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="DynamicReset">
<Implementation><![CDATA[ set i%Dynamic=0 set i%%isDefined("Dynamic")=0 quit
]]></Implementation>
</Method>

<Method name="DynamicIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Dynamic")
]]></Implementation>
</Method>

<Method name="EmbeddedClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%EmbeddedClass=value,i%%isDefined("EmbeddedClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="EmbeddedClassReset">
<Implementation><![CDATA[ set i%EmbeddedClass="" set i%%isDefined("EmbeddedClass")=0 quit
]]></Implementation>
</Method>

<Method name="EmbeddedClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("EmbeddedClass")
]]></Implementation>
</Method>

<Method name="FinalSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Final=value,i%%isDefined("Final")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="FinalReset">
<Implementation><![CDATA[ set i%Final=0 set i%%isDefined("Final")=0 quit
]]></Implementation>
</Method>

<Method name="FinalIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Final")
]]></Implementation>
</Method>

<Method name="GeneratedBySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%GeneratedBy=value,i%%isDefined("GeneratedBy")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="GeneratedByReset">
<Implementation><![CDATA[ set i%GeneratedBy="" set i%%isDefined("GeneratedBy")=0 quit
]]></Implementation>
</Method>

<Method name="GeneratedByIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("GeneratedBy")
]]></Implementation>
</Method>

<Method name="HiddenSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Hidden=value,i%%isDefined("Hidden")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="HiddenReset">
<Implementation><![CDATA[ set i%Hidden=0 set i%%isDefined("Hidden")=0 quit
]]></Implementation>
</Method>

<Method name="HiddenIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Hidden")
]]></Implementation>
</Method>

<Method name="ImportSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Import=value,i%%isDefined("Import")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ImportReset">
<Implementation><![CDATA[ set i%Import="" set i%%isDefined("Import")=0 quit
]]></Implementation>
</Method>

<Method name="ImportIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Import")
]]></Implementation>
</Method>

<Method name="IncludeCodeSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%IncludeCode=value,i%%isDefined("IncludeCode")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="IncludeCodeReset">
<Implementation><![CDATA[ set i%IncludeCode="" set i%%isDefined("IncludeCode")=0 quit
]]></Implementation>
</Method>

<Method name="IncludeCodeIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("IncludeCode")
]]></Implementation>
</Method>

<Method name="IncludeGeneratorSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%IncludeGenerator=value,i%%isDefined("IncludeGenerator")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="IncludeGeneratorReset">
<Implementation><![CDATA[ set i%IncludeGenerator="" set i%%isDefined("IncludeGenerator")=0 quit
]]></Implementation>
</Method>

<Method name="IncludeGeneratorIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("IncludeGenerator")
]]></Implementation>
</Method>

<Method name="IndexClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%IndexClass=value,i%%isDefined("IndexClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="IndexClassReset">
<Implementation><![CDATA[ set i%IndexClass="" set i%%isDefined("IndexClass")=0 quit
]]></Implementation>
</Method>

<Method name="IndexClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("IndexClass")
]]></Implementation>
</Method>

<Method name="InheritanceSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Inheritance=value,i%%isDefined("Inheritance")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="InheritanceReset">
<Implementation><![CDATA[ set i%Inheritance="left" set i%%isDefined("Inheritance")=0 quit
]]></Implementation>
</Method>

<Method name="InheritanceIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Inheritance")
]]></Implementation>
</Method>

<Method name="LanguageSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Language=value,i%%isDefined("Language")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="LanguageReset">
<Implementation><![CDATA[ set i%Language="cache" set i%%isDefined("Language")=0 quit
]]></Implementation>
</Method>

<Method name="LanguageIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Language")
]]></Implementation>
</Method>

<Method name="LegacyInstanceContextSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%LegacyInstanceContext=value,i%%isDefined("LegacyInstanceContext")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="LegacyInstanceContextReset">
<Implementation><![CDATA[ set i%LegacyInstanceContext=0 set i%%isDefined("LegacyInstanceContext")=0 quit
]]></Implementation>
</Method>

<Method name="LegacyInstanceContextIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("LegacyInstanceContext")
]]></Implementation>
</Method>

<Method name="MemberSuperSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%MemberSuper=value,i%%isDefined("MemberSuper")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="MemberSuperReset">
<Implementation><![CDATA[ set i%MemberSuper="" set i%%isDefined("MemberSuper")=0 quit
]]></Implementation>
</Method>

<Method name="MemberSuperIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("MemberSuper")
]]></Implementation>
</Method>

<Method name="ModificationAuxiliarySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ModificationAuxiliary=value,i%%isDefined("ModificationAuxiliary")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ModificationAuxiliaryReset">
<Implementation><![CDATA[ set i%ModificationAuxiliary="" set i%%isDefined("ModificationAuxiliary")=0 quit
]]></Implementation>
</Method>

<Method name="ModificationAuxiliaryIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ModificationAuxiliary")
]]></Implementation>
</Method>

<Method name="ModificationLevelSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ModificationLevel=value,i%%isDefined("ModificationLevel")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ModificationLevelReset">
<Implementation><![CDATA[ set i%ModificationLevel=9 set i%%isDefined("ModificationLevel")=0 quit
]]></Implementation>
</Method>

<Method name="ModificationLevelIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ModificationLevel")
]]></Implementation>
</Method>

<Method name="ModifiedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Modified=value,i%%isDefined("Modified")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ModifiedReset">
<Implementation><![CDATA[ set i%Modified=3 set i%%isDefined("Modified")=0 quit
]]></Implementation>
</Method>

<Method name="ModifiedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Modified")
]]></Implementation>
</Method>

<Method name="NameSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Name=$$$NormalizeClassname(value),i%%isDefined("Name")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="NameReset">
<Implementation><![CDATA[ set i%Name="" set i%%isDefined("Name")=0 quit
]]></Implementation>
</Method>

<Method name="NameIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Name")
]]></Implementation>
</Method>

<Method name="NoContextSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%NoContext=value,i%%isDefined("NoContext")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="NoContextReset">
<Implementation><![CDATA[ set i%NoContext=0 set i%%isDefined("NoContext")=0 quit
]]></Implementation>
</Method>

<Method name="NoContextIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("NoContext")
]]></Implementation>
</Method>

<Method name="NoExtentSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%NoExtent=value,i%%isDefined("NoExtent")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="NoExtentReset">
<Implementation><![CDATA[ set i%NoExtent=0 set i%%isDefined("NoExtent")=0 quit
]]></Implementation>
</Method>

<Method name="NoExtentIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("NoExtent")
]]></Implementation>
</Method>

<Method name="OdbcTypeSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%OdbcType=value,i%%isDefined("OdbcType")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="OdbcTypeReset">
<Implementation><![CDATA[ set i%OdbcType="VARCHAR" set i%%isDefined("OdbcType")=0 quit
]]></Implementation>
</Method>

<Method name="OdbcTypeIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("OdbcType")
]]></Implementation>
</Method>

<Method name="OwnerSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Owner=value,i%%isDefined("Owner")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="OwnerReset">
<Implementation><![CDATA[ set i%Owner="" set i%%isDefined("Owner")=0 quit
]]></Implementation>
</Method>

<Method name="OwnerIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Owner")
]]></Implementation>
</Method>

<Method name="ProcedureBlockSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ProcedureBlock=value,i%%isDefined("ProcedureBlock")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ProcedureBlockReset">
<Implementation><![CDATA[ set i%ProcedureBlock=1 set i%%isDefined("ProcedureBlock")=0 quit
]]></Implementation>
</Method>

<Method name="ProcedureBlockIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ProcedureBlock")
]]></Implementation>
</Method>

<Method name="ProjectionClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ProjectionClass=value,i%%isDefined("ProjectionClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ProjectionClassReset">
<Implementation><![CDATA[ set i%ProjectionClass="" set i%%isDefined("ProjectionClass")=0 quit
]]></Implementation>
</Method>

<Method name="ProjectionClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ProjectionClass")
]]></Implementation>
</Method>

<Method name="PropertyClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%PropertyClass=value,i%%isDefined("PropertyClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="PropertyClassReset">
<Implementation><![CDATA[ set i%PropertyClass="" set i%%isDefined("PropertyClass")=0 quit
]]></Implementation>
</Method>

<Method name="PropertyClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("PropertyClass")
]]></Implementation>
</Method>

<Method name="QueryClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%QueryClass=value,i%%isDefined("QueryClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="QueryClassReset">
<Implementation><![CDATA[ set i%QueryClass="" set i%%isDefined("QueryClass")=0 quit
]]></Implementation>
</Method>

<Method name="QueryClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("QueryClass")
]]></Implementation>
</Method>

<Method name="ServerOnlySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ServerOnly=value,i%%isDefined("ServerOnly")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ServerOnlyReset">
<Implementation><![CDATA[ set i%ServerOnly="" set i%%isDefined("ServerOnly")=0 quit
]]></Implementation>
</Method>

<Method name="ServerOnlyIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ServerOnly")
]]></Implementation>
</Method>

<Method name="SoapBindingStyleSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SoapBindingStyle=value,i%%isDefined("SoapBindingStyle")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SoapBindingStyleReset">
<Implementation><![CDATA[ set i%SoapBindingStyle="document" set i%%isDefined("SoapBindingStyle")=0 quit
]]></Implementation>
</Method>

<Method name="SoapBindingStyleIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SoapBindingStyle")
]]></Implementation>
</Method>

<Method name="SoapBodyUseSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SoapBodyUse=value,i%%isDefined("SoapBodyUse")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SoapBodyUseReset">
<Implementation><![CDATA[ set i%SoapBodyUse="literal" set i%%isDefined("SoapBodyUse")=0 quit
]]></Implementation>
</Method>

<Method name="SoapBodyUseIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SoapBodyUse")
]]></Implementation>
</Method>

<Method name="SqlCategorySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SqlCategory=value,i%%isDefined("SqlCategory")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SqlCategoryReset">
<Implementation><![CDATA[ set i%SqlCategory="STRING" set i%%isDefined("SqlCategory")=0 quit
]]></Implementation>
</Method>

<Method name="SqlCategoryIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SqlCategory")
]]></Implementation>
</Method>

<Method name="SqlRoutinePrefixSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SqlRoutinePrefix=value,i%%isDefined("SqlRoutinePrefix")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SqlRoutinePrefixReset">
<Implementation><![CDATA[ set i%SqlRoutinePrefix="" set i%%isDefined("SqlRoutinePrefix")=0 quit
]]></Implementation>
</Method>

<Method name="SqlRoutinePrefixIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SqlRoutinePrefix")
]]></Implementation>
</Method>

<Method name="SqlRowIdNameSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SqlRowIdName=value,i%%isDefined("SqlRowIdName")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SqlRowIdNameReset">
<Implementation><![CDATA[ set i%SqlRowIdName="" set i%%isDefined("SqlRowIdName")=0 quit
]]></Implementation>
</Method>

<Method name="SqlRowIdNameIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SqlRowIdName")
]]></Implementation>
</Method>

<Method name="SqlRowIdPrivateSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SqlRowIdPrivate=value,i%%isDefined("SqlRowIdPrivate")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SqlRowIdPrivateReset">
<Implementation><![CDATA[ set i%SqlRowIdPrivate=0 set i%%isDefined("SqlRowIdPrivate")=0 quit
]]></Implementation>
</Method>

<Method name="SqlRowIdPrivateIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SqlRowIdPrivate")
]]></Implementation>
</Method>

<Method name="SqlTableNameSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%SqlTableName=value,i%%isDefined("SqlTableName")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SqlTableNameReset">
<Implementation><![CDATA[ set i%SqlTableName="" set i%%isDefined("SqlTableName")=0 quit
]]></Implementation>
</Method>

<Method name="SqlTableNameIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("SqlTableName")
]]></Implementation>
</Method>

<Method name="StorageStrategySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%StorageStrategy=value,i%%isDefined("StorageStrategy")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="StorageStrategyReset">
<Implementation><![CDATA[ set i%StorageStrategy="" set i%%isDefined("StorageStrategy")=0 quit
]]></Implementation>
</Method>

<Method name="StorageStrategyIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("StorageStrategy")
]]></Implementation>
</Method>

<Method name="SuperSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%Super=value,i%%isDefined("Super")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SuperReset">
<Implementation><![CDATA[ set i%Super="" set i%%isDefined("Super")=0 quit
]]></Implementation>
</Method>

<Method name="SuperIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("Super")
]]></Implementation>
</Method>

<Method name="SystemSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%System=value,i%%isDefined("System")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="SystemReset">
<Implementation><![CDATA[ set i%System=0 set i%%isDefined("System")=0 quit
]]></Implementation>
</Method>

<Method name="SystemIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("System")
]]></Implementation>
</Method>

<Method name="TimeChangedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%TimeChanged=value,i%%isDefined("TimeChanged")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="TimeChangedReset">
<Implementation><![CDATA[ set i%TimeChanged="" set i%%isDefined("TimeChanged")=0 quit
]]></Implementation>
</Method>

<Method name="TimeChangedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("TimeChanged")
]]></Implementation>
</Method>

<Method name="TimeCreatedSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%TimeCreated=value,i%%isDefined("TimeCreated")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="TimeCreatedReset">
<Implementation><![CDATA[ set i%TimeCreated="" set i%%isDefined("TimeCreated")=0 quit
]]></Implementation>
</Method>

<Method name="TimeCreatedIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("TimeCreated")
]]></Implementation>
</Method>

<Method name="TriggerClassSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%TriggerClass=value,i%%isDefined("TriggerClass")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="TriggerClassReset">
<Implementation><![CDATA[ set i%TriggerClass="" set i%%isDefined("TriggerClass")=0 quit
]]></Implementation>
</Method>

<Method name="TriggerClassIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("TriggerClass")
]]></Implementation>
</Method>

<Method name="ViewQuerySet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ set i%ViewQuery=value,i%%isDefined("ViewQuery")=1 quit $$$OK
]]></Implementation>
</Method>

<Method name="ViewQueryReset">
<Implementation><![CDATA[ set i%ViewQuery="" set i%%isDefined("ViewQuery")=0 quit
]]></Implementation>
</Method>

<Method name="ViewQueryIsDefined">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[ quit ''i%%isDefined("ViewQuery")
]]></Implementation>
</Method>

<Method name="NormalizeClassname">
<ClassMethod>1</ClassMethod>
<FormalSpec>classname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ QUIT $$$NormalizeClassname(classname)
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.ClassDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddDEF({L1},21))#2:^(21),1:0)
</RetrievalCode>
</Data>
<Data name="ClassDefinitionError">
<RetrievalCode> s {ClassDefinitionError}=$s($d(^oddDEF({L1},67))#2:^(67),1:0)
</RetrievalCode>
</Data>
<Data name="ClassType">
<RetrievalCode> s {ClassType}=$s($d(^oddDEF({L1},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
<Data name="ClientDataType">
<RetrievalCode> s {ClientDataType}=$s($d(^oddDEF({L1},24))#2:^(24),1:"VARCHAR")
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddDEF({L1},73))#2:^(73),1:"")
</RetrievalCode>
</Data>
<Data name="CompileAfter">
<RetrievalCode> s {CompileAfter}=$s($d(^oddDEF({L1},28))#2:^(28),1:"")
</RetrievalCode>
</Data>
<Data name="ConstraintClass">
<RetrievalCode> s {ConstraintClass}=$s($d(^oddDEF({L1},80))#2:^(80),1:"")
</RetrievalCode>
</Data>
<Data name="DdlAllowed">
<RetrievalCode> s {DdlAllowed}=$s($d(^oddDEF({L1},29))#2:^(29),1:0)
</RetrievalCode>
</Data>
<Data name="DependsOn">
<RetrievalCode> s {DependsOn}=$s($d(^oddDEF({L1},84))#2:^(84),1:"")
</RetrievalCode>
</Data>
<Data name="Deployed">
<RetrievalCode> s {Deployed}=$s($d(^oddDEF({L1},72))#2:^(72),1:0)
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Dynamic">
<RetrievalCode> s {Dynamic}=$s($d(^oddDEF({L1},30))#2:^(30),1:0)
</RetrievalCode>
</Data>
<Data name="EmbeddedClass">
<RetrievalCode> s {EmbeddedClass}=$s($d(^oddDEF({L1},100))#2:^(100),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="GeneratedBy">
<RetrievalCode> s {GeneratedBy}=$s($d(^oddDEF({L1},87))#2:^(87),1:"")
</RetrievalCode>
</Data>
<Data name="Hidden">
<RetrievalCode> s {Hidden}=$s($d(^oddDEF({L1},32))#2:^(32),1:0)
</RetrievalCode>
</Data>
<Data name="Import">
<RetrievalCode> s {Import}=$s($d(^oddDEF({L1},33))#2:^(33),1:"")
</RetrievalCode>
</Data>
<Data name="IncludeCode">
<RetrievalCode> s {IncludeCode}=$s($d(^oddDEF({L1},35))#2:^(35),1:"")
</RetrievalCode>
</Data>
<Data name="IncludeGenerator">
<RetrievalCode> s {IncludeGenerator}=$s($d(^oddDEF({L1},37))#2:^(37),1:"")
</RetrievalCode>
</Data>
<Data name="IndexClass">
<RetrievalCode> s {IndexClass}=$s($d(^oddDEF({L1},81))#2:^(81),1:"")
</RetrievalCode>
</Data>
<Data name="Inheritance">
<RetrievalCode> s {Inheritance}=$s($d(^oddDEF({L1},92))#2:^(92),1:"left")
</RetrievalCode>
</Data>
<Data name="LegacyInstanceContext">
<RetrievalCode> s {LegacyInstanceContext}=$s($d(^oddDEF({L1},96))#2:^(96),1:0)
</RetrievalCode>
</Data>
<Data name="MemberSuper">
<RetrievalCode> s {MemberSuper}=$s($d(^oddDEF({L1},83))#2:^(83),1:"")
</RetrievalCode>
</Data>
<Data name="ModificationAuxiliary">
<RetrievalCode> s {ModificationAuxiliary}=$s($d(^oddDEF({L1},68))#2:^(68),1:"")
</RetrievalCode>
</Data>
<Data name="ModificationLevel">
<RetrievalCode> s {ModificationLevel}=$s($d(^oddDEF({L1},69))#2:^(69),1:9)
</RetrievalCode>
</Data>
<Data name="Modified">
<RetrievalCode> s {Modified}=$s($d(^oddDEF({L1},40))#2:^(40),1:3)
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddDEF({L1},42))#2:^(42),1:0)
</RetrievalCode>
</Data>
<Data name="NoExtent">
<RetrievalCode> s {NoExtent}=$s($d(^oddDEF({L1},76))#2:^(76),1:0)
</RetrievalCode>
</Data>
<Data name="OdbcType">
<RetrievalCode> s {OdbcType}=$s($d(^oddDEF({L1},43))#2:^(43),1:"VARCHAR")
</RetrievalCode>
</Data>
<Data name="Owner">
<RetrievalCode> s {Owner}=$s($d(^oddDEF({L1},44))#2:^(44),1:"")
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddDEF({L1},46))#2:^(46),1:1)
</RetrievalCode>
</Data>
<Data name="ProjectionClass">
<RetrievalCode> s {ProjectionClass}=$s($d(^oddDEF({L1},82))#2:^(82),1:"")
</RetrievalCode>
</Data>
<Data name="PropertyClass">
<RetrievalCode> s {PropertyClass}=$s($d(^oddDEF({L1},48))#2:^(48),1:"")
</RetrievalCode>
</Data>
<Data name="QueryClass">
<RetrievalCode> s {QueryClass}=$s($d(^oddDEF({L1},79))#2:^(79),1:"")
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddDEF({L1},88))#2:^(88),1:"")
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddDEF({L1},70))#2:^(70),1:"document")
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddDEF({L1},71))#2:^(71),1:"literal")
</RetrievalCode>
</Data>
<Data name="SqlCategory">
<RetrievalCode> s {SqlCategory}=$s($d(^oddDEF({L1},52))#2:^(52),1:"STRING")
</RetrievalCode>
</Data>
<Data name="SqlRoutinePrefix">
<RetrievalCode> s {SqlRoutinePrefix}=$s($d(^oddDEF({L1},54))#2:^(54),1:"")
</RetrievalCode>
</Data>
<Data name="SqlRowIdName">
<RetrievalCode> s {SqlRowIdName}=$s($d(^oddDEF({L1},55))#2:^(55),1:"")
</RetrievalCode>
</Data>
<Data name="SqlRowIdPrivate">
<RetrievalCode> s {SqlRowIdPrivate}=$s($d(^oddDEF({L1},56))#2:^(56),1:0)
</RetrievalCode>
</Data>
<Data name="SqlTableName">
<RetrievalCode> s {SqlTableName}=$s($d(^oddDEF({L1},58))#2:^(58),1:"")
</RetrievalCode>
</Data>
<Data name="StorageStrategy">
<RetrievalCode> s {StorageStrategy}=$s($d(^oddDEF({L1},59))#2:^(59),1:"")
</RetrievalCode>
</Data>
<Data name="Super">
<RetrievalCode> s {Super}=$s($d(^oddDEF({L1},60))#2:^(60),1:"")
</RetrievalCode>
</Data>
<Data name="System">
<RetrievalCode> s {System}=$s($d(^oddDEF({L1},61))#2:^(61),1:0)
</RetrievalCode>
</Data>
<Data name="TimeChanged">
<RetrievalCode> s {TimeChanged}=$s($d(^oddDEF({L1},63))#2:^(63),1:"")
</RetrievalCode>
</Data>
<Data name="TimeCreated">
<RetrievalCode> s {TimeCreated}=$s($d(^oddDEF({L1},64))#2:^(64),1:"")
</RetrievalCode>
</Data>
<Data name="TriggerClass">
<RetrievalCode> s {TriggerClass}=$s($d(^oddDEF({L1},99))#2:^(99),1:"")
</RetrievalCode>
</Data>
<Data name="ViewQuery">
<RetrievalCode> s {ViewQuery}=$s($d(^oddDEF({L1},65))#2:^(65),1:"")
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddDEF({L1},39))#2:^(39),1:"cache")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.ClassDefinitionQuery">
<Abstract>1</Abstract>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="ClassIndex">
<Description><![CDATA[
The <b>ClassIndex</b> query provides a summary of information about classes contained in the Class Index]]></Description>
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="ROWSPEC" value="TimeChanged:%String,ClassName:%String,System:%Integer,Hidden:%Boolean,ClassType:%String,Size:%Integer,Super:%String,SqlTableName:%String,Final:%Boolean,Generated:%Boolean,Abstract:%Boolean,Hash1:%String,Hash2:%String,Import:%String,ClientName:%String"/>
</Query>

<Method name="ClassIndexExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ClassIndexFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..ClassIndexFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="ClassIndexFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set RowSet=""
	If '$get(FetchCount) Set FetchCount=10000
	If $get(AtEnd) Set QHandle="" Quit $$$OK
	Set name=$zcvt(QHandle,"U"),AtEnd=0
	For no=1:1:FetchCount {
		Set name=$order(^rINDEXCLASS(name),1,data)
		If name="" Set AtEnd=1,QHandle="" Quit
		If $listget(data,16)=2 Set no=no-1 Continue
		Set RowSet=RowSet_$list(data,1,15)
		If $length(RowSet)>20000 Quit
	}
	If $get(AtEnd) Set ReturnCount=no-1 Quit $$$OK
	Set QHandle=name,ReturnCount=no
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ClassIndexClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="Summary">
<Description><![CDATA[
The <b>Summary</b> query provides a summary of information about classes contained in the 
<i>Cach&eacute Dictionary</i>.]]></Description>
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256):ClassName,Super:%String(MAXLEN=256),Hidden:%Boolean,Datatype:%Boolean,System:%Integer,Final:%Boolean,Persistent:%Boolean,Serial:%Boolean,TimeChanged,SqlTableName:%String(MAXLEN=256),Abstract:%Boolean"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..SummaryFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set RowSet=""
	If '$get(FetchCount) Set FetchCount=10000
	If $get(AtEnd) Set QHandle="" Quit $$$OK
	Set name=$zcvt(QHandle,"U"),AtEnd=0
	For no=1:1:FetchCount {
		Set name=$order(^rINDEXCLASS(name),1,data)
		If name="" Set AtEnd=1,QHandle="" Quit
		Set time=$listget(data) If time'="" Set time=$zdth(time,3)
		If $listget(data,16)=2 Set no=no-1 Continue
		Set classtype=$$ClassType^%occName($list(data,2))
		Set RowSet=RowSet_$lb($list(data,2),$lg(data,7),''$lg(data,4),classtype=$$$cCLASSCLASSTYPEDATATYPE,''$lg(data,3),''$lg(data,9),classtype=$$$cCLASSCLASSTYPEPERSISTENT,classtype=$$$cCLASSCLASSTYPESERIAL,time,$lg(data,8),$lg(data,10))
		If $length(RowSet)>20000 Quit
	}
	If $get(AtEnd) Set ReturnCount=no-1 Quit $$$OK
	Set QHandle=name,ReturnCount=no
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set QHandle=""
 Quit $$$OK
]]></Implementation>
</Method>

<Query name="FormWizard">
<Description><![CDATA[
The <b>FormWizard</b> query provides a list of persistent system classes and all others along with just their name]]></Description>
<Type>%Query</Type>
<FormalSpec>classtype:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256)"/>
</Query>

<Method name="FormWizardExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,classtype:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=$listbuild($zconvert(classtype,"l"))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FormWizardFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..FormWizardFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="FormWizardFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set RowSet="",ReturnCount=0
	If '$get(FetchCount) Set FetchCount=10000
	If $get(AtEnd) Set QHandle="" Quit $$$OK
	Set name=$listget(QHandle,2),AtEnd=0,classtype=$list(QHandle),system=($zutil(5)="%SYS")
	For  {
		Set name=$order(^rINDEXCLASS(name),1,data)
		If name="" Set AtEnd=1,QHandle="" Quit
		If $$ClassType^%occName($list(data,2))'=classtype Continue
		If $extract(name)="%",'system Continue
		Set RowSet=RowSet_$lb($list(data,2)),ReturnCount=ReturnCount+1
		If $length(RowSet)>20000||(ReturnCount'<FetchCount) Quit
	}
	If $get(AtEnd) Quit $$$OK
	Set $list(QHandle,2)=name
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FormWizardClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="SubclassOf">
<Description><![CDATA[
The <b>SubclassOf</b> query produces a list of classes that are subclasses of the
<var>super</var> class starting the search at <var>initval</var>. For example this
allows you to find all the subclasses of %CSP.Page very easily.]]></Description>
<Type>%Query</Type>
<FormalSpec>super:%String,initval:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256):ClassName"/>
</Query>

<Method name="SubclassOfExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,super:%String,initval:%String=""]]></FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New class,answer,idx,data
	Set idx=$increment(^CacheTemp)
	#; Make sure this is cleaned up if the process crashes
	$$$AddTempNode(^CacheTemp(idx))
	Set super=$$$NormalizeClassname(super)
	Set ^CacheTemp(idx,super)=1
	Set class=$order(^rINDEXCLASS($zcvt(initval,"u")),1,data)
	While class'="" {
		Do check($list(data,2))
		Set class=$order(^rINDEXCLASS(class),1,data)
	}
	Kill ^CacheTemp(idx,super)
	Set QHandle=$listbuild(idx,initval)
	Quit $$$OK
check(class) 	If class="" Quit 0
	If $data(^CacheTemp(idx,class)) Quit ^(class)
	#; Set this class to no in case of superclass loop, it will be set to correct value at end of this function
	Set ^(class)=0
	New thissuper,no,item,return
	Set return=0
	Set thissuper=$lg($get(^rINDEXCLASS($zcvt(class,"U"))),7)
	For no=1:1:$length(thissuper,",") {
		Set item=$zstrip($piece(thissuper,",",no),"<>W")
		If item'="" Do NormalizeClassnameByDef^%occName(.item,item,class) If $$check(item) Set return=1 Quit
	}
	Set ^CacheTemp(idx,class)=return
	Quit return
]]></Implementation>
</Method>

<Method name="SubclassOfClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $listget(QHandle)'="" {
		Kill ^CacheTemp($list(QHandle))
		$$$RemoveTempNode(^CacheTemp($list(QHandle)))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubclassOfFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..SubclassOfFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="SubclassOfFetchRows">
<Description><![CDATA[
<b>SubclassOfFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If QHandle="" Set AtEnd=1 Quit $$$OK
	If FetchCount=0 Set FetchCount=2000
	Set RowSet="",number=0
	Set class=$listget(QHandle,2),idx=$listget(QHandle)
	Set class=$order(^CacheTemp(idx,class),1,val)
	While class'="" {
		If val {
			Set RowSet=RowSet_$listbuild(class),number=number+1
			If number=FetchCount||($length(RowSet)>20000) Quit
		}
		Set class=$order(^CacheTemp(idx,class),1,val)
	}
	#; Check if we are done
	If class="" Set AtEnd=1,QHandle="" Kill ^CacheTemp(idx) $$$RemoveTempNode(^CacheTemp(idx)) Quit $$$OK
	Set ReturnCount=number
	Set QHandle=$ListBuild(idx,class)
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="MemberSummary">
<Description><![CDATA[
Return a list of members of this specific <var>kind</var> which is one of the following:<ul>
<li>a - Property</li>
<li>f - Foreign key</li>
<li>i - Index</li>
<li>j - Projection</li>
<li>m - Method</li>
<li>n - Constraint</li>
<li>o - System method</li>
<li>p - Parameter</li>
<li>q - Query</li>
<li>s - Storage defintion</li>
<li>t - Trigger</li>
<li>u - Comment text block</li>
<li>x - XData</li>
</ul>]]></Description>
<Type>%Query</Type>
<FormalSpec>classname:%String,kind:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256)"/>
</Query>

<Method name="MemberSummaryExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String,kind:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s classname=$$$NormalizeClassname(classname)
	s QHandle=$lb(0,classname,kind,"")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MemberSummaryFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s AtEnd=$li(QHandle,1),classname=$li(QHandle,2),kind=$li(QHandle,3),element=$li(QHandle,4),Row=""
	i AtEnd q $$$OK
	s element=$$$defMemberNext(classname,kind,element)
	i element="" s AtEnd=1
	e  s Row=$lb(element) i $$$defMemberNext(classname,kind,element)="" s AtEnd=1
	s QHandle=$lb(AtEnd,classname,kind,element)
	q $$$OK
]]></Implementation>
</Method>

<Method name="MemberSummaryClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledClass">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledClassQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.119173</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="Abstract">
<Description>
Specifies that the class cannot have instances; for datatypes, specifies that the class cannot be used as an attribute type.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Ancestry">
<Description>
Ancestry</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CacheVersion">
<Description>
The version of Cache this class was compiled on.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClassCompileError">
<Description>
Status code from this class compile if there is an error</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClassDefinitionError">
<Description>
Set to true if there is a problem serializing the class so the compiler knows not to compile this.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Classes">
<Description>
Array of items generated by this class.</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="ClassType">
<Description>
Specifies how this class is to be used.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientDataType">
<Description>
In the case of a datatype class, specifies the type used when exposed via ActiveX or Java. Datatype classes must specify a client datatype. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientDataTypeEnum">
<Description>
ClientDataTypeEnum</Description>
<Type>%Integer</Type>
</Property>

<Property name="ClientInfo">
<Description>
ClientInfo</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="ClientName">
<Description>
This gives an alternate name for the class if it projected, for example, to Java.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilationSignature">
<Description>
CompilationSignature</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompileAfter">
<Description>
Indicates that the class compiler should compile this class after the specified classes.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompileNamespace">
<Description>
The namespace when this class is compiled, used to help dependency checking.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Constraints">
<Description>
Constraint</Description>
<Type>%Dictionary.CompiledConstraint</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ConstraintClass">
<Description>
Additional constraint member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DdlAllowed">
<Description>
In the case of a persistent class, indicates whether or not DDL statements can be used to alter or delete the class definition. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="DependsOn">
<Description>
List of classes that this class depends on being runable in order for this class to compile.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deployed">
<Description>
Indicates whether the class has been deployed, that is, disassociated from the source that was used to build it.</Description>
<Type>%Integer</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this class is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DisableIncremental">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Dynamic">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="EmbeddedClass">
<Description>
If specified in a member type class is the name of the class which forms the embedded superclass</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Extents">
<Description>
Extents</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Final">
<Description>
Specifies that the class cannot have subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForeignKeys">
<Description>
ForeignKey</Description>
<Type>%Dictionary.CompiledForeignKey</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="GeneratedBy">
<Description>
If this class is generated by some other component then this is the name of the item that generated this class</Description>
<Type>%CacheString</Type>
</Property>

<Property name="HasCPP">
<Description>
True if this class has C++ methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
A hash of this class so we can detect when it is changed.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hidden">
<Description>
Specifies that this class is not typically listed when viewing the contents of the class dictionary.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Import">
<Description>
Supplies a list of class packages to import for this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Importall">
<Description>
Importall</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="IncludeCode">
<Description>
Specifies an optional list of Cache include files used when compiling this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IncludeCodeAll">
<Description>
IncludeCodeAll</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="IncludeGenerator">
<Description>
Specifies an optional list of Cache include files used when compiling the method generator methods of this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IncludeMGenAll">
<Description>
IncludeMGenAll</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Indices">
<Description>
Index</Description>
<Type>%Dictionary.CompiledIndex</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="IndexClass">
<Description>
Additional index member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Inheritance">
<Description>
Define the inheritance order when using multiple inheritance, if a member exists in multiple superclasses which one will take precedence.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="InitialValue">
<Description>
If specified the initial serial value for a new object</Description>
<Type>%CacheString</Type>
</Property>

<Property name="InstanceVars">
<Description>
InstanceVar</Description>
<Type>%Dictionary.CompiledInstanceVar</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Language">
<Description>
The default language used to implement methods for this class.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="LegacyInstanceContext">
<Description>
If true then pass %this as first argument of all instance methods</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Manifest">
<Description>
Array of items projected with this class which need to be included in any deployment package we create from this class</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="MemberSuper">
<Description>
This is the class to inherit if this class is used as a member class in member inheritance</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.CompiledMethod</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ModificationAuxiliary">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ModificationLevel">
<Description>
Deprecated.</Description>
<Type>%Integer</Type>
</Property>

<Property name="Modified">
<Description>
If set to 0 then class is always modified, and so it is always saved.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
The name of the class.</Description>
<Type>%Dictionary.CacheClassname</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description>
NoContext</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NoExtent">
<Description>
If TRUE will prevent this class from instantiating a persistent extent.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OdbcType">
<Description>
In the case of a datatype class, specifies the type used when exposed via ODBC or JDBC. Datatype classes must specify an ODBC type. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="OldHash">
<Description>
Keep track of old hash values so we can modify a class without marking it as out of date.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Owner">
<Description>
Specifies the owner of the class and its corresponding table. By default, classes and tables are owned by _SYSTEM.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%Dictionary.CompiledParameter</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PrimarySuper">
<Description>
PrimarySuper</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that the class uses procedure block for method code.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Procedures">
<Description>
Procedures</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Projections">
<Description>
Projection</Description>
<Type>%Dictionary.CompiledProjection</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ProjectionClass">
<Description>
Additional projection member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Properties">
<Description>
Property</Description>
<Type>%Dictionary.CompiledProperty</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PropertyClass">
<Description>
Additional property member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Queries">
<Description>
Query</Description>
<Type>%Dictionary.CompiledQuery</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="QueryClass">
<Description>
Additional query member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RandomSig">
<Description>
Random value that is updated each time the class is compiled</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RoutineCount">
<Description>
RoutineCount</Description>
<Type>%Integer</Type>
</Property>

<Property name="Routines">
<Description>
Routines</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="ServerOnly">
<Description>
ServerOnly</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SlotCount">
<Description>
SlotCount</Description>
<Type>%Integer</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies the SOAP Binding used by this class when it is used to send and receive mnessages via SOAP.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies the encoding used for SOAP messages.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlCategory">
<Description>
In the case of a datatype class, specifies a type to use for calculations in SQL. Datatype classes must specify an SQL Category.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlQualifiedNameQ">
<Description>
SqlQualifiedNameQ</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRoutinePrefix">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdName">
<Description>
In the case of a persistent class, specifies an altername field name used for the ID column. By default the ID is called ID.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdPrivate">
<Description>
In the case of a persistent class, specifies whether the ID column is projected to ODBC as a hidden field.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlSchemaName">
<Description>
SqlSchemaName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlTableName">
<Description>
In the case of a persistent class, specifies the table name used to identify the class in its SQL projection. By default, the SQL table name is the same as the class name.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Storages">
<Description>
Storage</Description>
<Type>%Dictionary.CompiledStorage</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="StorageStrategy">
<Description>
Specifies the name of the storage strategy used to control persistence for this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Structure">
<Description><![CDATA[
Hash of class &#39;structure&#39; so we can detect when SQL related classes need to be recompiled.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Super">
<Description>
Specifies one or more superclasses for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="System">
<Description>
Specifies that the class is internal to the implementation of Cache. Users should not mark their classes with this keyword.</Description>
<Type>%CacheString</Type>
<ClientName>_System</ClientName>
</Property>

<Property name="Tables">
<Description>
Tables</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="TimeChanged">
<Description>
Gives the time the last change was made to the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TimeCreated">
<Description>
Gives the time the class was first created.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Triggers">
<Description>
Trigger</Description>
<Type>%Dictionary.CompiledTrigger</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TriggerClass">
<Description>
Additional trigger member super classes to inherit.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UDLTexts">
<Description>
UDLText</Description>
<Type>%Dictionary.CompiledUDLText</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ViewQuery">
<Description>
Gives the SQL query used for View definition of this class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Views">
<Description>
Views</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="XDatas">
<Description>
XData</Description>
<Type>%Dictionary.CompiledXData</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="XMLData">
<Description>
XMLData</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=id
 i (name1="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comClassDefined(name1) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=id
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||('$$$comClassDefined(name1)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%Name=name1
 . s i%Abstract=$$$comClassKeyGet(name1,$$$cCLASSabstract)
 . s i%Ancestry=$$$comClassKeyGet(name1,$$$cCLASSancestry)
 . s i%CacheVersion=$$$comClassKeyGet(name1,$$$cCLASScacheversion)
 . s i%ClassCompileError=$$$comClassKeyGet(name1,$$$cCLASSclasscompileerror)
 . s i%ClassDefinitionError=$$$comClassKeyGet(name1,$$$cCLASSclassdefinitionerror)
 . s i%ClassType=$$$comClassKeyGet(name1,$$$cCLASSclasstype)
 . s i%ClientDataType=$$$comClassKeyGet(name1,$$$cCLASSclientdatatype)
 . s i%ClientDataTypeEnum=$$$comClassKeyGet(name1,$$$cCLASSclientdatatypeenum)
 . s i%ClientName=$$$comClassKeyGet(name1,$$$cCLASSclientname)
 . s i%CompilationSignature=$$$comClassKeyGet(name1,$$$cCLASScompilationsignature)
 . s i%CompileAfter=$$$comClassKeyGet(name1,$$$cCLASScompileafter)
 . s i%CompileNamespace=$$$comClassKeyGet(name1,$$$cCLASScompilenamespace)
 . s i%ConstraintClass=$$$comClassKeyGet(name1,$$$cCLASSconstraintclass)
 . s i%DdlAllowed=$$$comClassKeyGet(name1,$$$cCLASSddlallowed)
 . s i%DependsOn=$$$comClassKeyGet(name1,$$$cCLASSdependson)
 . s i%Deployed=$$$comClassKeyGet(name1,$$$cCLASSdeployed)
 . s i%Deprecated=$$$comClassKeyGet(name1,$$$cCLASSdeprecated)
 . s i%Description=$$$comClassKeyGet(name1,$$$cCLASSdescription)
 . s i%DisableIncremental=$$$comClassKeyGet(name1,$$$cCLASSdisableincremental)
 . s i%Dynamic=$$$comClassKeyGet(name1,$$$cCLASSdynamic)
 . s i%EmbeddedClass=$$$comClassKeyGet(name1,$$$cCLASSembeddedclass)
 . s i%Final=$$$comClassKeyGet(name1,$$$cCLASSfinal)
 . s i%GeneratedBy=$$$comClassKeyGet(name1,$$$cCLASSgeneratedby)
 . s i%HasCPP=$$$comClassKeyGet(name1,$$$cCLASShascpp)
 . s i%Hash=$$$comClassKeyGet(name1,$$$cCLASShash)
 . s i%Hidden=$$$comClassKeyGet(name1,$$$cCLASShidden)
 . s i%Import=$$$comClassKeyGet(name1,$$$cCLASSimport)
 . s i%IncludeCode=$$$comClassKeyGet(name1,$$$cCLASSincludecode)
 . s i%IncludeGenerator=$$$comClassKeyGet(name1,$$$cCLASSincludegenerator)
 . s i%IndexClass=$$$comClassKeyGet(name1,$$$cCLASSindexclass)
 . s i%Inheritance=$$$comClassKeyGet(name1,$$$cCLASSinheritance)
 . s i%InitialValue=$$$comClassKeyGet(name1,$$$cCLASSinitialvalue)
 . s i%KeywordError=$$$comClassKeyGet(name1,$$$cCLASSkeyworderror)
 . s i%KeywordModified=$$$comClassKeyGet(name1,$$$cCLASSkeywordmodified)
 . s i%Language=$$$comClassKeyGet(name1,$$$cCLASSlanguage)
 . s i%LegacyInstanceContext=$$$comClassKeyGet(name1,$$$cCLASSlegacyinstancecontext)
 . s i%MemberSuper=$$$comClassKeyGet(name1,$$$cCLASSmembersuper)
 . s i%ModificationAuxiliary=$$$comClassKeyGet(name1,$$$cCLASSmodificationauxiliary)
 . s i%ModificationLevel=$$$comClassKeyGet(name1,$$$cCLASSmodificationlevel)
 . s i%Modified=$$$comClassKeyGet(name1,$$$cCLASSmodified)
 . s i%Name=$$$comClassKeyGet(name1,$$$cCLASSname)
 . s i%NoContext=$$$comClassKeyGet(name1,$$$cCLASSnocontext)
 . s i%NoExtent=$$$comClassKeyGet(name1,$$$cCLASSnoextent)
 . s i%OdbcType=$$$comClassKeyGet(name1,$$$cCLASSodbctype)
 . s i%OldHash=$$$comClassKeyGet(name1,$$$cCLASSoldhash)
 . s i%Owner=$$$comClassKeyGet(name1,$$$cCLASSowner)
 . s i%PrimarySuper=$$$comClassKeyGet(name1,$$$cCLASSprimarysuper)
 . s i%ProcedureBlock=$$$comClassKeyGet(name1,$$$cCLASSprocedureblock)
 . s i%ProjectionClass=$$$comClassKeyGet(name1,$$$cCLASSprojectionclass)
 . s i%PropertyClass=$$$comClassKeyGet(name1,$$$cCLASSpropertyclass)
 . s i%QueryClass=$$$comClassKeyGet(name1,$$$cCLASSqueryclass)
 . s i%RandomSig=$$$comClassKeyGet(name1,$$$cCLASSrandomsig)
 . s i%RoutineCount=$$$comClassKeyGet(name1,$$$cCLASSroutinecount)
 . s i%ServerOnly=$$$comClassKeyGet(name1,$$$cCLASSserveronly)
 . s i%SlotCount=$$$comClassKeyGet(name1,$$$cCLASSslotcount)
 . s i%SoapBindingStyle=$$$comClassKeyGet(name1,$$$cCLASSsoapbindingstyle)
 . s i%SoapBodyUse=$$$comClassKeyGet(name1,$$$cCLASSsoapbodyuse)
 . s i%SqlCategory=$$$comClassKeyGet(name1,$$$cCLASSsqlcategory)
 . s i%SqlQualifiedNameQ=$$$comClassKeyGet(name1,$$$cCLASSsqlqualifiednameQ)
 . s i%SqlRoutinePrefix=$$$comClassKeyGet(name1,$$$cCLASSsqlroutineprefix)
 . s i%SqlRowIdName=$$$comClassKeyGet(name1,$$$cCLASSsqlrowidname)
 . s i%SqlRowIdPrivate=$$$comClassKeyGet(name1,$$$cCLASSsqlrowidprivate)
 . s i%SqlSchemaName=$$$comClassKeyGet(name1,$$$cCLASSsqlschemaname)
 . s i%SqlTableName=$$$comClassKeyGet(name1,$$$cCLASSsqltablename)
 . s i%StorageStrategy=$$$comClassKeyGet(name1,$$$cCLASSstoragestrategy)
 . s i%Structure=$$$comClassKeyGet(name1,$$$cCLASSstructure)
 . s i%Super=$$$comClassKeyGet(name1,$$$cCLASSsuper)
 . s i%System=$$$comClassKeyGet(name1,$$$cCLASSsystem)
 . s i%TimeChanged=$$$comClassKeyGet(name1,$$$cCLASStimechanged)
 . s i%TimeCreated=$$$comClassKeyGet(name1,$$$cCLASStimecreated)
 . s i%TriggerClass=$$$comClassKeyGet(name1,$$$cCLASStriggerclass)
 . s i%ViewQuery=$$$comClassKeyGet(name1,$$$cCLASSviewquery)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSclasses,sub) q:sub=""  d
 . . d ..Classes.SetAt($$$comClassArrayGet(name1,$$$cCLASSclasses,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSclientinfo,sub) q:sub=""  d
 . . d ..ClientInfo.SetAt($$$comClassArrayGet(name1,$$$cCLASSclientinfo,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSextents,sub) q:sub=""  d
 . . d ..Extents.SetAt($$$comClassArrayGet(name1,$$$cCLASSextents,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSimportall,sub) q:sub=""  d
 . . d ..Importall.SetAt($$$comClassArrayGet(name1,$$$cCLASSimportall,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSincludecodeall,sub) q:sub=""  d
 . . d ..IncludeCodeAll.SetAt($$$comClassArrayGet(name1,$$$cCLASSincludecodeall,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSincludemgenall,sub) q:sub=""  d
 . . d ..IncludeMGenAll.SetAt($$$comClassArrayGet(name1,$$$cCLASSincludemgenall,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSmanifest,sub) q:sub=""  d
 . . d ..Manifest.SetAt($$$comClassArrayGet(name1,$$$cCLASSmanifest,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSprocedures,sub) q:sub=""  d
 . . d ..Procedures.SetAt($$$comClassArrayGet(name1,$$$cCLASSprocedures,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSroutines,sub) q:sub=""  d
 . . d ..Routines.SetAt($$$comClassArrayGet(name1,$$$cCLASSroutines,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASStables,sub) q:sub=""  d
 . . d ..Tables.SetAt($$$comClassArrayGet(name1,$$$cCLASStables,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSviews,sub) q:sub=""  d
 . . d ..Views.SetAt($$$comClassArrayGet(name1,$$$cCLASSviews,sub),sub)
 . s sub="" f  s sub=$$$comMemberNext(name1,$$$cCLASSxmldata,sub) q:sub=""  d
 . . d ..XMLData.SetAt($$$comClassArrayGet(name1,$$$cCLASSxmldata,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledClassS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},21))#2:^(21),1:$s($d(^oddDEF({L1},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="Ancestry">
<RetrievalCode> s {Ancestry}=$s($d(^oddCOM({L1},22))#2:^(22),1:$s($d(^oddDEF({L1},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="CacheVersion">
<RetrievalCode> s {CacheVersion}=$s($d(^oddCOM({L1},74))#2:^(74),1:$s($d(^oddDEF({L1},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="ClassCompileError">
<RetrievalCode> s {ClassCompileError}=$s($d(^oddCOM({L1},98))#2:^(98),1:$s($d(^oddDEF({L1},98))#2:^(98),1:""))
</RetrievalCode>
</Data>
<Data name="ClassDefinitionError">
<RetrievalCode> s {ClassDefinitionError}=$s($d(^oddCOM({L1},67))#2:^(67),1:$s($d(^oddDEF({L1},67))#2:^(67),1:0))
</RetrievalCode>
</Data>
<Data name="ClassType">
<RetrievalCode> s {ClassType}=$s($d(^oddCOM({L1},23))#2:^(23),1:$s($d(^oddDEF({L1},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="Classes">
<RetrievalCode> n sub s {Classes}="",sub="" f  s sub=$o(^oddCOM({L1},86,sub)) q:sub=""  s {Classes}={Classes}_$lb($lb(sub,$g(^oddCOM({L1},86,sub))))
</RetrievalCode>
</Data>
<Data name="ClientDataType">
<RetrievalCode> s {ClientDataType}=$s($d(^oddCOM({L1},24))#2:^(24),1:$s($d(^oddDEF({L1},24))#2:^(24),1:"VARCHAR"))
</RetrievalCode>
</Data>
<Data name="ClientDataTypeEnum">
<RetrievalCode> s {ClientDataTypeEnum}=$s($d(^oddCOM({L1},25))#2:^(25),1:$s($d(^oddDEF({L1},25))#2:^(25),1:0))
</RetrievalCode>
</Data>
<Data name="ClientInfo">
<RetrievalCode> n sub s {ClientInfo}="",sub="" f  s sub=$o(^oddCOM({L1},26,sub)) q:sub=""  s {ClientInfo}={ClientInfo}_$lb($lb(sub,$g(^oddCOM({L1},26,sub))))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},73))#2:^(73),1:$s($d(^oddDEF({L1},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="CompilationSignature">
<RetrievalCode> s {CompilationSignature}=$s($d(^oddCOM({L1},27))#2:^(27),1:$s($d(^oddDEF({L1},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="CompileAfter">
<RetrievalCode> s {CompileAfter}=$s($d(^oddCOM({L1},28))#2:^(28),1:$s($d(^oddDEF({L1},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="CompileNamespace">
<RetrievalCode> s {CompileNamespace}=$s($d(^oddCOM({L1},91))#2:^(91),1:$s($d(^oddDEF({L1},91))#2:^(91),1:""))
</RetrievalCode>
</Data>
<Data name="ConstraintClass">
<RetrievalCode> s {ConstraintClass}=$s($d(^oddCOM({L1},80))#2:^(80),1:$s($d(^oddDEF({L1},80))#2:^(80),1:""))
</RetrievalCode>
</Data>
<Data name="DdlAllowed">
<RetrievalCode> s {DdlAllowed}=$s($d(^oddCOM({L1},29))#2:^(29),1:$s($d(^oddDEF({L1},29))#2:^(29),1:0))
</RetrievalCode>
</Data>
<Data name="DependsOn">
<RetrievalCode> s {DependsOn}=$s($d(^oddCOM({L1},84))#2:^(84),1:$s($d(^oddDEF({L1},84))#2:^(84),1:""))
</RetrievalCode>
</Data>
<Data name="Deployed">
<RetrievalCode> s {Deployed}=$s($d(^oddCOM({L1},72))#2:^(72),1:$s($d(^oddDEF({L1},72))#2:^(72),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},17))#2:^(17),1:$s($d(^oddDEF({L1},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},4))#2:^(4),1:$s($d(^oddDEF({L1},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="DisableIncremental">
<RetrievalCode> s {DisableIncremental}=$s($d(^oddCOM({L1},95))#2:^(95),1:$s($d(^oddDEF({L1},95))#2:^(95),1:0))
</RetrievalCode>
</Data>
<Data name="Dynamic">
<RetrievalCode> s {Dynamic}=$s($d(^oddCOM({L1},30))#2:^(30),1:$s($d(^oddDEF({L1},30))#2:^(30),1:0))
</RetrievalCode>
</Data>
<Data name="EmbeddedClass">
<RetrievalCode> s {EmbeddedClass}=$s($d(^oddCOM({L1},100))#2:^(100),1:$s($d(^oddDEF({L1},100))#2:^(100),1:""))
</RetrievalCode>
</Data>
<Data name="Extents">
<RetrievalCode> n sub s {Extents}="",sub="" f  s sub=$o(^oddCOM({L1},77,sub)) q:sub=""  s {Extents}={Extents}_$lb($lb(sub,$g(^oddCOM({L1},77,sub))))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},7))#2:^(7),1:$s($d(^oddDEF({L1},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="GeneratedBy">
<RetrievalCode> s {GeneratedBy}=$s($d(^oddCOM({L1},87))#2:^(87),1:$s($d(^oddDEF({L1},87))#2:^(87),1:""))
</RetrievalCode>
</Data>
<Data name="HasCPP">
<RetrievalCode> s {HasCPP}=$s($d(^oddCOM({L1},97))#2:^(97),1:$s($d(^oddDEF({L1},97))#2:^(97),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},89))#2:^(89),1:$s($d(^oddDEF({L1},89))#2:^(89),1:""))
</RetrievalCode>
</Data>
<Data name="Hidden">
<RetrievalCode> s {Hidden}=$s($d(^oddCOM({L1},32))#2:^(32),1:$s($d(^oddDEF({L1},32))#2:^(32),1:0))
</RetrievalCode>
</Data>
<Data name="Import">
<RetrievalCode> s {Import}=$s($d(^oddCOM({L1},33))#2:^(33),1:$s($d(^oddDEF({L1},33))#2:^(33),1:""))
</RetrievalCode>
</Data>
<Data name="Importall">
<RetrievalCode> n sub s {Importall}="",sub="" f  s sub=$o(^oddCOM({L1},34,sub)) q:sub=""  s {Importall}={Importall}_$lb($lb(sub,$g(^oddCOM({L1},34,sub))))
</RetrievalCode>
</Data>
<Data name="IncludeCode">
<RetrievalCode> s {IncludeCode}=$s($d(^oddCOM({L1},35))#2:^(35),1:$s($d(^oddDEF({L1},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="IncludeCodeAll">
<RetrievalCode> n sub s {IncludeCodeAll}="",sub="" f  s sub=$o(^oddCOM({L1},36,sub)) q:sub=""  s {IncludeCodeAll}={IncludeCodeAll}_$lb($lb(sub,$g(^oddCOM({L1},36,sub))))
</RetrievalCode>
</Data>
<Data name="IncludeGenerator">
<RetrievalCode> s {IncludeGenerator}=$s($d(^oddCOM({L1},37))#2:^(37),1:$s($d(^oddDEF({L1},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="IncludeMGenAll">
<RetrievalCode> n sub s {IncludeMGenAll}="",sub="" f  s sub=$o(^oddCOM({L1},38,sub)) q:sub=""  s {IncludeMGenAll}={IncludeMGenAll}_$lb($lb(sub,$g(^oddCOM({L1},38,sub))))
</RetrievalCode>
</Data>
<Data name="IndexClass">
<RetrievalCode> s {IndexClass}=$s($d(^oddCOM({L1},81))#2:^(81),1:$s($d(^oddDEF({L1},81))#2:^(81),1:""))
</RetrievalCode>
</Data>
<Data name="Inheritance">
<RetrievalCode> s {Inheritance}=$s($d(^oddCOM({L1},92))#2:^(92),1:$s($d(^oddDEF({L1},92))#2:^(92),1:"left"))
</RetrievalCode>
</Data>
<Data name="InitialValue">
<RetrievalCode> s {InitialValue}=$s($d(^oddCOM({L1},94))#2:^(94),1:$s($d(^oddDEF({L1},94))#2:^(94),1:""))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},12))#2:^(12),1:$s($d(^oddDEF({L1},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},13))#2:^(13),1:$s($d(^oddDEF({L1},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="LegacyInstanceContext">
<RetrievalCode> s {LegacyInstanceContext}=$s($d(^oddCOM({L1},96))#2:^(96),1:$s($d(^oddDEF({L1},96))#2:^(96),1:0))
</RetrievalCode>
</Data>
<Data name="Manifest">
<RetrievalCode> n sub s {Manifest}="",sub="" f  s sub=$o(^oddCOM({L1},103,sub)) q:sub=""  s {Manifest}={Manifest}_$lb($lb(sub,$g(^oddCOM({L1},103,sub))))
</RetrievalCode>
</Data>
<Data name="MemberSuper">
<RetrievalCode> s {MemberSuper}=$s($d(^oddCOM({L1},83))#2:^(83),1:$s($d(^oddDEF({L1},83))#2:^(83),1:""))
</RetrievalCode>
</Data>
<Data name="ModificationAuxiliary">
<RetrievalCode> s {ModificationAuxiliary}=$s($d(^oddCOM({L1},68))#2:^(68),1:$s($d(^oddDEF({L1},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="ModificationLevel">
<RetrievalCode> s {ModificationLevel}=$s($d(^oddCOM({L1},69))#2:^(69),1:$s($d(^oddDEF({L1},69))#2:^(69),1:9))
</RetrievalCode>
</Data>
<Data name="Modified">
<RetrievalCode> s {Modified}=$s($d(^oddCOM({L1},40))#2:^(40),1:$s($d(^oddDEF({L1},40))#2:^(40),1:3))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},42))#2:^(42),1:$s($d(^oddDEF({L1},42))#2:^(42),1:0))
</RetrievalCode>
</Data>
<Data name="NoExtent">
<RetrievalCode> s {NoExtent}=$s($d(^oddCOM({L1},76))#2:^(76),1:$s($d(^oddDEF({L1},76))#2:^(76),1:0))
</RetrievalCode>
</Data>
<Data name="OdbcType">
<RetrievalCode> s {OdbcType}=$s($d(^oddCOM({L1},43))#2:^(43),1:$s($d(^oddDEF({L1},43))#2:^(43),1:"VARCHAR"))
</RetrievalCode>
</Data>
<Data name="OldHash">
<RetrievalCode> s {OldHash}=$s($d(^oddCOM({L1},101))#2:^(101),1:$s($d(^oddDEF({L1},101))#2:^(101),1:""))
</RetrievalCode>
</Data>
<Data name="Owner">
<RetrievalCode> s {Owner}=$s($d(^oddCOM({L1},44))#2:^(44),1:$s($d(^oddDEF({L1},44))#2:^(44),1:""))
</RetrievalCode>
</Data>
<Data name="PrimarySuper">
<RetrievalCode> s {PrimarySuper}=$s($d(^oddCOM({L1},45))#2:^(45),1:$s($d(^oddDEF({L1},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},46))#2:^(46),1:$s($d(^oddDEF({L1},46))#2:^(46),1:1))
</RetrievalCode>
</Data>
<Data name="Procedures">
<RetrievalCode> n sub s {Procedures}="",sub="" f  s sub=$o(^oddCOM({L1},47,sub)) q:sub=""  s {Procedures}={Procedures}_$lb($lb(sub,$g(^oddCOM({L1},47,sub))))
</RetrievalCode>
</Data>
<Data name="ProjectionClass">
<RetrievalCode> s {ProjectionClass}=$s($d(^oddCOM({L1},82))#2:^(82),1:$s($d(^oddDEF({L1},82))#2:^(82),1:""))
</RetrievalCode>
</Data>
<Data name="PropertyClass">
<RetrievalCode> s {PropertyClass}=$s($d(^oddCOM({L1},48))#2:^(48),1:$s($d(^oddDEF({L1},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="QueryClass">
<RetrievalCode> s {QueryClass}=$s($d(^oddCOM({L1},79))#2:^(79),1:$s($d(^oddDEF({L1},79))#2:^(79),1:""))
</RetrievalCode>
</Data>
<Data name="RandomSig">
<RetrievalCode> s {RandomSig}=$s($d(^oddCOM({L1},102))#2:^(102),1:$s($d(^oddDEF({L1},102))#2:^(102),1:""))
</RetrievalCode>
</Data>
<Data name="RoutineCount">
<RetrievalCode> s {RoutineCount}=$s($d(^oddCOM({L1},49))#2:^(49),1:$s($d(^oddDEF({L1},49))#2:^(49),1:0))
</RetrievalCode>
</Data>
<Data name="Routines">
<RetrievalCode> n sub s {Routines}="",sub="" f  s sub=$o(^oddCOM({L1},50,sub)) q:sub=""  s {Routines}={Routines}_$lb($lb(sub,$g(^oddCOM({L1},50,sub))))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},88))#2:^(88),1:$s($d(^oddDEF({L1},88))#2:^(88),1:""))
</RetrievalCode>
</Data>
<Data name="SlotCount">
<RetrievalCode> s {SlotCount}=$s($d(^oddCOM({L1},51))#2:^(51),1:$s($d(^oddDEF({L1},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},70))#2:^(70),1:$s($d(^oddDEF({L1},70))#2:^(70),1:"document"))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},71))#2:^(71),1:$s($d(^oddDEF({L1},71))#2:^(71),1:"literal"))
</RetrievalCode>
</Data>
<Data name="SqlCategory">
<RetrievalCode> s {SqlCategory}=$s($d(^oddCOM({L1},52))#2:^(52),1:$s($d(^oddDEF({L1},52))#2:^(52),1:"STRING"))
</RetrievalCode>
</Data>
<Data name="SqlQualifiedNameQ">
<RetrievalCode> s {SqlQualifiedNameQ}=$s($d(^oddCOM({L1},53))#2:^(53),1:$s($d(^oddDEF({L1},53))#2:^(53),1:$g(^%qCacheObjectKey(1,"c",53))))
</RetrievalCode>
</Data>
<Data name="SqlRoutinePrefix">
<RetrievalCode> s {SqlRoutinePrefix}=$s($d(^oddCOM({L1},54))#2:^(54),1:$s($d(^oddDEF({L1},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SqlRowIdName">
<RetrievalCode> s {SqlRowIdName}=$s($d(^oddCOM({L1},55))#2:^(55),1:$s($d(^oddDEF({L1},55))#2:^(55),1:""))
</RetrievalCode>
</Data>
<Data name="SqlRowIdPrivate">
<RetrievalCode> s {SqlRowIdPrivate}=$s($d(^oddCOM({L1},56))#2:^(56),1:$s($d(^oddDEF({L1},56))#2:^(56),1:0))
</RetrievalCode>
</Data>
<Data name="SqlSchemaName">
<RetrievalCode> s {SqlSchemaName}=$s($d(^oddCOM({L1},57))#2:^(57),1:$s($d(^oddDEF({L1},57))#2:^(57),1:""))
</RetrievalCode>
</Data>
<Data name="SqlTableName">
<RetrievalCode> s {SqlTableName}=$s($d(^oddCOM({L1},58))#2:^(58),1:$s($d(^oddDEF({L1},58))#2:^(58),1:""))
</RetrievalCode>
</Data>
<Data name="StorageStrategy">
<RetrievalCode> s {StorageStrategy}=$s($d(^oddCOM({L1},59))#2:^(59),1:$s($d(^oddDEF({L1},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="Structure">
<RetrievalCode> s {Structure}=$s($d(^oddCOM({L1},90))#2:^(90),1:$s($d(^oddDEF({L1},90))#2:^(90),1:""))
</RetrievalCode>
</Data>
<Data name="Super">
<RetrievalCode> s {Super}=$s($d(^oddCOM({L1},60))#2:^(60),1:$s($d(^oddDEF({L1},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="System">
<RetrievalCode> s {System}=$s($d(^oddCOM({L1},61))#2:^(61),1:$s($d(^oddDEF({L1},61))#2:^(61),1:0))
</RetrievalCode>
</Data>
<Data name="Tables">
<RetrievalCode> n sub s {Tables}="",sub="" f  s sub=$o(^oddCOM({L1},62,sub)) q:sub=""  s {Tables}={Tables}_$lb($lb(sub,$g(^oddCOM({L1},62,sub))))
</RetrievalCode>
</Data>
<Data name="TimeChanged">
<RetrievalCode> s {TimeChanged}=$s($d(^oddCOM({L1},63))#2:^(63),1:$s($d(^oddDEF({L1},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="TimeCreated">
<RetrievalCode> s {TimeCreated}=$s($d(^oddCOM({L1},64))#2:^(64),1:$s($d(^oddDEF({L1},64))#2:^(64),1:""))
</RetrievalCode>
</Data>
<Data name="TriggerClass">
<RetrievalCode> s {TriggerClass}=$s($d(^oddCOM({L1},99))#2:^(99),1:$s($d(^oddDEF({L1},99))#2:^(99),1:""))
</RetrievalCode>
</Data>
<Data name="ViewQuery">
<RetrievalCode> s {ViewQuery}=$s($d(^oddCOM({L1},65))#2:^(65),1:$s($d(^oddDEF({L1},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="Views">
<RetrievalCode> n sub s {Views}="",sub="" f  s sub=$o(^oddCOM({L1},66,sub)) q:sub=""  s {Views}={Views}_$lb($lb(sub,$g(^oddCOM({L1},66,sub))))
</RetrievalCode>
</Data>
<Data name="XMLData">
<RetrievalCode> n sub s {XMLData}="",sub="" f  s sub=$o(^oddCOM({L1},85,sub)) q:sub=""  s {XMLData}={XMLData}_$lb($lb(sub,$g(^oddCOM({L1},85,sub))))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},39))#2:^(39),1:$s($d(^oddDEF({L1},39))#2:^(39),1:"cache"))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledClassQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Description><![CDATA[
The <b>Summary</b> query provides a summary of information about compiled classes contained in the 
<i>Cach&eacute Dictionary</i>.]]></Description>
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256):ClassName,Abstract:%Integer,System,Persistent,HasProperty:%Integer,Caption:%String(MAXLEN=256)"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s QHandle=$lb(0,"")
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n class,caption
 s AtEnd=$li(QHandle,1),class=$li(QHandle,2),Row=""
 i AtEnd q $$$OK
 s class=$$$comClassNext(class)
 While class'="",$$$defClassKeyGet(class,$$$cCLASSdeployed)=2 {
	 Set class=$$$comClassNext(class)
 }
 i class="" s AtEnd=1
 e  d  i $$$comClassNext(class)="" s AtEnd=1
 . s Row=$lb(class)
 . s Row=Row_$lb($$$comClassKeyGet(class,$$$cCLASSabstract))
 . s Row=Row_$lb($$$comClassKeyGet(class,$$$cCLASSsystem))
 . s Row=Row_$lb($$$getClassType(class)=$$$cCLASSCLASSTYPEPERSISTENT)
 . s Row=Row_$lb(''$$$comClassKeyDefined(class,$$$cCLASSproperty))
 . s caption=$$$comMemberKeyGet(class,$$$cCLASSparameter,"CAPTION",$$$cPARAMdefault)
 . i caption="" s caption=class
 . s Row=Row_$lb(caption)
 s QHandle=$lb(AtEnd,class)
 q $$$OK
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s QHandle=""
 Quit $$$OK
]]></Implementation>
</Method>

<Query name="MemberSummary">
<Type>%Query</Type>
<FormalSpec>classname:%String,kind:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String(MAXLEN=256)"/>
</Query>

<Method name="MemberSummaryExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String,kind:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s classname=$$$NormalizeClassname(classname)
 s QHandle=$lb(0,classname,kind,"")
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="MemberSummaryFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 n classname,kind,element
 s AtEnd=$li(QHandle,1),classname=$li(QHandle,2),kind=$li(QHandle,3),element=$li(QHandle,4),Row=""
 i AtEnd q $$$OK
 s element=$$$comMemberNext(classname,kind,element)
 i element="" s AtEnd=1
 e  s Row=$lb(element) i $$$comMemberNext(classname,kind,element)="" s AtEnd=1
 s QHandle=$lb(AtEnd,classname,kind,element)
 q $$$OK
]]></Implementation>
</Method>

<Method name="MemberSummaryClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s QHandle=""
 Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledConstraint">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledConstraintQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.414494</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Constraints</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Category">
<Description>
Specifies the type of constraint.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Deferrable">
<Description>
Deferrable</Description>
<Type>%Boolean</Type>
<SqlFieldName>_Deferrable</SqlFieldName>
</Property>

<Property name="Deprecated">
<Description>
True if this constraint is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Final">
<Description>
Final</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description>
Specifies the list of arguments that are passed to the constraint.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GeneratedFrom">
<Description>
Specifies the name of the class member from which this constraint is generated, member type depends on the value of the Category keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Initialmode">
<Description>
Initialmode</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.CompiledConstraintMethod</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="SqlName">
<Description>
SqlName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Type</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSconstraint,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSconstraint,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Category=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONScategory)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONScompilergenerated)
 . s i%Deferrable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSdeferrable)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSdeprecated)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSfinal)
 . s i%FormalSpec=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSformalspec)
 . s i%FormalSpecParsed=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSformalspecparsed)
 . s i%GeneratedFrom=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSgeneratedfrom)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSinheritedid)
 . s i%Initialmode=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSinitialmode)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSorigin)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSsqlname)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONStype)
 . s sub="" f  s sub=$$$comSubMemberNext(name1,$$$cCLASSconstraint,name2,$$$cCONSparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$comMemberArrayGet(name1,$$$cCLASSconstraint,name2,$$$cCONSparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledConsEF5S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"n"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledConstraint.Name}</Expression>
</Subscript>
<Data name="Category">
<RetrievalCode> s {Category}=$s($d(^oddCOM({L1},"n",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"n",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},21))#2:^(21),1:"fkey"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"n",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"n",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"n",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"n",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"n",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"n",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},7))#2:^(7),1:1))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"n",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"n",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},25))#2:^(25),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"n",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"n",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="GeneratedFrom">
<RetrievalCode> s {GeneratedFrom}=$s($d(^oddCOM({L1},"n",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"n",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"n",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"n",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"n",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"n",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Initialmode">
<RetrievalCode> s {Initialmode}=$s($d(^oddCOM({L1},"n",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"n",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"n",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"n",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"n",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"n",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"n",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"n",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"n",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"n",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddCOM({L1},"n",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$s($d(^oddCOM({L1},"n",{L3},"P",sub))#2:^(sub),$d(^oddCOM($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},"P",sub))#2:^(sub),1:$g(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},"P",sub)))))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"n",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"n",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"n",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"n",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="_Deferrable">
<RetrievalCode> s {_Deferrable}=$s($d(^oddCOM({L1},"n",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"n",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},2),{L1}),"n",{L3},22))#2:^(22),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledConstraintMethod">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80420.988142</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledConstraint</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DefaultArgs">
<Description>
DefaultArgs</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalType">
<Description>
FormalType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Label">
<Description>
Label</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OptimizedMAC">
<Description>
OptimizedMAC</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OptimizedRun">
<Description>
OptimizedRun</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OriginalName">
<Description>
OriginalName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnLabel">
<Description>
RtnLabel</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Runnable">
<Description>
Runnable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeClient">
<Description>
RuntimeClient</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeCodeMode">
<Description>
CodeMode to use for generated methods</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeHash">
<Description>
RuntimeHash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeLanguage">
<Description>
RuntimeLanguage</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Stub">
<Description>
Stub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StubMember">
<Description>
StubMember</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Abstract=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHabstract)
 . s i%ClassMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHclientmethod)
 . s i%ClientName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHclientname)
 . s i%CodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHcodemode)
 . s i%CompilerGenerated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHcompilergenerated)
 . s i%DefaultArgs=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHdefaultargs)
 . s i%Deprecated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHdeprecated)
 . s i%Description=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHdescription)
 . s i%ExternalProcName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHexternalprocname)
 . s i%Final=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHfinal)
 . s i%ForceGenerate=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHformalspec)
 . s i%FormalSpecParsed=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHformalspecparsed)
 . s i%FormalType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHformaltype)
 . s i%GenerateAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHgenerateafter)
 . s i%Hash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHhash)
 . s i%Id=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHid)
 . s i%InheritedId=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHinheritedid)
 . s i%Internal=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHinternal)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHkeywordmodified)
 . s i%Label=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHlabel)
 . s i%Language=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHlanguage)
 . s i%NoContext=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHnocontext)
 . s i%NotForProperty=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHnotinheritable)
 . s i%OptimizedMAC=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHoptimizedmac)
 . s i%OptimizedRun=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHoptimizedrun)
 . s i%Origin=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHorigin)
 . s i%OriginalName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHoriginalname)
 . s i%PlaceAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHplaceafter)
 . s i%Private=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHprocedureblock)
 . s i%PublicList=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHreturntypeparams)
 . s i%RtnLabel=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHrtnlabel)
 . s i%Runnable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHrunnable)
 . s i%RuntimeClient=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHruntimeclient)
 . s i%RuntimeCodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHruntimecodemode)
 . s i%RuntimeHash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHruntimehash)
 . s i%RuntimeLanguage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHruntimelanguage)
 . s i%SequenceNumber=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHserveronly)
 . s i%SoapAction=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsqlname)
 . s i%SqlProc=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHsqlroutine)
 . s i%Stub=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHstub)
 . s i%StubMember=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHstubmember)
 . s i%TagGenerator=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHtaggenerator)
 . s i%UserActualType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHuseractualtype)
 . s i%WebMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$comSubMemberKeyGet(name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$comSubMemberArrayGet(name1,$$$cCLASSconstraint,name2,$$$cCONSmethod,name3,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledCon8688S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"n"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledConstraint.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledConstraintMethod.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},21))#2:^(21),$d(^oddCOM($g(^(2),"*"),"m",{L5},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"m",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},70))#2:^(70),$d(^oddCOM($g(^(2),"*"),"m",{L5},70))#2:^(70),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},70))#2:^(70),1:0))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},24))#2:^(24),$d(^oddCOM($g(^(2),"*"),"m",{L5},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},25))#2:^(25),$d(^oddCOM($g(^(2),"*"),"m",{L5},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},25))#2:^(25),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},10))#2:^(10),$d(^oddCOM($g(^(2),"*"),"m",{L5},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="DefaultArgs">
<RetrievalCode> s {DefaultArgs}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},26))#2:^(26),$d(^oddCOM($g(^(2),"*"),"m",{L5},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},17))#2:^(17),$d(^oddCOM($g(^(2),"*"),"m",{L5},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},4))#2:^(4),$d(^oddCOM($g(^(2),"*"),"m",{L5},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},63))#2:^(63),$d(^oddCOM($g(^(2),"*"),"m",{L5},63))#2:^(63),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},7))#2:^(7),$d(^oddCOM($g(^(2),"*"),"m",{L5},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},71))#2:^(71),$d(^oddCOM($g(^(2),"*"),"m",{L5},71))#2:^(71),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},71))#2:^(71),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},27))#2:^(27),$d(^oddCOM($g(^(2),"*"),"m",{L5},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},60))#2:^(60),$d(^oddCOM($g(^(2),"*"),"m",{L5},60))#2:^(60),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="FormalType">
<RetrievalCode> s {FormalType}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},28))#2:^(28),$d(^oddCOM($g(^(2),"*"),"m",{L5},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},29))#2:^(29),$d(^oddCOM($g(^(2),"*"),"m",{L5},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},66))#2:^(66),$d(^oddCOM($g(^(2),"*"),"m",{L5},66))#2:^(66),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},66))#2:^(66),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},6))#2:^(6),$d(^oddCOM($g(^(2),"*"),"m",{L5},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},8))#2:^(8),$d(^oddCOM($g(^(2),"*"),"m",{L5},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},14))#2:^(14),$d(^oddCOM($g(^(2),"*"),"m",{L5},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"m",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"m",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Label">
<RetrievalCode> s {Label}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},31))#2:^(31),$d(^oddCOM($g(^(2),"*"),"m",{L5},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},33))#2:^(33),$d(^oddCOM($g(^(2),"*"),"m",{L5},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},34))#2:^(34),$d(^oddCOM($g(^(2),"*"),"m",{L5},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},34))#2:^(34),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},9))#2:^(9),$d(^oddCOM($g(^(2),"*"),"m",{L5},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OptimizedMAC">
<RetrievalCode> s {OptimizedMAC}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},35))#2:^(35),$d(^oddCOM($g(^(2),"*"),"m",{L5},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="OptimizedRun">
<RetrievalCode> s {OptimizedRun}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},36))#2:^(36),$d(^oddCOM($g(^(2),"*"),"m",{L5},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},2))#2:^(2),$d(^oddCOM($g(^(2),"*"),"m",{L5},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="OriginalName">
<RetrievalCode> s {OriginalName}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},37))#2:^(37),$d(^oddCOM($g(^(2),"*"),"m",{L5},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},38))#2:^(38),$d(^oddCOM($g(^(2),"*"),"m",{L5},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},39))#2:^(39),$d(^oddCOM($g(^(2),"*"),"m",{L5},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},39))#2:^(39),1:0))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},40))#2:^(40),$d(^oddCOM($g(^(2),"*"),"m",{L5},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},41))#2:^(41),$d(^oddCOM($g(^(2),"*"),"m",{L5},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},64))#2:^(64),$d(^oddCOM($g(^(2),"*"),"m",{L5},64))#2:^(64),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},64))#2:^(64),1:0))
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},42))#2:^(42),$d(^oddCOM($g(^(2),"*"),"m",{L5},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},62))#2:^(62),$d(^oddCOM($g(^(2),"*"),"m",{L5},62))#2:^(62),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},62))#2:^(62),1:""))
</RetrievalCode>
</Data>
<Data name="RtnLabel">
<RetrievalCode> s {RtnLabel}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},43))#2:^(43),$d(^oddCOM($g(^(2),"*"),"m",{L5},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="Runnable">
<RetrievalCode> s {Runnable}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},44))#2:^(44),$d(^oddCOM($g(^(2),"*"),"m",{L5},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},44))#2:^(44),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeClient">
<RetrievalCode> s {RuntimeClient}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},55))#2:^(55),$d(^oddCOM($g(^(2),"*"),"m",{L5},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},55))#2:^(55),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeCodeMode">
<RetrievalCode> s {RuntimeCodeMode}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},56))#2:^(56),$d(^oddCOM($g(^(2),"*"),"m",{L5},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},56))#2:^(56),1:"code"))
</RetrievalCode>
</Data>
<Data name="RuntimeHash">
<RetrievalCode> s {RuntimeHash}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},69))#2:^(69),$d(^oddCOM($g(^(2),"*"),"m",{L5},69))#2:^(69),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},69))#2:^(69),1:""))
</RetrievalCode>
</Data>
<Data name="RuntimeLanguage">
<RetrievalCode> s {RuntimeLanguage}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},58))#2:^(58),$d(^oddCOM($g(^(2),"*"),"m",{L5},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},58))#2:^(58),1:"cache"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},11))#2:^(11),$d(^oddCOM($g(^(2),"*"),"m",{L5},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},59))#2:^(59),$d(^oddCOM($g(^(2),"*"),"m",{L5},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},67))#2:^(67),$d(^oddCOM($g(^(2),"*"),"m",{L5},67))#2:^(67),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},67))#2:^(67),1:"[default]"))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},53))#2:^(53),$d(^oddCOM($g(^(2),"*"),"m",{L5},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},53))#2:^(53),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},54))#2:^(54),$d(^oddCOM($g(^(2),"*"),"m",{L5},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},68))#2:^(68),$d(^oddCOM($g(^(2),"*"),"m",{L5},68))#2:^(68),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},61))#2:^(61),$d(^oddCOM($g(^(2),"*"),"m",{L5},61))#2:^(61),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},61))#2:^(61),1:""))
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},73))#2:^(73),$d(^oddCOM($g(^(2),"*"),"m",{L5},73))#2:^(73),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},65))#2:^(65),$d(^oddCOM($g(^(2),"*"),"m",{L5},65))#2:^(65),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},45))#2:^(45),$d(^oddCOM($g(^(2),"*"),"m",{L5},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},46))#2:^(46),$d(^oddCOM($g(^(2),"*"),"m",{L5},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},46))#2:^(46),1:0))
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},74))#2:^(74),$d(^oddCOM($g(^(2),"*"),"m",{L5},74))#2:^(74),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="Stub">
<RetrievalCode> s {Stub}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},47))#2:^(47),$d(^oddCOM($g(^(2),"*"),"m",{L5},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="StubMember">
<RetrievalCode> s {StubMember}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},72))#2:^(72),$d(^oddCOM($g(^(2),"*"),"m",{L5},72))#2:^(72),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},72))#2:^(72),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},48))#2:^(48),$d(^oddCOM($g(^(2),"*"),"m",{L5},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},50))#2:^(50),$d(^oddCOM($g(^(2),"*"),"m",{L5},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},50))#2:^(50),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},51))#2:^(51),$d(^oddCOM($g(^(2),"*"),"m",{L5},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},52))#2:^(52),$d(^oddCOM($g(^(2),"*"),"m",{L5},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"n",{L3},"m",{L5},32))#2:^(32),$d(^oddCOM($g(^(2),"*"),"m",{L5},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"n",{L3},"m",{L5},2),"*"),"m",{L5},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledConstraintQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSconstraint)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledForeignKey">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledForeignKeyQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.411445</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>ForeignKeys</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this foreign key is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Supplies a description of the foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Final</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Defines a name for the key. It must be a valid class member name and must not conflict with any existing member name.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoCheck">
<Description>
NoCheck</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OnDelete">
<Description>
Specifies what referential action to take when the key value is deleted from the foreign table.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OnUpdate">
<Description>
Specifies what referential action to take when the key value is updated in the foreign table.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Properties">
<Description>
Specifies one or more properties whose values are used to constrain the value of the foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReferencedClass">
<Description>
Specifies the name of the class containing the key referred to by this foreign key definition.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReferencedKey">
<Description>
Specifies the key name of a unique index within a class that provides the set of allowed values for this foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="SqlName">
<Description>
Specifies an alternate name for this foreign key when referred to via SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSfkey,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSfkey,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYcompilergenerated)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYdescription)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYfinal)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYkeywordmodified)
 . s i%NoCheck=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYnotinheritable)
 . s i%OnDelete=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYondelete)
 . s i%OnUpdate=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYorigin)
 . s i%Properties=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYproperties)
 . s i%ReferencedClass=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass)
 . s i%ReferencedKey=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledFor23F8S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"f"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledForeignKey.Name}</Expression>
</Subscript>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"f",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"f",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"f",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"f",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"f",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"f",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"f",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"f",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},7))#2:^(7),1:1))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"f",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"f",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"f",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"f",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"f",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"f",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"f",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"f",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"f",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"f",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NoCheck">
<RetrievalCode> s {NoCheck}=$s($d(^oddCOM({L1},"f",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"f",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},27))#2:^(27),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"f",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"f",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OnDelete">
<RetrievalCode> s {OnDelete}=$s($d(^oddCOM({L1},"f",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"f",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},21))#2:^(21),1:"noaction"))
</RetrievalCode>
</Data>
<Data name="OnUpdate">
<RetrievalCode> s {OnUpdate}=$s($d(^oddCOM({L1},"f",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"f",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},22))#2:^(22),1:"noaction"))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"f",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"f",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Properties">
<RetrievalCode> s {Properties}=$s($d(^oddCOM({L1},"f",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"f",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="ReferencedClass">
<RetrievalCode> s {ReferencedClass}=$s($d(^oddCOM({L1},"f",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"f",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="ReferencedKey">
<RetrievalCode> s {ReferencedKey}=$s($d(^oddCOM({L1},"f",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"f",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},25))#2:^(25),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"f",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"f",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"f",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"f",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"f",{L3},2),{L1}),"f",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledForeignKeyQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSfkey)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledIndex">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledIndexQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.417926</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Indices</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="BuildPurge">
<Description>
BuildPurge</Description>
<Type>%Boolean</Type>
</Property>

<Property name="CompilationSignature">
<Description>
CompilationSignature</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Condition">
<Description>
In the case of a conditional index, specifies the condition that must be met for an entry to be included in the index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Specifies a list of properties whose values are to be stored within this index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this index is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Extent">
<Description>
An extent index is used to keep track of which object instances belong to a subclass. When using bitmap indices, then an extent index is automatically maintained and there is no need to define one.</Description>
<Type>%Boolean</Type>
<ClientName>_Extent</ClientName>
</Property>

<Property name="Final">
<Description>
Final</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="IdKey">
<Description>
Specifies that the property or properties defined for this index will be used to form the Object Identity value for this object. This value is used to uniquely locate persistent object instances. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.CompiledIndexMethod</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Name">
<Description>
The name of the index.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="PosInt">
<Description>
PosInt</Description>
<Type>%Boolean</Type>
</Property>

<Property name="PrimaryKey">
<Description>
Specifies that this index should be reported, via SQL, as being the Primary Key for this class. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="Properties">
<Description>
Specifies a list of properties used to build this index. May also include a collation specification for each property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PropertyCollection">
<Description>
Property</Description>
<Type>%Dictionary.CompiledIndexProperty</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="SqlName">
<Description>
Defines an alternate name for this index when referred to via SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SystemAssigned">
<Description>
SystemAssigned</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Type">
<Description><![CDATA[
Specifies the type of the index. Type &#39;key&#39; is deprecated.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="TypeClass">
<Description>
Specifies the FunctionalIndex class used to provide the implementation of the functional index interface.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="Unique">
<Description>
Specifies whether this is a unique index.  The property or properties indexed by a unique index are constrained to have unique values.  This means that no two instances can have the same collated value within the extent among the set of all objects of the class that defines the index.</Description>
<Type>%Boolean</Type>
<SqlFieldName>_Unique</SqlFieldName>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSindex,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSindex,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%BuildPurge=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXbuildpurge)
 . s i%CompilationSignature=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXcompilationsignature)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXcompilergenerated)
 . s i%Condition=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXcondition)
 . s i%Data=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXdata)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXdescription)
 . s i%Extent=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXextent)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXfinal)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXid)
 . s i%IdKey=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXidkey)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXorigin)
 . s i%PosInt=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXposint)
 . s i%PrimaryKey=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey)
 . s i%Properties=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperties)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXsqlname)
 . s i%SystemAssigned=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXsystemassigned)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXtype)
 . s i%TypeClass=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass)
 . s i%Unique=$$$comMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXunique)
 . s sub="" f  s sub=$$$comSubMemberNext(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$comMemberArrayGet(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledIndexS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"i"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledIndex.Name}</Expression>
</Subscript>
<Data name="BuildPurge">
<RetrievalCode> s {BuildPurge}=$s($d(^oddCOM({L1},"i",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"i",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="CompilationSignature">
<RetrievalCode> s {CompilationSignature}=$s($d(^oddCOM({L1},"i",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"i",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"i",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"i",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Condition">
<RetrievalCode> s {Condition}=$s($d(^oddCOM({L1},"i",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"i",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="Data">
<RetrievalCode> s {Data}=$s($d(^oddCOM({L1},"i",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"i",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"i",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"i",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"i",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"i",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Extent">
<RetrievalCode> s {Extent}=$s($d(^oddCOM({L1},"i",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"i",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},25))#2:^(25),1:0))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"i",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"i",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},7))#2:^(7),1:1))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"i",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"i",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="IdKey">
<RetrievalCode> s {IdKey}=$s($d(^oddCOM({L1},"i",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"i",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},26))#2:^(26),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"i",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"i",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"i",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"i",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"i",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"i",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"i",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"i",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"i",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"i",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"i",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"i",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddCOM({L1},"i",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$s($d(^oddCOM({L1},"i",{L3},"P",sub))#2:^(sub),$d(^oddCOM($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},"P",sub))#2:^(sub),1:$g(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},"P",sub)))))
</RetrievalCode>
</Data>
<Data name="PosInt">
<RetrievalCode> s {PosInt}=$s($d(^oddCOM({L1},"i",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"i",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},32))#2:^(32),1:0))
</RetrievalCode>
</Data>
<Data name="PrimaryKey">
<RetrievalCode> s {PrimaryKey}=$s($d(^oddCOM({L1},"i",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"i",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},27))#2:^(27),1:0))
</RetrievalCode>
</Data>
<Data name="Properties">
<RetrievalCode> s {Properties}=$s($d(^oddCOM({L1},"i",{L3},28))#2:^(28),$d(^oddCOM($g(^(2),{L1}),"i",{L3},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"i",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"i",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"i",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"i",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="SystemAssigned">
<RetrievalCode> s {SystemAssigned}=$s($d(^oddCOM({L1},"i",{L3},30))#2:^(30),$d(^oddCOM($g(^(2),{L1}),"i",{L3},30))#2:^(30),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},30))#2:^(30),1:0))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"i",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"i",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="TypeClass">
<RetrievalCode> s {TypeClass}=$s($d(^oddCOM({L1},"i",{L3},33))#2:^(33),$d(^oddCOM($g(^(2),{L1}),"i",{L3},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},33))#2:^(33),1:""))
</RetrievalCode>
</Data>
<Data name="_Unique">
<RetrievalCode> s {_Unique}=$s($d(^oddCOM({L1},"i",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"i",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},2),{L1}),"i",{L3},31))#2:^(31),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledIndexMethod">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.010259</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledIndex</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DefaultArgs">
<Description>
DefaultArgs</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalType">
<Description>
FormalType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Label">
<Description>
Label</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OptimizedMAC">
<Description>
OptimizedMAC</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OptimizedRun">
<Description>
OptimizedRun</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OriginalName">
<Description>
OriginalName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnLabel">
<Description>
RtnLabel</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Runnable">
<Description>
Runnable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeClient">
<Description>
RuntimeClient</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeCodeMode">
<Description>
CodeMode to use for generated methods</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeHash">
<Description>
RuntimeHash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeLanguage">
<Description>
RuntimeLanguage</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Stub">
<Description>
Stub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StubMember">
<Description>
StubMember</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Abstract=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHabstract)
 . s i%ClassMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHclientmethod)
 . s i%ClientName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHclientname)
 . s i%CodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHcodemode)
 . s i%CompilerGenerated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHcompilergenerated)
 . s i%DefaultArgs=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHdefaultargs)
 . s i%Deprecated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHdeprecated)
 . s i%Description=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHdescription)
 . s i%ExternalProcName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHexternalprocname)
 . s i%Final=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHfinal)
 . s i%ForceGenerate=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHformalspec)
 . s i%FormalSpecParsed=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHformalspecparsed)
 . s i%FormalType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHformaltype)
 . s i%GenerateAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHgenerateafter)
 . s i%Hash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHhash)
 . s i%Id=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHid)
 . s i%InheritedId=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHinheritedid)
 . s i%Internal=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHinternal)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHkeywordmodified)
 . s i%Label=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHlabel)
 . s i%Language=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHlanguage)
 . s i%NoContext=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHnocontext)
 . s i%NotForProperty=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHnotinheritable)
 . s i%OptimizedMAC=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHoptimizedmac)
 . s i%OptimizedRun=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHoptimizedrun)
 . s i%Origin=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHorigin)
 . s i%OriginalName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHoriginalname)
 . s i%PlaceAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHplaceafter)
 . s i%Private=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHprocedureblock)
 . s i%PublicList=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHreturntypeparams)
 . s i%RtnLabel=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHrtnlabel)
 . s i%Runnable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHrunnable)
 . s i%RuntimeClient=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHruntimeclient)
 . s i%RuntimeCodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHruntimecodemode)
 . s i%RuntimeHash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHruntimehash)
 . s i%RuntimeLanguage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHruntimelanguage)
 . s i%SequenceNumber=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHserveronly)
 . s i%SoapAction=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsqlname)
 . s i%SqlProc=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHsqlroutine)
 . s i%Stub=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHstub)
 . s i%StubMember=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHstubmember)
 . s i%TagGenerator=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHtaggenerator)
 . s i%UserActualType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHuseractualtype)
 . s i%WebMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$comSubMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$comSubMemberArrayGet(name1,$$$cCLASSindex,name2,$$$cINDEXmethod,name3,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledInd6594S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"i"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledIndex.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledIndexMethod.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},21))#2:^(21),$d(^oddCOM($g(^(2),"*"),"m",{L5},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"m",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},70))#2:^(70),$d(^oddCOM($g(^(2),"*"),"m",{L5},70))#2:^(70),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},70))#2:^(70),1:0))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},24))#2:^(24),$d(^oddCOM($g(^(2),"*"),"m",{L5},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},25))#2:^(25),$d(^oddCOM($g(^(2),"*"),"m",{L5},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},25))#2:^(25),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},10))#2:^(10),$d(^oddCOM($g(^(2),"*"),"m",{L5},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="DefaultArgs">
<RetrievalCode> s {DefaultArgs}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},26))#2:^(26),$d(^oddCOM($g(^(2),"*"),"m",{L5},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},17))#2:^(17),$d(^oddCOM($g(^(2),"*"),"m",{L5},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},4))#2:^(4),$d(^oddCOM($g(^(2),"*"),"m",{L5},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},63))#2:^(63),$d(^oddCOM($g(^(2),"*"),"m",{L5},63))#2:^(63),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},7))#2:^(7),$d(^oddCOM($g(^(2),"*"),"m",{L5},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},71))#2:^(71),$d(^oddCOM($g(^(2),"*"),"m",{L5},71))#2:^(71),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},71))#2:^(71),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},27))#2:^(27),$d(^oddCOM($g(^(2),"*"),"m",{L5},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},60))#2:^(60),$d(^oddCOM($g(^(2),"*"),"m",{L5},60))#2:^(60),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="FormalType">
<RetrievalCode> s {FormalType}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},28))#2:^(28),$d(^oddCOM($g(^(2),"*"),"m",{L5},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},29))#2:^(29),$d(^oddCOM($g(^(2),"*"),"m",{L5},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},66))#2:^(66),$d(^oddCOM($g(^(2),"*"),"m",{L5},66))#2:^(66),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},66))#2:^(66),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},6))#2:^(6),$d(^oddCOM($g(^(2),"*"),"m",{L5},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},8))#2:^(8),$d(^oddCOM($g(^(2),"*"),"m",{L5},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},14))#2:^(14),$d(^oddCOM($g(^(2),"*"),"m",{L5},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"m",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"m",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Label">
<RetrievalCode> s {Label}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},31))#2:^(31),$d(^oddCOM($g(^(2),"*"),"m",{L5},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},33))#2:^(33),$d(^oddCOM($g(^(2),"*"),"m",{L5},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},34))#2:^(34),$d(^oddCOM($g(^(2),"*"),"m",{L5},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},34))#2:^(34),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},9))#2:^(9),$d(^oddCOM($g(^(2),"*"),"m",{L5},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OptimizedMAC">
<RetrievalCode> s {OptimizedMAC}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},35))#2:^(35),$d(^oddCOM($g(^(2),"*"),"m",{L5},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="OptimizedRun">
<RetrievalCode> s {OptimizedRun}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},36))#2:^(36),$d(^oddCOM($g(^(2),"*"),"m",{L5},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},2))#2:^(2),$d(^oddCOM($g(^(2),"*"),"m",{L5},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="OriginalName">
<RetrievalCode> s {OriginalName}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},37))#2:^(37),$d(^oddCOM($g(^(2),"*"),"m",{L5},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},38))#2:^(38),$d(^oddCOM($g(^(2),"*"),"m",{L5},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},39))#2:^(39),$d(^oddCOM($g(^(2),"*"),"m",{L5},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},39))#2:^(39),1:0))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},40))#2:^(40),$d(^oddCOM($g(^(2),"*"),"m",{L5},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},41))#2:^(41),$d(^oddCOM($g(^(2),"*"),"m",{L5},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},64))#2:^(64),$d(^oddCOM($g(^(2),"*"),"m",{L5},64))#2:^(64),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},64))#2:^(64),1:0))
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},42))#2:^(42),$d(^oddCOM($g(^(2),"*"),"m",{L5},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},62))#2:^(62),$d(^oddCOM($g(^(2),"*"),"m",{L5},62))#2:^(62),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},62))#2:^(62),1:""))
</RetrievalCode>
</Data>
<Data name="RtnLabel">
<RetrievalCode> s {RtnLabel}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},43))#2:^(43),$d(^oddCOM($g(^(2),"*"),"m",{L5},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="Runnable">
<RetrievalCode> s {Runnable}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},44))#2:^(44),$d(^oddCOM($g(^(2),"*"),"m",{L5},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},44))#2:^(44),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeClient">
<RetrievalCode> s {RuntimeClient}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},55))#2:^(55),$d(^oddCOM($g(^(2),"*"),"m",{L5},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},55))#2:^(55),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeCodeMode">
<RetrievalCode> s {RuntimeCodeMode}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},56))#2:^(56),$d(^oddCOM($g(^(2),"*"),"m",{L5},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},56))#2:^(56),1:"code"))
</RetrievalCode>
</Data>
<Data name="RuntimeHash">
<RetrievalCode> s {RuntimeHash}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},69))#2:^(69),$d(^oddCOM($g(^(2),"*"),"m",{L5},69))#2:^(69),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},69))#2:^(69),1:""))
</RetrievalCode>
</Data>
<Data name="RuntimeLanguage">
<RetrievalCode> s {RuntimeLanguage}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},58))#2:^(58),$d(^oddCOM($g(^(2),"*"),"m",{L5},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},58))#2:^(58),1:"cache"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},11))#2:^(11),$d(^oddCOM($g(^(2),"*"),"m",{L5},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},59))#2:^(59),$d(^oddCOM($g(^(2),"*"),"m",{L5},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},67))#2:^(67),$d(^oddCOM($g(^(2),"*"),"m",{L5},67))#2:^(67),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},67))#2:^(67),1:"[default]"))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},53))#2:^(53),$d(^oddCOM($g(^(2),"*"),"m",{L5},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},53))#2:^(53),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},54))#2:^(54),$d(^oddCOM($g(^(2),"*"),"m",{L5},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},68))#2:^(68),$d(^oddCOM($g(^(2),"*"),"m",{L5},68))#2:^(68),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},61))#2:^(61),$d(^oddCOM($g(^(2),"*"),"m",{L5},61))#2:^(61),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},61))#2:^(61),1:""))
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},73))#2:^(73),$d(^oddCOM($g(^(2),"*"),"m",{L5},73))#2:^(73),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},65))#2:^(65),$d(^oddCOM($g(^(2),"*"),"m",{L5},65))#2:^(65),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},45))#2:^(45),$d(^oddCOM($g(^(2),"*"),"m",{L5},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},46))#2:^(46),$d(^oddCOM($g(^(2),"*"),"m",{L5},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},46))#2:^(46),1:0))
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},74))#2:^(74),$d(^oddCOM($g(^(2),"*"),"m",{L5},74))#2:^(74),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="Stub">
<RetrievalCode> s {Stub}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},47))#2:^(47),$d(^oddCOM($g(^(2),"*"),"m",{L5},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="StubMember">
<RetrievalCode> s {StubMember}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},72))#2:^(72),$d(^oddCOM($g(^(2),"*"),"m",{L5},72))#2:^(72),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},72))#2:^(72),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},48))#2:^(48),$d(^oddCOM($g(^(2),"*"),"m",{L5},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},50))#2:^(50),$d(^oddCOM($g(^(2),"*"),"m",{L5},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},50))#2:^(50),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},51))#2:^(51),$d(^oddCOM($g(^(2),"*"),"m",{L5},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},52))#2:^(52),$d(^oddCOM($g(^(2),"*"),"m",{L5},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"i",{L3},"m",{L5},32))#2:^(32),$d(^oddCOM($g(^(2),"*"),"m",{L5},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"m",{L5},2),"*"),"m",{L5},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledIndexProperty">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80420.962122</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledIndex</Type>
<Cardinality>parent</Cardinality>
<Inverse>PropertyCollection</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Collation">
<Description>
Collation</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CollationParms">
<Description>
CollationParms</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Property">
<Description>
Property</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Collation=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3,$$$cINDEXPROPcollation)
 . s i%CollationParms=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3,$$$cINDEXPROPcollationparms)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3,$$$cINDEXPROPkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3,$$$cINDEXPROPkeywordmodified)
 . s i%Property=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSindex,name2,$$$cINDEXproperty,name3,$$$cINDEXPROPproperty)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledInd682ES</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"i"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledIndex.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"I"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledIndexProperty.Name}</Expression>
</Subscript>
<Data name="Collation">
<RetrievalCode> s {Collation}=$s($d(^oddCOM({L1},"i",{L3},"I",{L5},21))#2:^(21),$d(^oddCOM($g(^(2),"*"),"I",{L5},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"I",{L5},2),"*"),"I",{L5},21))#2:^(21),1:""))
</RetrievalCode>
</Data>
<Data name="CollationParms">
<RetrievalCode> s {CollationParms}=$s($d(^oddCOM({L1},"i",{L3},"I",{L5},22))#2:^(22),$d(^oddCOM($g(^(2),"*"),"I",{L5},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"I",{L5},2),"*"),"I",{L5},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"i",{L3},"I",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"I",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"I",{L5},2),"*"),"I",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"i",{L3},"I",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"I",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"I",{L5},2),"*"),"I",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Property">
<RetrievalCode> s {Property}=$s($d(^oddCOM({L1},"i",{L3},"I",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"I",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"i",{L3},"I",{L5},2),"*"),"I",{L5},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledIndexQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSindex)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledInstanceVar">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledInstanceVarQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.421304</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>InstanceVars</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="InitialExpression">
<Description>
InitialExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ModifiedBit">
<Description>
ModifiedBit</Description>
<Type>%Integer</Type>
</Property>

<Property name="MultiDimensional">
<Description>
MultiDimensional</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSinstancevar,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSinstancevar,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARcompilergenerated)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARinheritedid)
 . s i%InitialExpression=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARinitialexpression)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARkeywordmodified)
 . s i%ModifiedBit=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARmodifiedbit)
 . s i%MultiDimensional=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARmultidimensional)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSinstancevar,name2,$$$cIVARorigin)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledIns9959S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"v"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledInstanceVar.Name}</Expression>
</Subscript>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"v",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"v",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"v",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"v",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"v",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"v",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="InitialExpression">
<RetrievalCode> s {InitialExpression}=$s($d(^oddCOM({L1},"v",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"v",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},21))#2:^(21),1:""""""))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"v",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"v",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"v",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"v",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="ModifiedBit">
<RetrievalCode> s {ModifiedBit}=$s($d(^oddCOM({L1},"v",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"v",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},22))#2:^(22),1:0))
</RetrievalCode>
</Data>
<Data name="MultiDimensional">
<RetrievalCode> s {MultiDimensional}=$s($d(^oddCOM({L1},"v",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"v",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"v",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"v",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"v",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"v",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"v",{L3},2),{L1}),"v",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledInstanceVarQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSinstancevar)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledMethod">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledMethodQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.474169</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DefaultArgs">
<Description>
DefaultArgs</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalType">
<Description>
FormalType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Label">
<Description>
Label</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OptimizedMAC">
<Description>
OptimizedMAC</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OptimizedRun">
<Description>
OptimizedRun</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OriginalName">
<Description>
OriginalName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnLabel">
<Description>
RtnLabel</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Runnable">
<Description>
Runnable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeClient">
<Description>
RuntimeClient</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeCodeMode">
<Description>
CodeMode to use for generated methods</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeHash">
<Description>
RuntimeHash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeLanguage">
<Description>
RuntimeLanguage</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Stub">
<Description>
Stub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StubMember">
<Description>
StubMember</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSmethod,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSmethod,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Abstract=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHabstract)
 . s i%ClassMethod=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod)
 . s i%ClientName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHclientname)
 . s i%CodeMode=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHcodemode)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHcompilergenerated)
 . s i%DefaultArgs=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHdefaultargs)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHdescription)
 . s i%ExternalProcName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHfinal)
 . s i%ForceGenerate=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHformalspec)
 . s i%FormalSpecParsed=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHformalspecparsed)
 . s i%FormalType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHformaltype)
 . s i%GenerateAfter=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter)
 . s i%Hash=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHhash)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHkeywordmodified)
 . s i%Label=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHlabel)
 . s i%Language=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHlanguage)
 . s i%NoContext=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHnocontext)
 . s i%NotForProperty=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable)
 . s i%OptimizedMAC=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHoptimizedmac)
 . s i%OptimizedRun=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHoptimizedrun)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHorigin)
 . s i%OriginalName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHoriginalname)
 . s i%PlaceAfter=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter)
 . s i%Private=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock)
 . s i%PublicList=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams)
 . s i%RtnLabel=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHrtnlabel)
 . s i%Runnable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHrunnable)
 . s i%RuntimeClient=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHruntimeclient)
 . s i%RuntimeCodeMode=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHruntimecodemode)
 . s i%RuntimeHash=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHruntimehash)
 . s i%RuntimeLanguage=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHruntimelanguage)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHserveronly)
 . s i%SoapAction=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsqlname)
 . s i%SqlProc=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine)
 . s i%Stub=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHstub)
 . s i%StubMember=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHstubmember)
 . s i%TagGenerator=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHtaggenerator)
 . s i%UserActualType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHuseractualtype)
 . s i%WebMethod=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$comMemberKeyGetO(origin,name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$comMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$comMemberArrayGet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledMethodS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledMethod.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"m",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"m",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddCOM({L1},"m",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"m",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddCOM({L1},"m",{L3},70))#2:^(70),$d(^oddCOM($g(^(2),{L1}),"m",{L3},70))#2:^(70),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},70))#2:^(70),1:0))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"m",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"m",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"m",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"m",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},25))#2:^(25),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"m",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"m",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="DefaultArgs">
<RetrievalCode> s {DefaultArgs}=$s($d(^oddCOM({L1},"m",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"m",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"m",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"m",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"m",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"m",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddCOM({L1},"m",{L3},63))#2:^(63),$d(^oddCOM($g(^(2),{L1}),"m",{L3},63))#2:^(63),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"m",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"m",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddCOM({L1},"m",{L3},71))#2:^(71),$d(^oddCOM($g(^(2),{L1}),"m",{L3},71))#2:^(71),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},71))#2:^(71),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"m",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"m",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"m",{L3},60))#2:^(60),$d(^oddCOM($g(^(2),{L1}),"m",{L3},60))#2:^(60),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="FormalType">
<RetrievalCode> s {FormalType}=$s($d(^oddCOM({L1},"m",{L3},28))#2:^(28),$d(^oddCOM($g(^(2),{L1}),"m",{L3},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddCOM({L1},"m",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"m",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},"m",{L3},66))#2:^(66),$d(^oddCOM($g(^(2),{L1}),"m",{L3},66))#2:^(66),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},66))#2:^(66),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"m",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"m",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"m",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"m",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"m",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"m",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"m",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"m",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"m",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"m",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Label">
<RetrievalCode> s {Label}=$s($d(^oddCOM({L1},"m",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"m",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},"m",{L3},33))#2:^(33),$d(^oddCOM($g(^(2),{L1}),"m",{L3},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddCOM({L1},"m",{L3},34))#2:^(34),$d(^oddCOM($g(^(2),{L1}),"m",{L3},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},34))#2:^(34),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"m",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"m",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OptimizedMAC">
<RetrievalCode> s {OptimizedMAC}=$s($d(^oddCOM({L1},"m",{L3},35))#2:^(35),$d(^oddCOM($g(^(2),{L1}),"m",{L3},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="OptimizedRun">
<RetrievalCode> s {OptimizedRun}=$s($d(^oddCOM({L1},"m",{L3},36))#2:^(36),$d(^oddCOM($g(^(2),{L1}),"m",{L3},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"m",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"m",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="OriginalName">
<RetrievalCode> s {OriginalName}=$s($d(^oddCOM({L1},"m",{L3},37))#2:^(37),$d(^oddCOM($g(^(2),{L1}),"m",{L3},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddCOM({L1},"m",{L3},38))#2:^(38),$d(^oddCOM($g(^(2),{L1}),"m",{L3},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"m",{L3},39))#2:^(39),$d(^oddCOM($g(^(2),{L1}),"m",{L3},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},39))#2:^(39),1:0))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},"m",{L3},40))#2:^(40),$d(^oddCOM($g(^(2),{L1}),"m",{L3},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddCOM({L1},"m",{L3},41))#2:^(41),$d(^oddCOM($g(^(2),{L1}),"m",{L3},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddCOM({L1},"m",{L3},64))#2:^(64),$d(^oddCOM($g(^(2),{L1}),"m",{L3},64))#2:^(64),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},64))#2:^(64),1:0))
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddCOM({L1},"m",{L3},42))#2:^(42),$d(^oddCOM($g(^(2),{L1}),"m",{L3},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddCOM({L1},"m",{L3},62))#2:^(62),$d(^oddCOM($g(^(2),{L1}),"m",{L3},62))#2:^(62),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},62))#2:^(62),1:""))
</RetrievalCode>
</Data>
<Data name="RtnLabel">
<RetrievalCode> s {RtnLabel}=$s($d(^oddCOM({L1},"m",{L3},43))#2:^(43),$d(^oddCOM($g(^(2),{L1}),"m",{L3},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="Runnable">
<RetrievalCode> s {Runnable}=$s($d(^oddCOM({L1},"m",{L3},44))#2:^(44),$d(^oddCOM($g(^(2),{L1}),"m",{L3},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},44))#2:^(44),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeClient">
<RetrievalCode> s {RuntimeClient}=$s($d(^oddCOM({L1},"m",{L3},55))#2:^(55),$d(^oddCOM($g(^(2),{L1}),"m",{L3},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},55))#2:^(55),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeCodeMode">
<RetrievalCode> s {RuntimeCodeMode}=$s($d(^oddCOM({L1},"m",{L3},56))#2:^(56),$d(^oddCOM($g(^(2),{L1}),"m",{L3},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},56))#2:^(56),1:"code"))
</RetrievalCode>
</Data>
<Data name="RuntimeHash">
<RetrievalCode> s {RuntimeHash}=$s($d(^oddCOM({L1},"m",{L3},69))#2:^(69),$d(^oddCOM($g(^(2),{L1}),"m",{L3},69))#2:^(69),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},69))#2:^(69),1:""))
</RetrievalCode>
</Data>
<Data name="RuntimeLanguage">
<RetrievalCode> s {RuntimeLanguage}=$s($d(^oddCOM({L1},"m",{L3},58))#2:^(58),$d(^oddCOM($g(^(2),{L1}),"m",{L3},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},58))#2:^(58),1:"cache"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"m",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"m",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"m",{L3},59))#2:^(59),$d(^oddCOM($g(^(2),{L1}),"m",{L3},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddCOM({L1},"m",{L3},67))#2:^(67),$d(^oddCOM($g(^(2),{L1}),"m",{L3},67))#2:^(67),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},67))#2:^(67),1:"[default]"))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"m",{L3},53))#2:^(53),$d(^oddCOM($g(^(2),{L1}),"m",{L3},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},53))#2:^(53),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"m",{L3},54))#2:^(54),$d(^oddCOM($g(^(2),{L1}),"m",{L3},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddCOM({L1},"m",{L3},68))#2:^(68),$d(^oddCOM($g(^(2),{L1}),"m",{L3},68))#2:^(68),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"m",{L3},61))#2:^(61),$d(^oddCOM($g(^(2),{L1}),"m",{L3},61))#2:^(61),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},61))#2:^(61),1:""))
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddCOM({L1},"m",{L3},73))#2:^(73),$d(^oddCOM($g(^(2),{L1}),"m",{L3},73))#2:^(73),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddCOM({L1},"m",{L3},65))#2:^(65),$d(^oddCOM($g(^(2),{L1}),"m",{L3},65))#2:^(65),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"m",{L3},45))#2:^(45),$d(^oddCOM($g(^(2),{L1}),"m",{L3},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"m",{L3},46))#2:^(46),$d(^oddCOM($g(^(2),{L1}),"m",{L3},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},46))#2:^(46),1:0))
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddCOM({L1},"m",{L3},74))#2:^(74),$d(^oddCOM($g(^(2),{L1}),"m",{L3},74))#2:^(74),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="Stub">
<RetrievalCode> s {Stub}=$s($d(^oddCOM({L1},"m",{L3},47))#2:^(47),$d(^oddCOM($g(^(2),{L1}),"m",{L3},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="StubMember">
<RetrievalCode> s {StubMember}=$s($d(^oddCOM({L1},"m",{L3},72))#2:^(72),$d(^oddCOM($g(^(2),{L1}),"m",{L3},72))#2:^(72),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},72))#2:^(72),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"m",{L3},48))#2:^(48),$d(^oddCOM($g(^(2),{L1}),"m",{L3},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"m",{L3},50))#2:^(50),$d(^oddCOM($g(^(2),{L1}),"m",{L3},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},50))#2:^(50),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"m",{L3},51))#2:^(51),$d(^oddCOM($g(^(2),{L1}),"m",{L3},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddCOM({L1},"m",{L3},52))#2:^(52),$d(^oddCOM($g(^(2),{L1}),"m",{L3},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"m",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"m",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"m",{L3},2),{L1}),"m",{L3},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledMethodQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSmethod)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledParameter">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledParameterQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.484281</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Parameters</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Abstract</Description>
<Type>%Boolean</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Constraint">
<Description>
Specifies a constraint value is used by Cache Studio to provide input validation for the parameter. Its value is not used nor enforced by the Class Compiler.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Constraint</SqlFieldName>
</Property>

<Property name="Default">
<Description>
Specifies a default value for the parameter assuming the Expression keyword is blank.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Default</SqlFieldName>
</Property>

<Property name="Deprecated">
<Description>
True if this parameter is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Encoded">
<Description>
If true then the parameter value is base64 encoded.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Expression">
<Description>
An expression to seed parameter with evaluated at compile time, if specified this takes precedence over the Default keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the parameter.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Flags">
<Description>
Specifies any additional modifier flags for the parameter type.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
The name of the parameter.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Specifies a type for the parameter. The type is used by Cache Studio to provide input validation for the parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSparameter,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSparameter,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Abstract=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMabstract)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMcompilergenerated)
 . s i%Constraint=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint)
 . s i%Default=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMdefault)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMdescription)
 . s i%Encoded=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMencoded)
 . s i%Expression=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMexpression)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMfinal)
 . s i%Flags=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMflags)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMorigin)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber)
 . s i%TagGenerator=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMtaggenerator)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSparameter,name2,$$$cPARAMtype)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledParameterS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"p"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledParameter.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"p",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"p",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},24))#2:^(24),1:0))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"p",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"p",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"p",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"p",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"p",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"p",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Encoded">
<RetrievalCode> s {Encoded}=$s($d(^oddCOM({L1},"p",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"p",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},27))#2:^(27),1:0))
</RetrievalCode>
</Data>
<Data name="Expression">
<RetrievalCode> s {Expression}=$s($d(^oddCOM({L1},"p",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"p",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},25))#2:^(25),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"p",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"p",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="Flags">
<RetrievalCode> s {Flags}=$s($d(^oddCOM({L1},"p",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"p",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"p",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"p",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"p",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"p",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"p",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"p",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"p",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"p",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"p",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"p",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"p",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"p",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"p",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"p",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"p",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"p",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"p",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"p",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"p",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"p",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="_Constraint">
<RetrievalCode> s {_Constraint}=$s($d(^oddCOM({L1},"p",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"p",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},21))#2:^(21),1:""))
</RetrievalCode>
</Data>
<Data name="_Default">
<RetrievalCode> s {_Default}=$s($d(^oddCOM({L1},"p",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"p",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"p",{L3},2),{L1}),"p",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledParameterQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSparameter)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledProjection">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledProjectionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.485783</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Projections</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Deprecated">
<Description>
True if this projection is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the projection.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
The name of the projection.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this projection is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="Type">
<Description>
Specifies the name of the class associated with the projection.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSprojection,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSprojection,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJdescription)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJorigin)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSprojection,name2,$$$cPROJtype)
 . s sub="" f  s sub=$$$comSubMemberNext(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$comMemberArrayGet(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledProDCA3S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"j"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledProjection.Name}</Expression>
</Subscript>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"j",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"j",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"j",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"j",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"j",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"j",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"j",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"j",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"j",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"j",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"j",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"j",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"j",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"j",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddCOM({L1},"j",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$s($d(^oddCOM({L1},"j",{L3},"P",sub))#2:^(sub),$d(^oddCOM($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},"P",sub))#2:^(sub),1:$g(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},"P",sub)))))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"j",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"j",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"j",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"j",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"j",{L3},2),{L1}),"j",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledProjectionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSprojection)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledProperty">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledPropertyQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.488513</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Properties</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Aliases">
<Description>
List of aliases for this property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Calculated">
<Description>
Specifies that the property has no in-memory storage allocated for it when the object containing it is instantiated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Cardinality">
<Description>
Specifies the cardinality of a relationship property. The Cardinality keyword is required for relationship properties. It is ignored by non-relationship properties. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Collection">
<Description>
Specifies that a property is a collection property as well as what type of collection it is.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ComputeDependency">
<Description>
List of properties referenced by the SQLCOMPUTECODE.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ComputeTriggers">
<Description>
List of properties to be computed when this property changes.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this property is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DirectRefOnGet">
<Description>
Deprecated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DirectRefOnSet">
<Description>
Deprecated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of this property.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Identity">
<Description>
Specifies that this property is the identity for this class. Identity properties can be set in new objects only and the default is set by incrementing a counter.</Description>
<Type>%Boolean</Type>
<SqlFieldName>_Identity</SqlFieldName>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="InitialExpression">
<Description>
Specifies an initial value for the property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Inverse">
<Description>
Specifies the name of the inverse side of a relationship. That is, the name of the corresponding relationship property in the related class. The inverse property must exist in the related class and have the correct Cardinality value. The Inverse keyword is required for relationship properties. It is ignored by non-relationship properties.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.CompiledPropertyMethod</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="MultiDimensional">
<Description>
Specifies that an attribute has the characteristics of a multidimensional array.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
The name of the property.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoModBit">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OnDelete">
<Description>
Specifies what referential action to take when the key value is deleted from the foreign table.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Private">
<Description>
Specifies that the property is private. Private properties can only be used by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReadOnly">
<Description>
Specifies that the property is readonly.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Relationship">
<Description>
Specifies that a property is a relationship property. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="Required">
<Description>
In the case of a persistent class, specifies that the value of the property must be given a value before it can be stored to disk.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeType">
<Description>
RuntimeType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a property will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlCollation">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlColumnNumber">
<Description>
Explicitly sets the SQL Column number for this property. This is provided for legacy application support.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputeCode">
<Description>
Specifies Cache ObjectScript code that evaluates to a computed field value. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputed">
<Description>
Specifies that this property is an SQL computed field.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlComputeOnChange">
<Description>
Specifies one or more properties whose modification triggers the recalculation of this computed field within SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlFieldName">
<Description>
In the case of a persistent class, specifies the column name used to identify the property in its SQL projection. By default, the SQL column name is the same as the property name.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlListDelimiter">
<Description>
Specifies the delimiter character used within SQL for lists. This is provided for legacy application support.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlListType">
<Description>
specifies the representation to be used for a list.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Storable">
<Description>
Storable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Transient">
<Description>
In the case of a persistent class, specifies that the property is not stored in the database.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Type">
<Description>
Specifies the name of the class associated with the property, which can be a data type class, a persistent class, or an embeddable serial class.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="UDLTexts">
<Description>
UDLText</Description>
<Type>%Dictionary.CompiledPropertyUDLText</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSproperty,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSproperty,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Aliases=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPaliases)
 . s i%Calculated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcalculated)
 . s i%Cardinality=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcardinality)
 . s i%ClientName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPclientname)
 . s i%Collection=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcollection)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcompilergenerated)
 . s i%ComputeDependency=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcomputedependency)
 . s i%ComputeTriggers=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPcomputetriggers)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPdescription)
 . s i%DirectRefOnGet=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPdirectrefonget)
 . s i%DirectRefOnSet=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPdirectrefonset)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPfinal)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPid)
 . s i%Identity=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPidentity)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPinheritedid)
 . s i%InitialExpression=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPinternal)
 . s i%Inverse=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPinverse)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPkeywordmodified)
 . s i%MultiDimensional=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional)
 . s i%NoModBit=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable)
 . s i%OnDelete=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPondelete)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPorigin)
 . s i%Private=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPprivate)
 . s i%ReadOnly=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPreadonly)
 . s i%Relationship=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPrelationship)
 . s i%Required=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPrequired)
 . s i%RuntimeType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPruntimetype)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber)
 . s i%ServerOnly=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPserveronly)
 . s i%SqlCollation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation)
 . s i%SqlColumnNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber)
 . s i%SqlComputeCode=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode)
 . s i%SqlComputed=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed)
 . s i%SqlComputeOnChange=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange)
 . s i%SqlFieldName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname)
 . s i%SqlListDelimiter=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter)
 . s i%SqlListType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype)
 . s i%Storable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPstorable)
 . s i%Transient=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPtransient)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPtype)
 . s sub="" f  s sub=$$$comSubMemberNext(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$comMemberArrayGet(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledPropertyS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"a"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledProperty.Name}</Expression>
</Subscript>
<Data name="Aliases">
<RetrievalCode> s {Aliases}=$s($d(^oddCOM({L1},"a",{L3},58))#2:^(58),$d(^oddCOM($g(^(2),{L1}),"a",{L3},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},58))#2:^(58),1:""))
</RetrievalCode>
</Data>
<Data name="Calculated">
<RetrievalCode> s {Calculated}=$s($d(^oddCOM({L1},"a",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"a",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="Cardinality">
<RetrievalCode> s {Cardinality}=$s($d(^oddCOM({L1},"a",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"a",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"a",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"a",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Collection">
<RetrievalCode> s {Collection}=$s($d(^oddCOM({L1},"a",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"a",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"a",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"a",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="ComputeDependency">
<RetrievalCode> s {ComputeDependency}=$s($d(^oddCOM({L1},"a",{L3},54))#2:^(54),$d(^oddCOM($g(^(2),{L1}),"a",{L3},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="ComputeTriggers">
<RetrievalCode> s {ComputeTriggers}=$s($d(^oddCOM({L1},"a",{L3},55))#2:^(55),$d(^oddCOM($g(^(2),{L1}),"a",{L3},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},55))#2:^(55),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"a",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"a",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"a",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"a",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="DirectRefOnGet">
<RetrievalCode> s {DirectRefOnGet}=$s($d(^oddCOM({L1},"a",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"a",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},29))#2:^(29),1:0))
</RetrievalCode>
</Data>
<Data name="DirectRefOnSet">
<RetrievalCode> s {DirectRefOnSet}=$s($d(^oddCOM({L1},"a",{L3},30))#2:^(30),$d(^oddCOM($g(^(2),{L1}),"a",{L3},30))#2:^(30),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},30))#2:^(30),1:0))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"a",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"a",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"a",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"a",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"a",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"a",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="InitialExpression">
<RetrievalCode> s {InitialExpression}=$s($d(^oddCOM({L1},"a",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"a",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},31))#2:^(31),1:""""""))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"a",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"a",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="Inverse">
<RetrievalCode> s {Inverse}=$s($d(^oddCOM({L1},"a",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"a",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"a",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"a",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"a",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"a",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="MultiDimensional">
<RetrievalCode> s {MultiDimensional}=$s($d(^oddCOM({L1},"a",{L3},33))#2:^(33),$d(^oddCOM($g(^(2),{L1}),"a",{L3},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NoModBit">
<RetrievalCode> s {NoModBit}=$s($d(^oddCOM({L1},"a",{L3},53))#2:^(53),$d(^oddCOM($g(^(2),{L1}),"a",{L3},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},53))#2:^(53),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"a",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"a",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OnDelete">
<RetrievalCode> s {OnDelete}=$s($d(^oddCOM({L1},"a",{L3},59))#2:^(59),$d(^oddCOM($g(^(2),{L1}),"a",{L3},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"a",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"a",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddCOM({L1},"a",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$s($d(^oddCOM({L1},"a",{L3},"P",sub))#2:^(sub),$d(^oddCOM($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},"P",sub))#2:^(sub),1:$g(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},"P",sub)))))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"a",{L3},35))#2:^(35),$d(^oddCOM($g(^(2),{L1}),"a",{L3},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},35))#2:^(35),1:0))
</RetrievalCode>
</Data>
<Data name="ReadOnly">
<RetrievalCode> s {ReadOnly}=$s($d(^oddCOM({L1},"a",{L3},52))#2:^(52),$d(^oddCOM($g(^(2),{L1}),"a",{L3},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="Relationship">
<RetrievalCode> s {Relationship}=$s($d(^oddCOM({L1},"a",{L3},36))#2:^(36),$d(^oddCOM($g(^(2),{L1}),"a",{L3},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},36))#2:^(36),1:0))
</RetrievalCode>
</Data>
<Data name="Required">
<RetrievalCode> s {Required}=$s($d(^oddCOM({L1},"a",{L3},37))#2:^(37),$d(^oddCOM($g(^(2),{L1}),"a",{L3},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},37))#2:^(37),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeType">
<RetrievalCode> s {RuntimeType}=$s($d(^oddCOM({L1},"a",{L3},40))#2:^(40),$d(^oddCOM($g(^(2),{L1}),"a",{L3},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"a",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"a",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"a",{L3},57))#2:^(57),$d(^oddCOM($g(^(2),{L1}),"a",{L3},57))#2:^(57),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},57))#2:^(57),1:""))
</RetrievalCode>
</Data>
<Data name="SqlCollation">
<RetrievalCode> s {SqlCollation}=$s($d(^oddCOM({L1},"a",{L3},42))#2:^(42),$d(^oddCOM($g(^(2),{L1}),"a",{L3},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="SqlColumnNumber">
<RetrievalCode> s {SqlColumnNumber}=$s($d(^oddCOM({L1},"a",{L3},43))#2:^(43),$d(^oddCOM($g(^(2),{L1}),"a",{L3},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="SqlComputeCode">
<RetrievalCode> s {SqlComputeCode}=$s($d(^oddCOM({L1},"a",{L3},44))#2:^(44),$d(^oddCOM($g(^(2),{L1}),"a",{L3},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},44))#2:^(44),1:""))
</RetrievalCode>
</Data>
<Data name="SqlComputeOnChange">
<RetrievalCode> s {SqlComputeOnChange}=$s($d(^oddCOM({L1},"a",{L3},46))#2:^(46),$d(^oddCOM($g(^(2),{L1}),"a",{L3},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},46))#2:^(46),1:""))
</RetrievalCode>
</Data>
<Data name="SqlComputed">
<RetrievalCode> s {SqlComputed}=$s($d(^oddCOM({L1},"a",{L3},45))#2:^(45),$d(^oddCOM($g(^(2),{L1}),"a",{L3},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},45))#2:^(45),1:0))
</RetrievalCode>
</Data>
<Data name="SqlFieldName">
<RetrievalCode> s {SqlFieldName}=$s($d(^oddCOM({L1},"a",{L3},47))#2:^(47),$d(^oddCOM($g(^(2),{L1}),"a",{L3},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="SqlListDelimiter">
<RetrievalCode> s {SqlListDelimiter}=$s($d(^oddCOM({L1},"a",{L3},48))#2:^(48),$d(^oddCOM($g(^(2),{L1}),"a",{L3},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="SqlListType">
<RetrievalCode> s {SqlListType}=$s($d(^oddCOM({L1},"a",{L3},49))#2:^(49),$d(^oddCOM($g(^(2),{L1}),"a",{L3},49))#2:^(49),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},49))#2:^(49),1:""))
</RetrievalCode>
</Data>
<Data name="Storable">
<RetrievalCode> s {Storable}=$s($d(^oddCOM({L1},"a",{L3},50))#2:^(50),$d(^oddCOM($g(^(2),{L1}),"a",{L3},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},50))#2:^(50),1:0))
</RetrievalCode>
</Data>
<Data name="Transient">
<RetrievalCode> s {Transient}=$s($d(^oddCOM({L1},"a",{L3},51))#2:^(51),$d(^oddCOM($g(^(2),{L1}),"a",{L3},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"a",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"a",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="_Identity">
<RetrievalCode> s {_Identity}=$s($d(^oddCOM({L1},"a",{L3},56))#2:^(56),$d(^oddCOM($g(^(2),{L1}),"a",{L3},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},2),{L1}),"a",{L3},56))#2:^(56),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledPropertyMethod">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80420.997269</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledProperty</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DefaultArgs">
<Description>
DefaultArgs</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalType">
<Description>
FormalType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Label">
<Description>
Label</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OptimizedMAC">
<Description>
OptimizedMAC</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OptimizedRun">
<Description>
OptimizedRun</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OriginalName">
<Description>
OriginalName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnLabel">
<Description>
RtnLabel</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Runnable">
<Description>
Runnable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeClient">
<Description>
RuntimeClient</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeCodeMode">
<Description>
CodeMode to use for generated methods</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeHash">
<Description>
RuntimeHash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeLanguage">
<Description>
RuntimeLanguage</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Stub">
<Description>
Stub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StubMember">
<Description>
StubMember</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Abstract=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHabstract)
 . s i%ClassMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHclientmethod)
 . s i%ClientName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHclientname)
 . s i%CodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHcodemode)
 . s i%CompilerGenerated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHcompilergenerated)
 . s i%DefaultArgs=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHdefaultargs)
 . s i%Deprecated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHdeprecated)
 . s i%Description=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHdescription)
 . s i%ExternalProcName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHexternalprocname)
 . s i%Final=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHfinal)
 . s i%ForceGenerate=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHformalspec)
 . s i%FormalSpecParsed=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHformalspecparsed)
 . s i%FormalType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHformaltype)
 . s i%GenerateAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHgenerateafter)
 . s i%Hash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHhash)
 . s i%Id=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHid)
 . s i%InheritedId=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHinheritedid)
 . s i%Internal=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHinternal)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHkeywordmodified)
 . s i%Label=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHlabel)
 . s i%Language=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHlanguage)
 . s i%NoContext=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHnocontext)
 . s i%NotForProperty=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHnotinheritable)
 . s i%OptimizedMAC=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHoptimizedmac)
 . s i%OptimizedRun=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHoptimizedrun)
 . s i%Origin=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHorigin)
 . s i%OriginalName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHoriginalname)
 . s i%PlaceAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHplaceafter)
 . s i%Private=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHprocedureblock)
 . s i%PublicList=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHreturntypeparams)
 . s i%RtnLabel=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHrtnlabel)
 . s i%Runnable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHrunnable)
 . s i%RuntimeClient=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHruntimeclient)
 . s i%RuntimeCodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHruntimecodemode)
 . s i%RuntimeHash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHruntimehash)
 . s i%RuntimeLanguage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHruntimelanguage)
 . s i%SequenceNumber=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHserveronly)
 . s i%SoapAction=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsqlname)
 . s i%SqlProc=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHsqlroutine)
 . s i%Stub=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHstub)
 . s i%StubMember=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHstubmember)
 . s i%TagGenerator=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHtaggenerator)
 . s i%UserActualType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHuseractualtype)
 . s i%WebMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$comSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$comSubMemberArrayGet(name1,$$$cCLASSproperty,name2,$$$cPROPmethod,name3,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledPro4352S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"a"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledProperty.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledPropertyMethod.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},21))#2:^(21),$d(^oddCOM($g(^(2),"*"),"m",{L5},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"m",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},70))#2:^(70),$d(^oddCOM($g(^(2),"*"),"m",{L5},70))#2:^(70),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},70))#2:^(70),1:0))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},24))#2:^(24),$d(^oddCOM($g(^(2),"*"),"m",{L5},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},25))#2:^(25),$d(^oddCOM($g(^(2),"*"),"m",{L5},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},25))#2:^(25),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},10))#2:^(10),$d(^oddCOM($g(^(2),"*"),"m",{L5},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="DefaultArgs">
<RetrievalCode> s {DefaultArgs}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},26))#2:^(26),$d(^oddCOM($g(^(2),"*"),"m",{L5},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},17))#2:^(17),$d(^oddCOM($g(^(2),"*"),"m",{L5},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},4))#2:^(4),$d(^oddCOM($g(^(2),"*"),"m",{L5},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},63))#2:^(63),$d(^oddCOM($g(^(2),"*"),"m",{L5},63))#2:^(63),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},7))#2:^(7),$d(^oddCOM($g(^(2),"*"),"m",{L5},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},71))#2:^(71),$d(^oddCOM($g(^(2),"*"),"m",{L5},71))#2:^(71),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},71))#2:^(71),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},27))#2:^(27),$d(^oddCOM($g(^(2),"*"),"m",{L5},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},60))#2:^(60),$d(^oddCOM($g(^(2),"*"),"m",{L5},60))#2:^(60),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="FormalType">
<RetrievalCode> s {FormalType}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},28))#2:^(28),$d(^oddCOM($g(^(2),"*"),"m",{L5},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},29))#2:^(29),$d(^oddCOM($g(^(2),"*"),"m",{L5},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},66))#2:^(66),$d(^oddCOM($g(^(2),"*"),"m",{L5},66))#2:^(66),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},66))#2:^(66),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},6))#2:^(6),$d(^oddCOM($g(^(2),"*"),"m",{L5},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},8))#2:^(8),$d(^oddCOM($g(^(2),"*"),"m",{L5},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},14))#2:^(14),$d(^oddCOM($g(^(2),"*"),"m",{L5},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"m",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"m",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Label">
<RetrievalCode> s {Label}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},31))#2:^(31),$d(^oddCOM($g(^(2),"*"),"m",{L5},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},33))#2:^(33),$d(^oddCOM($g(^(2),"*"),"m",{L5},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},34))#2:^(34),$d(^oddCOM($g(^(2),"*"),"m",{L5},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},34))#2:^(34),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},9))#2:^(9),$d(^oddCOM($g(^(2),"*"),"m",{L5},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OptimizedMAC">
<RetrievalCode> s {OptimizedMAC}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},35))#2:^(35),$d(^oddCOM($g(^(2),"*"),"m",{L5},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="OptimizedRun">
<RetrievalCode> s {OptimizedRun}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},36))#2:^(36),$d(^oddCOM($g(^(2),"*"),"m",{L5},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},2))#2:^(2),$d(^oddCOM($g(^(2),"*"),"m",{L5},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="OriginalName">
<RetrievalCode> s {OriginalName}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},37))#2:^(37),$d(^oddCOM($g(^(2),"*"),"m",{L5},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},38))#2:^(38),$d(^oddCOM($g(^(2),"*"),"m",{L5},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},39))#2:^(39),$d(^oddCOM($g(^(2),"*"),"m",{L5},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},39))#2:^(39),1:0))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},40))#2:^(40),$d(^oddCOM($g(^(2),"*"),"m",{L5},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},41))#2:^(41),$d(^oddCOM($g(^(2),"*"),"m",{L5},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},64))#2:^(64),$d(^oddCOM($g(^(2),"*"),"m",{L5},64))#2:^(64),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},64))#2:^(64),1:0))
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},42))#2:^(42),$d(^oddCOM($g(^(2),"*"),"m",{L5},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},62))#2:^(62),$d(^oddCOM($g(^(2),"*"),"m",{L5},62))#2:^(62),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},62))#2:^(62),1:""))
</RetrievalCode>
</Data>
<Data name="RtnLabel">
<RetrievalCode> s {RtnLabel}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},43))#2:^(43),$d(^oddCOM($g(^(2),"*"),"m",{L5},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="Runnable">
<RetrievalCode> s {Runnable}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},44))#2:^(44),$d(^oddCOM($g(^(2),"*"),"m",{L5},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},44))#2:^(44),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeClient">
<RetrievalCode> s {RuntimeClient}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},55))#2:^(55),$d(^oddCOM($g(^(2),"*"),"m",{L5},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},55))#2:^(55),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeCodeMode">
<RetrievalCode> s {RuntimeCodeMode}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},56))#2:^(56),$d(^oddCOM($g(^(2),"*"),"m",{L5},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},56))#2:^(56),1:"code"))
</RetrievalCode>
</Data>
<Data name="RuntimeHash">
<RetrievalCode> s {RuntimeHash}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},69))#2:^(69),$d(^oddCOM($g(^(2),"*"),"m",{L5},69))#2:^(69),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},69))#2:^(69),1:""))
</RetrievalCode>
</Data>
<Data name="RuntimeLanguage">
<RetrievalCode> s {RuntimeLanguage}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},58))#2:^(58),$d(^oddCOM($g(^(2),"*"),"m",{L5},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},58))#2:^(58),1:"cache"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},11))#2:^(11),$d(^oddCOM($g(^(2),"*"),"m",{L5},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},59))#2:^(59),$d(^oddCOM($g(^(2),"*"),"m",{L5},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},67))#2:^(67),$d(^oddCOM($g(^(2),"*"),"m",{L5},67))#2:^(67),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},67))#2:^(67),1:"[default]"))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},53))#2:^(53),$d(^oddCOM($g(^(2),"*"),"m",{L5},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},53))#2:^(53),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},54))#2:^(54),$d(^oddCOM($g(^(2),"*"),"m",{L5},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},68))#2:^(68),$d(^oddCOM($g(^(2),"*"),"m",{L5},68))#2:^(68),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},61))#2:^(61),$d(^oddCOM($g(^(2),"*"),"m",{L5},61))#2:^(61),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},61))#2:^(61),1:""))
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},73))#2:^(73),$d(^oddCOM($g(^(2),"*"),"m",{L5},73))#2:^(73),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},65))#2:^(65),$d(^oddCOM($g(^(2),"*"),"m",{L5},65))#2:^(65),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},45))#2:^(45),$d(^oddCOM($g(^(2),"*"),"m",{L5},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},46))#2:^(46),$d(^oddCOM($g(^(2),"*"),"m",{L5},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},46))#2:^(46),1:0))
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},74))#2:^(74),$d(^oddCOM($g(^(2),"*"),"m",{L5},74))#2:^(74),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="Stub">
<RetrievalCode> s {Stub}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},47))#2:^(47),$d(^oddCOM($g(^(2),"*"),"m",{L5},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="StubMember">
<RetrievalCode> s {StubMember}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},72))#2:^(72),$d(^oddCOM($g(^(2),"*"),"m",{L5},72))#2:^(72),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},72))#2:^(72),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},48))#2:^(48),$d(^oddCOM($g(^(2),"*"),"m",{L5},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},50))#2:^(50),$d(^oddCOM($g(^(2),"*"),"m",{L5},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},50))#2:^(50),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},51))#2:^(51),$d(^oddCOM($g(^(2),"*"),"m",{L5},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},52))#2:^(52),$d(^oddCOM($g(^(2),"*"),"m",{L5},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"a",{L3},"m",{L5},32))#2:^(32),$d(^oddCOM($g(^(2),"*"),"m",{L5},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"m",{L5},2),"*"),"m",{L5},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledPropertyQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41412</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSproperty)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledPropertyUDLText">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.036479</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledProperty</Type>
<Cardinality>parent</Cardinality>
<Inverse>UDLTexts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Category">
<Description>
Category</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Content">
<Description>
Holds the content of the UDL text.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Speficies the COS name of the UDL text.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Position">
<Description>
Position</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="TextType">
<Description>
TextType</Description>
<Type>%Integer</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Category=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTkeywordmodified)
 . s i%Position=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition)
 . s i%SequenceNumber=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber)
 . s i%TextType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype)
 . s i%Content=""
 . f ptr=1:1:$$$comSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent) d
 . . d ..Content.WriteLine($$$comSubMemberArrayGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,ptr))
 . d ..Content.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledPro3DD9S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"a"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledProperty.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"u"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledPropertyUDLText.Name}</Expression>
</Subscript>
<Data name="Category">
<RetrievalCode> s {Category}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"u",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},23))#2:^(23),1:"comment"))
</RetrievalCode>
</Data>
<Data name="Content">
<RetrievalCode> s {Content}=""
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"u",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"u",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Position">
<RetrievalCode> s {Position}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},24))#2:^(24),$d(^oddCOM($g(^(2),"*"),"u",{L5},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},24))#2:^(24),1:"body"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},11))#2:^(11),$d(^oddCOM($g(^(2),"*"),"u",{L5},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="TextType">
<RetrievalCode> s {TextType}=$s($d(^oddCOM({L1},"a",{L3},"u",{L5},22))#2:^(22),$d(^oddCOM($g(^(2),"*"),"u",{L5},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"a",{L3},"u",{L5},2),"*"),"u",{L5},22))#2:^(22),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledQuery">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledQueryQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.548708</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Queries</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Cardinality">
<Description>
Cardinality</Description>
<Type>%Integer</Type>
</Property>

<Property name="ClientInfo">
<Description>
ClientInfo</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ColCaptions">
<Description>
ColCaptions</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ColNames">
<Description>
ColNames</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this query is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExtendedInfo">
<Description>
ExtendedInfo</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the query.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments passed to the Execute method. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Methods">
<Description>
Method</Description>
<Type>%Dictionary.CompiledQueryMethod</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Name">
<Description>
The name of the query.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
Deprecated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="ParmNames">
<Description>
ParmNames</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
SoapNameSpace</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this query is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the query can be invoked as an SQL stored procedure.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlQuery">
<Description>
Specifies an SQL statement to be used for an SQL-based query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlQueryGen">
<Description>
SqlQueryGen</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlView">
<Description>
Specifies whether to project this query as an SQL View.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlViewName">
<Description>
Specifies an SQL alias for the view projected from this query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Specifies the Query class used to provide the implementation of the query interface.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
description=Specifies that this query can be invoked using the SOAP protocol. </Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSquery,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSquery,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Cardinality=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYcardinality)
 . s i%ClientInfo=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYclientinfo)
 . s i%ClientName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYclientname)
 . s i%ColCaptions=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYcolcaptions)
 . s i%ColNames=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYcolnames)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYcompilergenerated)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYdescription)
 . s i%ExtendedInfo=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYextendedinfo)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYfinal)
 . s i%FormalSpec=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYformalspec)
 . s i%FormalSpecParsed=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYformalspecparsed)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYorigin)
 . s i%ParmNames=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYparmnames)
 . s i%Private=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYprivate)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber)
 . s i%SoapBindingStyle=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle)
 . s i%SoapBodyUse=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse)
 . s i%SoapNameSpace=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlname)
 . s i%SqlProc=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc)
 . s i%SqlQuery=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery)
 . s i%SqlQueryGen=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlquerygen)
 . s i%SqlView=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlview)
 . s i%SqlViewName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYtype)
 . s i%UserActualType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYuseractualtype)
 . s i%WebMethod=$$$comMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod)
 . s sub="" f  s sub=$$$comSubMemberNext(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$comMemberArrayGet(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledQueryS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"q"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledQuery.Name}</Expression>
</Subscript>
<Data name="Cardinality">
<RetrievalCode> s {Cardinality}=$s($d(^oddCOM({L1},"q",{L3},40))#2:^(40),$d(^oddCOM($g(^(2),{L1}),"q",{L3},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},40))#2:^(40),1:0))
</RetrievalCode>
</Data>
<Data name="ClientInfo">
<RetrievalCode> s {ClientInfo}=$s($d(^oddCOM({L1},"q",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"q",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},21))#2:^(21),1:""))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"q",{L3},41))#2:^(41),$d(^oddCOM($g(^(2),{L1}),"q",{L3},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ColCaptions">
<RetrievalCode> s {ColCaptions}=$s($d(^oddCOM({L1},"q",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"q",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="ColNames">
<RetrievalCode> s {ColNames}=$s($d(^oddCOM({L1},"q",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"q",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"q",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"q",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"q",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"q",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"q",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"q",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExtendedInfo">
<RetrievalCode> s {ExtendedInfo}=$s($d(^oddCOM({L1},"q",{L3},38))#2:^(38),$d(^oddCOM($g(^(2),{L1}),"q",{L3},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"q",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"q",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"q",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"q",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"q",{L3},34))#2:^(34),$d(^oddCOM($g(^(2),{L1}),"q",{L3},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},34))#2:^(34),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"q",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"q",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"q",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"q",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"q",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"q",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"q",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"q",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"q",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"q",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"q",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"q",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"q",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"q",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddCOM({L1},"q",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$s($d(^oddCOM({L1},"q",{L3},"P",sub))#2:^(sub),$d(^oddCOM($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},"P",sub))#2:^(sub),1:$g(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},"P",sub)))))
</RetrievalCode>
</Data>
<Data name="ParmNames">
<RetrievalCode> s {ParmNames}=$s($d(^oddCOM({L1},"q",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"q",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},25))#2:^(25),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"q",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"q",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},26))#2:^(26),1:0))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"q",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"q",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"q",{L3},35))#2:^(35),$d(^oddCOM($g(^(2),{L1}),"q",{L3},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"q",{L3},36))#2:^(36),$d(^oddCOM($g(^(2),{L1}),"q",{L3},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"q",{L3},37))#2:^(37),$d(^oddCOM($g(^(2),{L1}),"q",{L3},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"q",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"q",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"q",{L3},28))#2:^(28),$d(^oddCOM($g(^(2),{L1}),"q",{L3},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},28))#2:^(28),1:0))
</RetrievalCode>
</Data>
<Data name="SqlQuery">
<RetrievalCode> s {SqlQuery}=$s($d(^oddCOM({L1},"q",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"q",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="SqlQueryGen">
<RetrievalCode> s {SqlQueryGen}=$s($d(^oddCOM({L1},"q",{L3},39))#2:^(39),$d(^oddCOM($g(^(2),{L1}),"q",{L3},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},39))#2:^(39),1:""))
</RetrievalCode>
</Data>
<Data name="SqlView">
<RetrievalCode> s {SqlView}=$s($d(^oddCOM({L1},"q",{L3},30))#2:^(30),$d(^oddCOM($g(^(2),{L1}),"q",{L3},30))#2:^(30),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},30))#2:^(30),1:0))
</RetrievalCode>
</Data>
<Data name="SqlViewName">
<RetrievalCode> s {SqlViewName}=$s($d(^oddCOM({L1},"q",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"q",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"q",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"q",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"q",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"q",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"q",{L3},33))#2:^(33),$d(^oddCOM($g(^(2),{L1}),"q",{L3},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},2),{L1}),"q",{L3},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledQueryMethod">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.091353</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledQuery</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="DefaultArgs">
<Description>
DefaultArgs</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalSpecParsed">
<Description>
FormalSpecParsed</Description>
<Type>%CacheString</Type>
</Property>

<Property name="FormalType">
<Description>
FormalType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Label">
<Description>
Label</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OptimizedMAC">
<Description>
OptimizedMAC</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OptimizedRun">
<Description>
OptimizedRun</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OriginalName">
<Description>
OriginalName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnLabel">
<Description>
RtnLabel</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Runnable">
<Description>
Runnable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeClient">
<Description>
RuntimeClient</Description>
<Type>%Boolean</Type>
</Property>

<Property name="RuntimeCodeMode">
<Description>
CodeMode to use for generated methods</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeHash">
<Description>
RuntimeHash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RuntimeLanguage">
<Description>
RuntimeLanguage</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Stub">
<Description>
Stub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StubMember">
<Description>
StubMember</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="UserActualType">
<Description>
UserActualType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comSubMemberDefined(name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comSubMemberDefined(name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Abstract=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHabstract)
 . s i%ClassMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHclientmethod)
 . s i%ClientName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHclientname)
 . s i%CodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHcodemode)
 . s i%CompilerGenerated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHcompilergenerated)
 . s i%DefaultArgs=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHdefaultargs)
 . s i%Deprecated=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHdeprecated)
 . s i%Description=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHdescription)
 . s i%ExternalProcName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHexternalprocname)
 . s i%Final=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHfinal)
 . s i%ForceGenerate=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHformalspec)
 . s i%FormalSpecParsed=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHformalspecparsed)
 . s i%FormalType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHformaltype)
 . s i%GenerateAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHgenerateafter)
 . s i%Hash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHhash)
 . s i%Id=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHid)
 . s i%InheritedId=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHinheritedid)
 . s i%Internal=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHinternal)
 . s i%KeywordError=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHkeyworderror)
 . s i%KeywordModified=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHkeywordmodified)
 . s i%Label=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHlabel)
 . s i%Language=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHlanguage)
 . s i%NoContext=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHnocontext)
 . s i%NotForProperty=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHnotinheritable)
 . s i%OptimizedMAC=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHoptimizedmac)
 . s i%OptimizedRun=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHoptimizedrun)
 . s i%Origin=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHorigin)
 . s i%OriginalName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHoriginalname)
 . s i%PlaceAfter=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHplaceafter)
 . s i%Private=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHprocedureblock)
 . s i%PublicList=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHreturntypeparams)
 . s i%RtnLabel=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHrtnlabel)
 . s i%Runnable=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHrunnable)
 . s i%RuntimeClient=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHruntimeclient)
 . s i%RuntimeCodeMode=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHruntimecodemode)
 . s i%RuntimeHash=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHruntimehash)
 . s i%RuntimeLanguage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHruntimelanguage)
 . s i%SequenceNumber=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHserveronly)
 . s i%SoapAction=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsqlname)
 . s i%SqlProc=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHsqlroutine)
 . s i%Stub=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHstub)
 . s i%StubMember=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHstubmember)
 . s i%TagGenerator=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHtaggenerator)
 . s i%UserActualType=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHuseractualtype)
 . s i%WebMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$comSubMemberKeyGetO(origin,name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$comSubMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$comSubMemberArrayGet(name1,$$$cCLASSquery,name2,$$$cQUERYmethod,name3,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledQuerFC7S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"q"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledQuery.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledQueryMethod.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},21))#2:^(21),$d(^oddCOM($g(^(2),"*"),"m",{L5},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},21))#2:^(21),1:0))
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},23))#2:^(23),$d(^oddCOM($g(^(2),"*"),"m",{L5},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},70))#2:^(70),$d(^oddCOM($g(^(2),"*"),"m",{L5},70))#2:^(70),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},70))#2:^(70),1:0))
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},24))#2:^(24),$d(^oddCOM($g(^(2),"*"),"m",{L5},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},25))#2:^(25),$d(^oddCOM($g(^(2),"*"),"m",{L5},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},25))#2:^(25),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},10))#2:^(10),$d(^oddCOM($g(^(2),"*"),"m",{L5},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="DefaultArgs">
<RetrievalCode> s {DefaultArgs}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},26))#2:^(26),$d(^oddCOM($g(^(2),"*"),"m",{L5},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},17))#2:^(17),$d(^oddCOM($g(^(2),"*"),"m",{L5},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},4))#2:^(4),$d(^oddCOM($g(^(2),"*"),"m",{L5},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},63))#2:^(63),$d(^oddCOM($g(^(2),"*"),"m",{L5},63))#2:^(63),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},63))#2:^(63),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},7))#2:^(7),$d(^oddCOM($g(^(2),"*"),"m",{L5},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},71))#2:^(71),$d(^oddCOM($g(^(2),"*"),"m",{L5},71))#2:^(71),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},71))#2:^(71),1:0))
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},27))#2:^(27),$d(^oddCOM($g(^(2),"*"),"m",{L5},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="FormalSpecParsed">
<RetrievalCode> s {FormalSpecParsed}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},60))#2:^(60),$d(^oddCOM($g(^(2),"*"),"m",{L5},60))#2:^(60),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},60))#2:^(60),1:""))
</RetrievalCode>
</Data>
<Data name="FormalType">
<RetrievalCode> s {FormalType}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},28))#2:^(28),$d(^oddCOM($g(^(2),"*"),"m",{L5},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},29))#2:^(29),$d(^oddCOM($g(^(2),"*"),"m",{L5},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},66))#2:^(66),$d(^oddCOM($g(^(2),"*"),"m",{L5},66))#2:^(66),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},66))#2:^(66),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},6))#2:^(6),$d(^oddCOM($g(^(2),"*"),"m",{L5},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},8))#2:^(8),$d(^oddCOM($g(^(2),"*"),"m",{L5},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},14))#2:^(14),$d(^oddCOM($g(^(2),"*"),"m",{L5},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},12))#2:^(12),$d(^oddCOM($g(^(2),"*"),"m",{L5},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},13))#2:^(13),$d(^oddCOM($g(^(2),"*"),"m",{L5},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Label">
<RetrievalCode> s {Label}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},31))#2:^(31),$d(^oddCOM($g(^(2),"*"),"m",{L5},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},33))#2:^(33),$d(^oddCOM($g(^(2),"*"),"m",{L5},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},33))#2:^(33),1:0))
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},34))#2:^(34),$d(^oddCOM($g(^(2),"*"),"m",{L5},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},34))#2:^(34),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},9))#2:^(9),$d(^oddCOM($g(^(2),"*"),"m",{L5},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OptimizedMAC">
<RetrievalCode> s {OptimizedMAC}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},35))#2:^(35),$d(^oddCOM($g(^(2),"*"),"m",{L5},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
<Data name="OptimizedRun">
<RetrievalCode> s {OptimizedRun}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},36))#2:^(36),$d(^oddCOM($g(^(2),"*"),"m",{L5},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},2))#2:^(2),$d(^oddCOM($g(^(2),"*"),"m",{L5},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="OriginalName">
<RetrievalCode> s {OriginalName}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},37))#2:^(37),$d(^oddCOM($g(^(2),"*"),"m",{L5},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},38))#2:^(38),$d(^oddCOM($g(^(2),"*"),"m",{L5},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},39))#2:^(39),$d(^oddCOM($g(^(2),"*"),"m",{L5},39))#2:^(39),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},39))#2:^(39),1:0))
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},40))#2:^(40),$d(^oddCOM($g(^(2),"*"),"m",{L5},40))#2:^(40),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},40))#2:^(40),1:""))
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},41))#2:^(41),$d(^oddCOM($g(^(2),"*"),"m",{L5},41))#2:^(41),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},41))#2:^(41),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},64))#2:^(64),$d(^oddCOM($g(^(2),"*"),"m",{L5},64))#2:^(64),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},64))#2:^(64),1:0))
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},42))#2:^(42),$d(^oddCOM($g(^(2),"*"),"m",{L5},42))#2:^(42),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},42))#2:^(42),1:""))
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},62))#2:^(62),$d(^oddCOM($g(^(2),"*"),"m",{L5},62))#2:^(62),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},62))#2:^(62),1:""))
</RetrievalCode>
</Data>
<Data name="RtnLabel">
<RetrievalCode> s {RtnLabel}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},43))#2:^(43),$d(^oddCOM($g(^(2),"*"),"m",{L5},43))#2:^(43),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},43))#2:^(43),1:""))
</RetrievalCode>
</Data>
<Data name="Runnable">
<RetrievalCode> s {Runnable}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},44))#2:^(44),$d(^oddCOM($g(^(2),"*"),"m",{L5},44))#2:^(44),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},44))#2:^(44),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeClient">
<RetrievalCode> s {RuntimeClient}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},55))#2:^(55),$d(^oddCOM($g(^(2),"*"),"m",{L5},55))#2:^(55),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},55))#2:^(55),1:0))
</RetrievalCode>
</Data>
<Data name="RuntimeCodeMode">
<RetrievalCode> s {RuntimeCodeMode}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},56))#2:^(56),$d(^oddCOM($g(^(2),"*"),"m",{L5},56))#2:^(56),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},56))#2:^(56),1:"code"))
</RetrievalCode>
</Data>
<Data name="RuntimeHash">
<RetrievalCode> s {RuntimeHash}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},69))#2:^(69),$d(^oddCOM($g(^(2),"*"),"m",{L5},69))#2:^(69),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},69))#2:^(69),1:""))
</RetrievalCode>
</Data>
<Data name="RuntimeLanguage">
<RetrievalCode> s {RuntimeLanguage}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},58))#2:^(58),$d(^oddCOM($g(^(2),"*"),"m",{L5},58))#2:^(58),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},58))#2:^(58),1:"cache"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},11))#2:^(11),$d(^oddCOM($g(^(2),"*"),"m",{L5},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},59))#2:^(59),$d(^oddCOM($g(^(2),"*"),"m",{L5},59))#2:^(59),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},59))#2:^(59),1:""))
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},67))#2:^(67),$d(^oddCOM($g(^(2),"*"),"m",{L5},67))#2:^(67),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},67))#2:^(67),1:"[default]"))
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},53))#2:^(53),$d(^oddCOM($g(^(2),"*"),"m",{L5},53))#2:^(53),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},53))#2:^(53),1:""))
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},54))#2:^(54),$d(^oddCOM($g(^(2),"*"),"m",{L5},54))#2:^(54),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},54))#2:^(54),1:""))
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},68))#2:^(68),$d(^oddCOM($g(^(2),"*"),"m",{L5},68))#2:^(68),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},68))#2:^(68),1:""))
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},61))#2:^(61),$d(^oddCOM($g(^(2),"*"),"m",{L5},61))#2:^(61),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},61))#2:^(61),1:""))
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},73))#2:^(73),$d(^oddCOM($g(^(2),"*"),"m",{L5},73))#2:^(73),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},73))#2:^(73),1:""))
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},65))#2:^(65),$d(^oddCOM($g(^(2),"*"),"m",{L5},65))#2:^(65),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},65))#2:^(65),1:""))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},45))#2:^(45),$d(^oddCOM($g(^(2),"*"),"m",{L5},45))#2:^(45),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},45))#2:^(45),1:""))
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},46))#2:^(46),$d(^oddCOM($g(^(2),"*"),"m",{L5},46))#2:^(46),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},46))#2:^(46),1:0))
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},74))#2:^(74),$d(^oddCOM($g(^(2),"*"),"m",{L5},74))#2:^(74),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},74))#2:^(74),1:""))
</RetrievalCode>
</Data>
<Data name="Stub">
<RetrievalCode> s {Stub}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},47))#2:^(47),$d(^oddCOM($g(^(2),"*"),"m",{L5},47))#2:^(47),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},47))#2:^(47),1:""))
</RetrievalCode>
</Data>
<Data name="StubMember">
<RetrievalCode> s {StubMember}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},72))#2:^(72),$d(^oddCOM($g(^(2),"*"),"m",{L5},72))#2:^(72),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},72))#2:^(72),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},48))#2:^(48),$d(^oddCOM($g(^(2),"*"),"m",{L5},48))#2:^(48),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},48))#2:^(48),1:""))
</RetrievalCode>
</Data>
<Data name="UserActualType">
<RetrievalCode> s {UserActualType}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},50))#2:^(50),$d(^oddCOM($g(^(2),"*"),"m",{L5},50))#2:^(50),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},50))#2:^(50),1:""))
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},51))#2:^(51),$d(^oddCOM($g(^(2),"*"),"m",{L5},51))#2:^(51),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},51))#2:^(51),1:0))
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},52))#2:^(52),$d(^oddCOM($g(^(2),"*"),"m",{L5},52))#2:^(52),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},52))#2:^(52),1:0))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"q",{L3},"m",{L5},32))#2:^(32),$d(^oddCOM($g(^(2),"*"),"m",{L5},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"q",{L3},"m",{L5},2),"*"),"m",{L5},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledQueryQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSquery)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledStorage">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledStorageQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.55758</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Storages</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="CounterLocation">
<Description>
Specifies the base location of counters for properties with type is %Library.Counter. Normally this would be a global reference such as ^User.PersonC. The global reference can also include one or more leading subscripts.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Data</Description>
<Type>%Dictionary.CompiledStorageData</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="DataLocation">
<Description>
Specifies expression that is the location where data is stored for this class. Normally this would be a global reference such as ^User.PersonD. The global reference can also include one or more leading subscripts.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DefaultData">
<Description>
Specifies the name of the DATA definition that the Class Compiler Data Structure Generator uses to place any previously unstored properties. A property is unstored if it is storable, but is not listed in any DATA definition. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this storage is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the storage definition. This description is displayed by the online class reference.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExtentLocation">
<Description>
Specifies the base location of globals used by the extent of this class. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExtentSize">
<Description>
ExtentSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that the storage definition cannot be modified by subclasses.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="IdExpression">
<Description>
IdExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IdFunction">
<Description>
Specifies the system function used to allocate new id values.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IdLocation">
<Description>
Specifies location of the ID Counter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Indices">
<Description>
Index</Description>
<Type>%Dictionary.CompiledStorageIndex</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="IndexLocation">
<Description>
Specifies the global used for indices for this class. If not specified, the index location is ^MyApp.MyClassI, where MyApp.MyClass is the classname. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Specifies the name of the Storage definition. This name must be a valid class member name and must not conflict with any other class member names.</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Properties">
<Description>
Property</Description>
<Type>%Dictionary.CompiledStorageProperty</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="RootClass">
<Description>
RootClass</Description>
<Type>%Boolean</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="SqlChildSub">
<Description>
SqlChildSub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlIdExpression">
<Description>
SqlIdExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SQLMaps">
<Description>
SQLMap</Description>
<Type>%Dictionary.CompiledStorageSQLMap</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="SqlRowIdName">
<Description>
Specifies the name of the Row ID column projected to SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdProperty">
<Description>
Specifies the SQL RowId property. This keyword is only used by classes that have been migrated from earlier InterSystems products.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlTableNumber">
<Description>
Specifies the internal SQL Table Number. This keyword is only used by classes that have been migrated from earlier InterSystems products.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="State">
<Description>
For a serial embedded class, this keyword specifies which Data definition is used to define the serialized state of the object. This is also the default DATA definition that unstored properties will be added to by the default structure generator.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StreamLocation">
<Description>
Specifies the default global used to store any stream properties within this class. If not specified, the index location is ^MyApp.MyClassS, where MyApp.MyClass is the classname. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Specifies the Storage Class used to provide persistence for this class.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="VersionLocation">
<Description>
Specifies location of the %Version Counter.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSstorage,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSstorage,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFcompilergenerated)
 . s i%CounterLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation)
 . s i%DataLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation)
 . s i%DefaultData=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFdescription)
 . s i%ExtentLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation)
 . s i%ExtentSize=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFfinal)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFid)
 . s i%IdExpression=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression)
 . s i%IdFunction=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction)
 . s i%IdLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation)
 . s i%IndexLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFkeywordmodified)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFnotinheritable)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEForigin)
 . s i%RootClass=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFrootclass)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber)
 . s i%SqlChildSub=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub)
 . s i%SqlIdExpression=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression)
 . s i%SqlRowIdName=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname)
 . s i%SqlRowIdProperty=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty)
 . s i%SqlTableNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber)
 . s i%State=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFstate)
 . s i%StreamLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation)
 . s i%Type=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFtype)
 . s i%VersionLocation=$$$comMemberKeyGetO(origin,name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStorageS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"s",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"s",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="CounterLocation">
<RetrievalCode> s {CounterLocation}=$s($d(^oddCOM({L1},"s",{L3},36))#2:^(36),$d(^oddCOM($g(^(2),{L1}),"s",{L3},36))#2:^(36),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},36))#2:^(36),1:""))
</RetrievalCode>
</Data>
<Data name="DataLocation">
<RetrievalCode> s {DataLocation}=$s($d(^oddCOM({L1},"s",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"s",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},21))#2:^(21),1:""))
</RetrievalCode>
</Data>
<Data name="DefaultData">
<RetrievalCode> s {DefaultData}=$s($d(^oddCOM({L1},"s",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"s",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"s",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"s",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"s",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"s",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="ExtentLocation">
<RetrievalCode> s {ExtentLocation}=$s($d(^oddCOM({L1},"s",{L3},38))#2:^(38),$d(^oddCOM($g(^(2),{L1}),"s",{L3},38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},38))#2:^(38),1:""))
</RetrievalCode>
</Data>
<Data name="ExtentSize">
<RetrievalCode> s {ExtentSize}=$s($d(^oddCOM({L1},"s",{L3},34))#2:^(34),$d(^oddCOM($g(^(2),{L1}),"s",{L3},34))#2:^(34),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},34))#2:^(34),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"s",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"s",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"s",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"s",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="IdExpression">
<RetrievalCode> s {IdExpression}=$s($d(^oddCOM({L1},"s",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"s",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
<Data name="IdFunction">
<RetrievalCode> s {IdFunction}=$s($d(^oddCOM({L1},"s",{L3},37))#2:^(37),$d(^oddCOM($g(^(2),{L1}),"s",{L3},37))#2:^(37),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},37))#2:^(37),1:""))
</RetrievalCode>
</Data>
<Data name="IdLocation">
<RetrievalCode> s {IdLocation}=$s($d(^oddCOM({L1},"s",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"s",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="IndexLocation">
<RetrievalCode> s {IndexLocation}=$s($d(^oddCOM({L1},"s",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"s",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},25))#2:^(25),1:""))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"s",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"s",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"s",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"s",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"s",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"s",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"s",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"s",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"s",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"s",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"s",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"s",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="RootClass">
<RetrievalCode> s {RootClass}=$s($d(^oddCOM({L1},"s",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"s",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},26))#2:^(26),1:0))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"s",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"s",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="SqlChildSub">
<RetrievalCode> s {SqlChildSub}=$s($d(^oddCOM({L1},"s",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"s",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="SqlIdExpression">
<RetrievalCode> s {SqlIdExpression}=$s($d(^oddCOM({L1},"s",{L3},28))#2:^(28),$d(^oddCOM($g(^(2),{L1}),"s",{L3},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="SqlRowIdName">
<RetrievalCode> s {SqlRowIdName}=$s($d(^oddCOM({L1},"s",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"s",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="SqlRowIdProperty">
<RetrievalCode> s {SqlRowIdProperty}=$s($d(^oddCOM({L1},"s",{L3},30))#2:^(30),$d(^oddCOM($g(^(2),{L1}),"s",{L3},30))#2:^(30),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},30))#2:^(30),1:""))
</RetrievalCode>
</Data>
<Data name="SqlTableNumber">
<RetrievalCode> s {SqlTableNumber}=$s($d(^oddCOM({L1},"s",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"s",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},31))#2:^(31),1:""))
</RetrievalCode>
</Data>
<Data name="State">
<RetrievalCode> s {State}=$s($d(^oddCOM({L1},"s",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"s",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
<Data name="StreamLocation">
<RetrievalCode> s {StreamLocation}=$s($d(^oddCOM({L1},"s",{L3},33))#2:^(33),$d(^oddCOM($g(^(2),{L1}),"s",{L3},33))#2:^(33),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},33))#2:^(33),1:""))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddCOM({L1},"s",{L3},5))#2:^(5),$d(^oddCOM($g(^(2),{L1}),"s",{L3},5))#2:^(5),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},5))#2:^(5),1:""))
</RetrievalCode>
</Data>
<Data name="VersionLocation">
<RetrievalCode> s {VersionLocation}=$s($d(^oddCOM({L1},"s",{L3},35))#2:^(35),$d(^oddCOM($g(^(2),{L1}),"s",{L3},35))#2:^(35),1:$s($d(^oddDEF($g(^oddCOM({L1},"s",{L3},2),{L1}),"s",{L3},35))#2:^(35),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageData">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.061876</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorage</Type>
<Cardinality>parent</Cardinality>
<Inverse>Data</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Attribute">
<Description>
Attribute</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Specifies the name of the StorageData definition. This name must be a valid storage member name and must not conflict with any other StorageData names.</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="Structure">
<Description>
Specifies how the data is stored into a global node.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Subscript">
<Description>
Subscript</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Values">
<Description>
Value</Description>
<Type>%Dictionary.CompiledStorageDataValue</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Attribute=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute)
 . s i%KeywordError=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAkeyworderror)
 . s i%KeywordModified=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAkeywordmodified)
 . s i%Structure=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure)
 . s i%Subscript=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoE869S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"D"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageData.Name}</Expression>
</Subscript>
<Data name="Attribute">
<RetrievalCode> s {Attribute}=$g(^oddCOM({L1},"s",{L3},"D",{L5},21),$g(^%qCacheObjectKey(1,"D",21)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"D",{L5},12),$g(^%qCacheObjectKey(1,"D",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"D",{L5},13),$g(^%qCacheObjectKey(1,"D",13)))
</RetrievalCode>
</Data>
<Data name="Structure">
<RetrievalCode> s {Structure}=$g(^oddCOM({L1},"s",{L3},"D",{L5},22),$g(^%qCacheObjectKey(1,"D",22)))
</RetrievalCode>
</Data>
<Data name="Subscript">
<RetrievalCode> s {Subscript}=$g(^oddCOM({L1},"s",{L3},"D",{L5},23),$g(^%qCacheObjectKey(1,"D",23)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageDataValue">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.232078</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageData</Type>
<Cardinality>parent</Cardinality>
<Inverse>Values</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Specifies the name of the StorageDataValue. This name must be a valid storage member name and must not conflict with any other StorageDataValue names.</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Value">
<Description>
Value</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%KeywordError=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALkeywordmodified)
 . s i%Value=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoFF18S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"D"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageData.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"V"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageDataValue.Name}</Expression>
</Subscript>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"D",{L5},"V",{L7},12),$g(^%qCacheObjectKey(1,"V",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"D",{L5},"V",{L7},13),$g(^%qCacheObjectKey(1,"V",13)))
</RetrievalCode>
</Data>
<Data name="Value">
<RetrievalCode> s {Value}=$g(^oddCOM({L1},"s",{L3},"D",{L5},"V",{L7},21),$g(^%qCacheObjectKey(1,"V",21)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageIndex">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.067551</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorage</Type>
<Cardinality>parent</Cardinality>
<Inverse>Indices</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Location">
<Description>
Location</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%KeywordError=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXkeyworderror)
 . s i%KeywordModified=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXkeywordmodified)
 . s i%Location=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoDC05S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"X"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageIndex.Name}</Expression>
</Subscript>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"X",{L5},12),$g(^%qCacheObjectKey(1,"X",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"X",{L5},13),$g(^%qCacheObjectKey(1,"X",13)))
</RetrievalCode>
</Data>
<Data name="Location">
<RetrievalCode> s {Location}=$g(^oddCOM({L1},"s",{L3},"X",{L5},21),$g(^%qCacheObjectKey(1,"X",21)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageProperty">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.089886</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorage</Type>
<Cardinality>parent</Cardinality>
<Inverse>Properties</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="AverageFieldSize">
<Description>
AverageFieldSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="BiasQueriesAsOutlier">
<Description>
BiasQueriesAsOutlier</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ChildBlockCount">
<Description>
ChildBlockCount</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ChildExtentSize">
<Description>
ChildExtentSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="OutlierSelectivity">
<Description>
OutlierSelectivity</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Selectivity">
<Description>
Selectivity</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StreamLocation">
<Description>
StreamLocation</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%AverageFieldSize=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize)
 . s i%BiasQueriesAsOutlier=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier)
 . s i%ChildBlockCount=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount)
 . s i%ChildExtentSize=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize)
 . s i%KeywordError=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYkeyworderror)
 . s i%KeywordModified=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYkeywordmodified)
 . s i%OutlierSelectivity=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity)
 . s i%Selectivity=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity)
 . s i%StreamLocation=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledSto4B18S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"M"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageProperty.Name}</Expression>
</Subscript>
<Data name="AverageFieldSize">
<RetrievalCode> s {AverageFieldSize}=$g(^oddCOM({L1},"s",{L3},"M",{L5},26),$g(^%qCacheObjectKey(1,"M",26)))
</RetrievalCode>
</Data>
<Data name="BiasQueriesAsOutlier">
<RetrievalCode> s {BiasQueriesAsOutlier}=$g(^oddCOM({L1},"s",{L3},"M",{L5},25),$g(^%qCacheObjectKey(1,"M",25)))
</RetrievalCode>
</Data>
<Data name="ChildBlockCount">
<RetrievalCode> s {ChildBlockCount}=$g(^oddCOM({L1},"s",{L3},"M",{L5},27),$g(^%qCacheObjectKey(1,"M",27)))
</RetrievalCode>
</Data>
<Data name="ChildExtentSize">
<RetrievalCode> s {ChildExtentSize}=$g(^oddCOM({L1},"s",{L3},"M",{L5},23),$g(^%qCacheObjectKey(1,"M",23)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"M",{L5},12),$g(^%qCacheObjectKey(1,"M",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"M",{L5},13),$g(^%qCacheObjectKey(1,"M",13)))
</RetrievalCode>
</Data>
<Data name="OutlierSelectivity">
<RetrievalCode> s {OutlierSelectivity}=$g(^oddCOM({L1},"s",{L3},"M",{L5},24),$g(^%qCacheObjectKey(1,"M",24)))
</RetrievalCode>
</Data>
<Data name="Selectivity">
<RetrievalCode> s {Selectivity}=$g(^oddCOM({L1},"s",{L3},"M",{L5},21),$g(^%qCacheObjectKey(1,"M",21)))
</RetrievalCode>
</Data>
<Data name="StreamLocation">
<RetrievalCode> s {StreamLocation}=$g(^oddCOM({L1},"s",{L3},"M",{L5},22),$g(^%qCacheObjectKey(1,"M",22)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSstorage)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMap">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.094775</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorage</Type>
<Cardinality>parent</Cardinality>
<Inverse>SQLMaps</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="BlockCount">
<Description>
BlockCount</Description>
<Type>%Integer</Type>
</Property>

<Property name="Condition">
<Description>
Condition</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ConditionalWithHostVars">
<Description>
ConditionalWithHostVars</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ConditionFields">
<Description>
ConditionFields</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Data</Description>
<Type>%Dictionary.CompiledStorageSQLMapData</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Global">
<Description>
Global</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Global</SqlFieldName>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="PopulationPct">
<Description>
PopulationPct</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PopulationType">
<Description>
PopulationType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RowIdSpecs">
<Description>
RowIdSpec</Description>
<Type>%Dictionary.CompiledStorageSQLMapRowIdSpec</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="RowReference">
<Description>
RowReference</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Structure">
<Description>
Structure</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Subscripts">
<Description>
Subscript</Description>
<Type>%Dictionary.CompiledStorageSQLMapSub</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Type">
<Description>
Specifies what kind of a map this is.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$comStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%BlockCount=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount)
 . s i%Condition=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition)
 . s i%ConditionalWithHostVars=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars)
 . s i%ConditionFields=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields)
 . s i%Global=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal)
 . s i%KeywordError=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPkeyworderror)
 . s i%KeywordModified=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPkeywordmodified)
 . s i%PopulationPct=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct)
 . s i%PopulationType=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype)
 . s i%RowReference=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference)
 . s i%Structure=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure)
 . s i%Type=$$$comStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoE089S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Data name="BlockCount">
<RetrievalCode> s {BlockCount}=$g(^oddCOM({L1},"s",{L3},"S",{L5},29),$g(^%qCacheObjectKey(1,"S",29)))
</RetrievalCode>
</Data>
<Data name="Condition">
<RetrievalCode> s {Condition}=$g(^oddCOM({L1},"s",{L3},"S",{L5},21),$g(^%qCacheObjectKey(1,"S",21)))
</RetrievalCode>
</Data>
<Data name="ConditionFields">
<RetrievalCode> s {ConditionFields}=$g(^oddCOM({L1},"s",{L3},"S",{L5},23),$g(^%qCacheObjectKey(1,"S",23)))
</RetrievalCode>
</Data>
<Data name="ConditionalWithHostVars">
<RetrievalCode> s {ConditionalWithHostVars}=$g(^oddCOM({L1},"s",{L3},"S",{L5},22),$g(^%qCacheObjectKey(1,"S",22)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},12),$g(^%qCacheObjectKey(1,"S",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},13),$g(^%qCacheObjectKey(1,"S",13)))
</RetrievalCode>
</Data>
<Data name="PopulationPct">
<RetrievalCode> s {PopulationPct}=$g(^oddCOM({L1},"s",{L3},"S",{L5},25),$g(^%qCacheObjectKey(1,"S",25)))
</RetrievalCode>
</Data>
<Data name="PopulationType">
<RetrievalCode> s {PopulationType}=$g(^oddCOM({L1},"s",{L3},"S",{L5},26),$g(^%qCacheObjectKey(1,"S",26)))
</RetrievalCode>
</Data>
<Data name="RowReference">
<RetrievalCode> s {RowReference}=$g(^oddCOM({L1},"s",{L3},"S",{L5},27),$g(^%qCacheObjectKey(1,"S",27)))
</RetrievalCode>
</Data>
<Data name="Structure">
<RetrievalCode> s {Structure}=$g(^oddCOM({L1},"s",{L3},"S",{L5},28),$g(^%qCacheObjectKey(1,"S",28)))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$g(^oddCOM({L1},"s",{L3},"S",{L5},5),$g(^%qCacheObjectKey(1,"S",5)))
</RetrievalCode>
</Data>
<Data name="_Global">
<RetrievalCode> s {_Global}=$g(^oddCOM({L1},"s",{L3},"S",{L5},24),$g(^%qCacheObjectKey(1,"S",24)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMapData">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.235093</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageSQLMap</Type>
<Cardinality>parent</Cardinality>
<Inverse>Data</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Delimiter">
<Description>
Delimiter</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="Node">
<Description>
Node</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Piece">
<Description>
Piece</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RetrievalCode">
<Description>
RetrievalCode</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%Delimiter=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter)
 . s i%KeywordError=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAkeywordmodified)
 . s i%Node=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode)
 . s i%Piece=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece)
 . s i%RetrievalCode=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledSto6C88S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"T"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageSQLMapData.Name}</Expression>
</Subscript>
<Data name="Delimiter">
<RetrievalCode> s {Delimiter}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},21),$g(^%qCacheObjectKey(1,"T",21)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},12),$g(^%qCacheObjectKey(1,"T",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},13),$g(^%qCacheObjectKey(1,"T",13)))
</RetrievalCode>
</Data>
<Data name="Node">
<RetrievalCode> s {Node}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},22),$g(^%qCacheObjectKey(1,"T",22)))
</RetrievalCode>
</Data>
<Data name="Piece">
<RetrievalCode> s {Piece}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},23),$g(^%qCacheObjectKey(1,"T",23)))
</RetrievalCode>
</Data>
<Data name="RetrievalCode">
<RetrievalCode> s {RetrievalCode}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"T",{L7},24),$g(^%qCacheObjectKey(1,"T",24)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMapRowIdSpec">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.276578</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageSQLMap</Type>
<Cardinality>parent</Cardinality>
<Inverse>RowIdSpecs</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Field">
<Description>
Field</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%Expression=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression)
 . s i%Field=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield)
 . s i%KeywordError=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECkeywordmodified)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoA5A5S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"R"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageSQLMapRowIdSpec.Name}</Expression>
</Subscript>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"R",{L7},21),$g(^%qCacheObjectKey(1,"R",21)))
</RetrievalCode>
</Data>
<Data name="Field">
<RetrievalCode> s {Field}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"R",{L7},22),$g(^%qCacheObjectKey(1,"R",22)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"R",{L7},12),$g(^%qCacheObjectKey(1,"R",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"R",{L7},13),$g(^%qCacheObjectKey(1,"R",13)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMapSub">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.241397</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageSQLMap</Type>
<Cardinality>parent</Cardinality>
<Inverse>Subscripts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="AccessType">
<Description>
AccessType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Accessvars">
<Description>
Accessvar</Description>
<Type>%Dictionary.CompiledStorageSQLMapSubAccessvar</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="DataAccess">
<Description>
DataAccess</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Delimiter">
<Description>
Delimiter</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Invalidconditions">
<Description>
Invalidcondition</Description>
<Type>%Dictionary.CompiledStorageSQLMapSubInvalidcondition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="LoopInitValue">
<Description>
LoopInitValue</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="NextCode">
<Description>
NextCode</Description>
<Type>%CacheString</Type>
</Property>

<Property name="NullMarker">
<Description>
NullMarker</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StartValue">
<Description>
StartValue</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StopExpression">
<Description>
StopExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StopValue">
<Description>
StopValue</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$comStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%AccessType=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype)
 . s i%DataAccess=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess)
 . s i%Delimiter=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter)
 . s i%Expression=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression)
 . s i%KeywordError=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBkeywordmodified)
 . s i%LoopInitValue=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue)
 . s i%NextCode=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode)
 . s i%NullMarker=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker)
 . s i%StartValue=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue)
 . s i%StopExpression=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression)
 . s i%StopValue=$$$comStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledSto42CFS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageSQLMapSub.Name}</Expression>
</Subscript>
<Data name="AccessType">
<RetrievalCode> s {AccessType}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},21),$g(^%qCacheObjectKey(1,"B",21)))
</RetrievalCode>
</Data>
<Data name="DataAccess">
<RetrievalCode> s {DataAccess}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},22),$g(^%qCacheObjectKey(1,"B",22)))
</RetrievalCode>
</Data>
<Data name="Delimiter">
<RetrievalCode> s {Delimiter}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},23),$g(^%qCacheObjectKey(1,"B",23)))
</RetrievalCode>
</Data>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},24),$g(^%qCacheObjectKey(1,"B",24)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},12),$g(^%qCacheObjectKey(1,"B",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},13),$g(^%qCacheObjectKey(1,"B",13)))
</RetrievalCode>
</Data>
<Data name="LoopInitValue">
<RetrievalCode> s {LoopInitValue}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},25),$g(^%qCacheObjectKey(1,"B",25)))
</RetrievalCode>
</Data>
<Data name="NextCode">
<RetrievalCode> s {NextCode}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},26),$g(^%qCacheObjectKey(1,"B",26)))
</RetrievalCode>
</Data>
<Data name="NullMarker">
<RetrievalCode> s {NullMarker}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},27),$g(^%qCacheObjectKey(1,"B",27)))
</RetrievalCode>
</Data>
<Data name="StartValue">
<RetrievalCode> s {StartValue}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},28),$g(^%qCacheObjectKey(1,"B",28)))
</RetrievalCode>
</Data>
<Data name="StopExpression">
<RetrievalCode> s {StopExpression}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},29),$g(^%qCacheObjectKey(1,"B",29)))
</RetrievalCode>
</Data>
<Data name="StopValue">
<RetrievalCode> s {StopValue}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},30),$g(^%qCacheObjectKey(1,"B",30)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMapSubAccessvar">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.34158</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageSQLMapSub</Type>
<Cardinality>parent</Cardinality>
<Inverse>Accessvars</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Code">
<Description>
Code</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Variable">
<Description>
Variable</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="")||('$$$comStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,4)
 . s i%Name=name5
 . s i%Code=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode)
 . s i%KeywordError=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARkeywordmodified)
 . s i%Variable=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledStoA1E3S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageSQLMapSub.Name}</Expression>
</Subscript>
<Subscript name="8">
<Expression>"A"</Expression>
</Subscript>
<Subscript name="9">
<Expression>{%Dictionary.CompiledStorageSQLMapSubAccessvar.Name}</Expression>
</Subscript>
<Data name="Code">
<RetrievalCode> s {Code}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},21),$g(^%qCacheObjectKey(1,"A",21)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},12),$g(^%qCacheObjectKey(1,"A",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},13),$g(^%qCacheObjectKey(1,"A",13)))
</RetrievalCode>
</Data>
<Data name="Variable">
<RetrievalCode> s {Variable}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},22),$g(^%qCacheObjectKey(1,"A",22)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledStorageSQLMapSubInvalidcondition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.346565</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledStorageSQLMapSub</Type>
<Cardinality>parent</Cardinality>
<Inverse>Invalidconditions</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="")||('$$$comStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,4)
 . s i%Name=name5
 . s i%Expression=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression)
 . s i%KeywordError=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDkeyworderror)
 . s i%KeywordModified=$$$comStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDkeywordmodified)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledSto6F7ES</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledStorage.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.CompiledStorageSQLMap.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.CompiledStorageSQLMapSub.Name}</Expression>
</Subscript>
<Subscript name="8">
<Expression>"N"</Expression>
</Subscript>
<Subscript name="9">
<Expression>{%Dictionary.CompiledStorageSQLMapSubInvalidcondition.Name}</Expression>
</Subscript>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"N",{L9},21),$g(^%qCacheObjectKey(1,"N",21)))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"N",{L9},12),$g(^%qCacheObjectKey(1,"N",12)))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$g(^oddCOM({L1},"s",{L3},"S",{L5},"B",{L7},"N",{L9},13),$g(^%qCacheObjectKey(1,"N",13)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledTrigger">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledTriggerQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.572774</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>Triggers</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Code">
<Description>
The code that is executed when the trigger is fired.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: lines of code to be compiled, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CompilerGenerated">
<Description>
CompilerGenerated</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this trigger is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the SQL trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Event">
<Description>
Specifies the SQL event that will fire the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the SQL trigger.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Foreach">
<Description>
Indicates if the trigger will be invoked for each row, for rows and objects, or for each statement</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Id">
<Description>
Id</Description>
<Type>%Integer</Type>
</Property>

<Property name="InheritedId">
<Description>
InheritedId</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Language">
<Description>
The language used to implement this trigger.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the SQL trigger.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NewTable">
<Description>
The name of the SQL table that holds old values for the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="NotInheritable">
<Description>
NotInheritable</Description>
<Type>%Boolean</Type>
</Property>

<Property name="OldTable">
<Description>
The name of the SQL table that holds old values for the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Order">
<Description>
In the case of multiple triggers for the same EVENT and TIME, specifies the order in which the triggers should be fired.</Description>
<Type>%Integer</Type>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="SqlName">
<Description>
Specifies an alternate name when this trigger is used by SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="TagGenerator">
<Description>
TagGenerator</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Time">
<Description>
Specifies whether the trigger is fired before or after the EVENT.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Time</SqlFieldName>
</Property>

<Property name="UpdateColumnList">
<Description>
Specifies one or more columns whose modification causes the trigger to be pulled by SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASStrigger,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASStrigger,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Code=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode)
 . s i%CodeMode=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode)
 . s i%CompilerGenerated=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERcompilergenerated)
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription)
 . s i%Event=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent)
 . s i%Final=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal)
 . s i%Foreach=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach)
 . s i%Id=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERid)
 . s i%InheritedId=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERinheritedid)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERkeywordmodified)
 . s i%Language=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage)
 . s i%NewTable=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable)
 . s i%NotInheritable=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERnotinheritable)
 . s i%OldTable=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable)
 . s i%Order=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERorigin)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber)
 . s i%SqlName=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname)
 . s i%TagGenerator=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERtaggenerator)
 . s i%Time=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime)
 . s i%UpdateColumnList=$$$comMemberKeyGetO(origin,name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledTriggerS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"t"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledTrigger.Name}</Expression>
</Subscript>
<Data name="Code">
<RetrievalCode> s {Code}=$s($d(^oddCOM({L1},"t",{L3},21))#2:^(21),$d(^oddCOM($g(^(2),{L1}),"t",{L3},21))#2:^(21),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},21))#2:^(21),1:""))
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddCOM({L1},"t",{L3},31))#2:^(31),$d(^oddCOM($g(^(2),{L1}),"t",{L3},31))#2:^(31),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},31))#2:^(31),1:"code"))
</RetrievalCode>
</Data>
<Data name="CompilerGenerated">
<RetrievalCode> s {CompilerGenerated}=$s($d(^oddCOM({L1},"t",{L3},10))#2:^(10),$d(^oddCOM($g(^(2),{L1}),"t",{L3},10))#2:^(10),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},10))#2:^(10),1:0))
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"t",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"t",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"t",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"t",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Event">
<RetrievalCode> s {Event}=$s($d(^oddCOM({L1},"t",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"t",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddCOM({L1},"t",{L3},7))#2:^(7),$d(^oddCOM($g(^(2),{L1}),"t",{L3},7))#2:^(7),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},7))#2:^(7),1:0))
</RetrievalCode>
</Data>
<Data name="Foreach">
<RetrievalCode> s {Foreach}=$s($d(^oddCOM({L1},"t",{L3},26))#2:^(26),$d(^oddCOM($g(^(2),{L1}),"t",{L3},26))#2:^(26),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},26))#2:^(26),1:""))
</RetrievalCode>
</Data>
<Data name="Id">
<RetrievalCode> s {Id}=$s($d(^oddCOM({L1},"t",{L3},6))#2:^(6),$d(^oddCOM($g(^(2),{L1}),"t",{L3},6))#2:^(6),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},6))#2:^(6),1:0))
</RetrievalCode>
</Data>
<Data name="InheritedId">
<RetrievalCode> s {InheritedId}=$s($d(^oddCOM({L1},"t",{L3},8))#2:^(8),$d(^oddCOM($g(^(2),{L1}),"t",{L3},8))#2:^(8),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},8))#2:^(8),1:0))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"t",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"t",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"t",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"t",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"t",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"t",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="NewTable">
<RetrievalCode> s {NewTable}=$s($d(^oddCOM({L1},"t",{L3},29))#2:^(29),$d(^oddCOM($g(^(2),{L1}),"t",{L3},29))#2:^(29),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},29))#2:^(29),1:""))
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddCOM({L1},"t",{L3},9))#2:^(9),$d(^oddCOM($g(^(2),{L1}),"t",{L3},9))#2:^(9),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},9))#2:^(9),1:0))
</RetrievalCode>
</Data>
<Data name="OldTable">
<RetrievalCode> s {OldTable}=$s($d(^oddCOM({L1},"t",{L3},30))#2:^(30),$d(^oddCOM($g(^(2),{L1}),"t",{L3},30))#2:^(30),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},30))#2:^(30),1:""))
</RetrievalCode>
</Data>
<Data name="Order">
<RetrievalCode> s {Order}=$s($d(^oddCOM({L1},"t",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"t",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},23))#2:^(23),1:0))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"t",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"t",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"t",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"t",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddCOM({L1},"t",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"t",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},24))#2:^(24),1:""))
</RetrievalCode>
</Data>
<Data name="TagGenerator">
<RetrievalCode> s {TagGenerator}=$s($d(^oddCOM({L1},"t",{L3},32))#2:^(32),$d(^oddCOM($g(^(2),{L1}),"t",{L3},32))#2:^(32),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},32))#2:^(32),1:""))
</RetrievalCode>
</Data>
<Data name="UpdateColumnList">
<RetrievalCode> s {UpdateColumnList}=$s($d(^oddCOM({L1},"t",{L3},28))#2:^(28),$d(^oddCOM($g(^(2),{L1}),"t",{L3},28))#2:^(28),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},28))#2:^(28),1:""))
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddCOM({L1},"t",{L3},27))#2:^(27),$d(^oddCOM($g(^(2),{L1}),"t",{L3},27))#2:^(27),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},27))#2:^(27),1:""))
</RetrievalCode>
</Data>
<Data name="_Time">
<RetrievalCode> s {_Time}=$s($d(^oddCOM({L1},"t",{L3},25))#2:^(25),$d(^oddCOM($g(^(2),{L1}),"t",{L3},25))#2:^(25),1:$s($d(^oddDEF($g(^oddCOM({L1},"t",{L3},2),{L1}),"t",{L3},25))#2:^(25),1:"BEFORE"))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledTriggerQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASStrigger)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledUDLText">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledUDLTextQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.546656</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>UDLTexts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Category">
<Description>
Category</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Content">
<Description>
Holds the content of the UDL text.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Name">
<Description>
Speficies the COS name of the UDL text.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Position">
<Description>
Position</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="TextType">
<Description>
TextType</Description>
<Type>%Integer</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSudltext,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSudltext,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Category=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTkeywordmodified)
 . s i%Position=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber)
 . s i%TextType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype)
 . s i%Content=""
 . f ptr=1:1:$$$comMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent) d
 . . d ..Content.WriteLine($$$comMemberArrayGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,ptr))
 . d ..Content.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledUDLTextS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"u"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledUDLText.Name}</Expression>
</Subscript>
<Data name="Category">
<RetrievalCode> s {Category}=$s($d(^oddCOM({L1},"u",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"u",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},23))#2:^(23),1:"comment"))
</RetrievalCode>
</Data>
<Data name="Content">
<RetrievalCode> s {Content}=""
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"u",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"u",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"u",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"u",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="Position">
<RetrievalCode> s {Position}=$s($d(^oddCOM({L1},"u",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"u",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},24))#2:^(24),1:"body"))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"u",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"u",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="TextType">
<RetrievalCode> s {TextType}=$s($d(^oddCOM({L1},"u",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"u",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"u",{L3},2),{L1}),"u",{L3},22))#2:^(22),1:0))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledUDLTextQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSudltext)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.CompiledXData">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.CompiledXDataQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.648962</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.CompiledClass</Type>
<Cardinality>parent</Cardinality>
<Inverse>XDatas</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Data">
<Description>
The data stream.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this XDATA is deprecated.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="Description">
<Description>
Specifies a description of the XData.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordError">
<Description>
KeywordError</Description>
<Type>%Boolean</Type>
</Property>

<Property name="KeywordModified">
<Description>
KeywordModified</Description>
<Type>%Boolean</Type>
</Property>

<Property name="MimeType">
<Description>
Mime type of XData block.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
The name of the xData block.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Origin">
<Description>
Origin</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SchemaSpec">
<Description>
The schema definition of the data.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
</Property>

<Property name="XMLNamespace">
<Description>
The default XML NameSpace for the XDATA.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> set %ok=0
 set %msg="Delete operation not supported on this table."
</Code>
<Event>DELETE</Event>
<Time>BEFORE</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotNewCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Property name="Object">
<Description>
The object representation of this XData block after correlating the XML and importing it</Description>
<Type>%RegisteredObject</Type>
<Calculated>1</Calculated>
</Property>

<Method name="ObjectGet">
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[ q ##class(%Studio.SASchemaUtil).returnCorrelated($this)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$comMemberDefined(name1,$$$cCLASSxdata,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$comMemberDefined(name1,$$$cCLASSxdata,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Deprecated=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated)
 . s i%Description=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAdescription)
 . s i%Internal=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAinternal)
 . s i%KeywordError=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAkeyworderror)
 . s i%KeywordModified=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAkeywordmodified)
 . s i%MimeType=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype)
 . s i%Origin=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAorigin)
 . s i%SchemaSpec=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec)
 . s i%SequenceNumber=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber)
 . s i%XMLNamespace=$$$comMemberKeyGetO(origin,name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace)
 . s i%Data=""
 . f ptr=1:1:$$$comMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata) d
 . . d ..Data.WriteLine($$$comMemberArrayGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,ptr))
 . d ..Data.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ q $$$ERROR($$$CanNotSaveCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$CanNotDeleteCompiledDictionaryClasses)
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.CompiledXDataS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddCOM</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.CompiledClass.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"x"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.CompiledXData.Name}</Expression>
</Subscript>
<Data name="Data">
<RetrievalCode> s {Data}=""
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddCOM({L1},"x",{L3},17))#2:^(17),$d(^oddCOM($g(^(2),{L1}),"x",{L3},17))#2:^(17),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},17))#2:^(17),1:0))
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddCOM({L1},"x",{L3},4))#2:^(4),$d(^oddCOM($g(^(2),{L1}),"x",{L3},4))#2:^(4),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},4))#2:^(4),1:""))
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddCOM({L1},"x",{L3},14))#2:^(14),$d(^oddCOM($g(^(2),{L1}),"x",{L3},14))#2:^(14),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},14))#2:^(14),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordError">
<RetrievalCode> s {KeywordError}=$s($d(^oddCOM({L1},"x",{L3},12))#2:^(12),$d(^oddCOM($g(^(2),{L1}),"x",{L3},12))#2:^(12),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},12))#2:^(12),1:0))
</RetrievalCode>
</Data>
<Data name="KeywordModified">
<RetrievalCode> s {KeywordModified}=$s($d(^oddCOM({L1},"x",{L3},13))#2:^(13),$d(^oddCOM($g(^(2),{L1}),"x",{L3},13))#2:^(13),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},13))#2:^(13),1:0))
</RetrievalCode>
</Data>
<Data name="MimeType">
<RetrievalCode> s {MimeType}=$s($d(^oddCOM({L1},"x",{L3},24))#2:^(24),$d(^oddCOM($g(^(2),{L1}),"x",{L3},24))#2:^(24),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},24))#2:^(24),1:"text/xml"))
</RetrievalCode>
</Data>
<Data name="Origin">
<RetrievalCode> s {Origin}=$s($d(^oddCOM({L1},"x",{L3},2))#2:^(2),$d(^oddCOM($g(^(2),{L1}),"x",{L3},2))#2:^(2),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},2))#2:^(2),1:""))
</RetrievalCode>
</Data>
<Data name="SchemaSpec">
<RetrievalCode> s {SchemaSpec}=$s($d(^oddCOM({L1},"x",{L3},22))#2:^(22),$d(^oddCOM($g(^(2),{L1}),"x",{L3},22))#2:^(22),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},22))#2:^(22),1:""))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddCOM({L1},"x",{L3},11))#2:^(11),$d(^oddCOM($g(^(2),{L1}),"x",{L3},11))#2:^(11),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},11))#2:^(11),1:0))
</RetrievalCode>
</Data>
<Data name="XMLNamespace">
<RetrievalCode> s {XMLNamespace}=$s($d(^oddCOM({L1},"x",{L3},23))#2:^(23),$d(^oddCOM($g(^(2),{L1}),"x",{L3},23))#2:^(23),1:$s($d(^oddDEF($g(^oddCOM({L1},"x",{L3},2),{L1}),"x",{L3},23))#2:^(23),1:""))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.CompiledXDataQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSxdata)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.CompiledClassQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.ForeignKeyDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.ForeignKeyDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.600833</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>ForeignKeys</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Deprecated">
<Description>
True if this foreign key is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Supplies a description of the foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
Defines a name for the key. It must be a valid class member name and must not conflict with any existing member name.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoCheck">
<Description>
NoCheck</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="OnDelete">
<Description>
Specifies what referential action to take when the key value is deleted from the foreign table.</Description>
<Type>%CacheString</Type>
<InitialExpression>"noaction"</InitialExpression>
</Property>

<Property name="OnUpdate">
<Description>
Specifies what referential action to take when the key value is updated in the foreign table.</Description>
<Type>%CacheString</Type>
<InitialExpression>"noaction"</InitialExpression>
</Property>

<Property name="Properties">
<Description>
Specifies one or more properties whose values are used to constrain the value of the foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReferencedClass">
<Description>
Specifies the name of the class containing the key referred to by this foreign key definition.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReferencedKey">
<Description>
Specifies the key name of a unique index within a class that provides the set of allowed values for this foreign key.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlName">
<Description>
Specifies an alternate name for this foreign key when referred to via SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="OnDeleteIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="cascade" q $$$OK
 i val="noaction" q $$$OK
 i val="setdefault" q $$$OK
 i val="setnull" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ForeignKeyDefinition:OnDelete",val)
]]></Implementation>
</Method>

<Method name="OnUpdateIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="cascade" q $$$OK
 i val="noaction" q $$$OK
 i val="setdefault" q $$$OK
 i val="setnull" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.ForeignKeyDefinition:OnUpdate",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSfkey,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSfkey,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYdescription)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYinternal)
 . s i%NoCheck=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck)
 . s i%OnDelete=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYondelete)
 . s i%OnUpdate=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate)
 . s i%Properties=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYproperties)
 . s i%ReferencedClass=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass)
 . s i%ReferencedKey=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber)
 . s i%SqlName=$$$defMemberKeyGet(name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSfkey,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSfkey,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYinternal,i%Internal) }
 . i i%NoCheck=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck,i%NoCheck) }
 . i i%OnDelete="noaction" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYondelete) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYondelete,i%OnDelete) }
 . i i%OnUpdate="noaction" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate,i%OnUpdate) }
 . i i%Properties="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYproperties) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYproperties,i%Properties) }
 . i i%ReferencedClass="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass,i%ReferencedClass) }
 . i i%ReferencedKey="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey,i%ReferencedKey) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname,i%SqlName) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSfkey,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.ForeignKeyDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSfkey,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYinternal,i%Internal) }
 . i i%NoCheck=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYnocheck,i%NoCheck) }
 . i i%OnDelete="noaction" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYondelete) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYondelete,i%OnDelete) }
 . i i%OnUpdate="noaction" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYonupdate,i%OnUpdate) }
 . i i%Properties="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYproperties) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYproperties,i%Properties) }
 . i i%ReferencedClass="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedclass,i%ReferencedClass) }
 . i i%ReferencedKey="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYreferencedkey,i%ReferencedKey) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSfkey,name2,$$$cFKEYsqlname,i%SqlName) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSfkey,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSfkey,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.ForeignKeyDD81DS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"f"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.ForeignKeyDefinition.Name}</Expression>
</Subscript>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"f",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"f",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"f",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="NoCheck">
<RetrievalCode> s {NoCheck}=$s($d(^oddDEF({L1},"f",{L3},27))#2:^(27),1:0)
</RetrievalCode>
</Data>
<Data name="OnDelete">
<RetrievalCode> s {OnDelete}=$s($d(^oddDEF({L1},"f",{L3},21))#2:^(21),1:"noaction")
</RetrievalCode>
</Data>
<Data name="OnUpdate">
<RetrievalCode> s {OnUpdate}=$s($d(^oddDEF({L1},"f",{L3},22))#2:^(22),1:"noaction")
</RetrievalCode>
</Data>
<Data name="Properties">
<RetrievalCode> s {Properties}=$s($d(^oddDEF({L1},"f",{L3},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
<Data name="ReferencedClass">
<RetrievalCode> s {ReferencedClass}=$s($d(^oddDEF({L1},"f",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="ReferencedKey">
<RetrievalCode> s {ReferencedKey}=$s($d(^oddDEF({L1},"f",{L3},25))#2:^(25),1:"")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"f",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddDEF({L1},"f",{L3},26))#2:^(26),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.ForeignKeyDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSfkey)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.IndexDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.IndexDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.608999</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Indices</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Condition">
<Description>
In the case of a conditional index, specifies the condition that must be met for an entry to be included in the index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Specifies a list of properties whose values are to be stored within this index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this index is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the index.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Extent">
<Description>
An extent index is used to keep track of which object instances belong to a subclass. When using bitmap indices, then an extent index is automatically maintained and there is no need to define one.</Description>
<Type>%Boolean</Type>
<ClientName>_Extent</ClientName>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="IdKey">
<Description>
Specifies that the property or properties defined for this index will be used to form the Object Identity value for this object. This value is used to uniquely locate persistent object instances. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the index.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="PrimaryKey">
<Description>
Specifies that this index should be reported, via SQL, as being the Primary Key for this class. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Properties">
<Description>
Specifies a list of properties used to build this index. May also include a collation specification for each property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlName">
<Description>
Defines an alternate name for this index when referred to via SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description><![CDATA[
Specifies the type of the index. Type &#39;key&#39; is deprecated.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="TypeClass">
<Description>
Specifies the FunctionalIndex class used to provide the implementation of the functional index interface.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="Unique">
<Description>
Specifies whether this is a unique index.  The property or properties indexed by a unique index are constrained to have unique values.  This means that no two instances can have the same collated value within the extent among the set of all objects of the class that defines the index.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<SqlFieldName>_Unique</SqlFieldName>
</Property>

<Method name="TypeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="bitmap" q $$$OK
 i val="bitslice" q $$$OK
 i val="index" q $$$OK
 i val="collatedkey" q $$$OK
 i val="key" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.IndexDefinition:Type",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSindex,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSindex,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Condition=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXcondition)
 . s i%Data=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXdata)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXdescription)
 . s i%Extent=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXextent)
 . s i%IdKey=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXidkey)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXinternal)
 . s i%PrimaryKey=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey)
 . s i%Properties=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXproperties)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber)
 . s i%SqlName=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXsqlname)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXtype)
 . s i%TypeClass=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass)
 . s i%Unique=$$$defMemberKeyGet(name1,$$$cCLASSindex,name2,$$$cINDEXunique)
 . s sub="" f  s sub=$$$defSubMemberNext(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$defMemberArrayGet(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSindex,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSindex,name2,"")
 . i i%Condition="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXcondition) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXcondition,i%Condition) }
 . i i%Data="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdata) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdata,i%Data) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdescription,i%Description) }
 . i i%Extent=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXextent) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXextent,i%Extent) }
 . i i%IdKey=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXidkey) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXidkey,i%IdKey) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXinternal,i%Internal) }
 . i i%PrimaryKey=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey,i%PrimaryKey) }
 . i i%Properties="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXproperties) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXproperties,i%Properties) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXsqlname,i%SqlName) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXtype) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXtype,i%Type) }
 . i i%TypeClass="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass,i%TypeClass) }
 . i i%Unique=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXunique) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXunique,i%Unique) }
 . $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub,..Parameters.GetAt(sub))
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSindex,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.IndexDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSindex,name2,"")
 . i i%Condition="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXcondition) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXcondition,i%Condition) }
 . i i%Data="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdata) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdata,i%Data) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXdescription,i%Description) }
 . i i%Extent=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXextent) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXextent,i%Extent) }
 . i i%IdKey=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXidkey) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXidkey,i%IdKey) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXinternal,i%Internal) }
 . i i%PrimaryKey=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXprimarykey,i%PrimaryKey) }
 . i i%Properties="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXproperties) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXproperties,i%Properties) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXsqlname,i%SqlName) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXtype) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXtype,i%Type) }
 . i i%TypeClass="" { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXtypeclass,i%TypeClass) }
 . i i%Unique=0 { $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXunique) } else { $$$defMemberKeySet(name1,$$$cCLASSindex,name2,$$$cINDEXunique,i%Unique) }
 . $$$defMemberKeyKill(name1,$$$cCLASSindex,name2,$$$cINDEXparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSindex,name2,$$$cINDEXparameter,sub,..Parameters.GetAt(sub))
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSindex,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSindex,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.IndexDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"i"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.IndexDefinition.Name}</Expression>
</Subscript>
<Data name="Condition">
<RetrievalCode> s {Condition}=$s($d(^oddDEF({L1},"i",{L3},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
<Data name="Data">
<RetrievalCode> s {Data}=$s($d(^oddDEF({L1},"i",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"i",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"i",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Extent">
<RetrievalCode> s {Extent}=$s($d(^oddDEF({L1},"i",{L3},25))#2:^(25),1:0)
</RetrievalCode>
</Data>
<Data name="IdKey">
<RetrievalCode> s {IdKey}=$s($d(^oddDEF({L1},"i",{L3},26))#2:^(26),1:0)
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"i",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddDEF({L1},"i",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$g(^oddDEF({L1},"i",{L3},"P",sub))))
</RetrievalCode>
</Data>
<Data name="PrimaryKey">
<RetrievalCode> s {PrimaryKey}=$s($d(^oddDEF({L1},"i",{L3},27))#2:^(27),1:0)
</RetrievalCode>
</Data>
<Data name="Properties">
<RetrievalCode> s {Properties}=$s($d(^oddDEF({L1},"i",{L3},28))#2:^(28),1:"")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"i",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddDEF({L1},"i",{L3},29))#2:^(29),1:"")
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"i",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
<Data name="TypeClass">
<RetrievalCode> s {TypeClass}=$s($d(^oddDEF({L1},"i",{L3},33))#2:^(33),1:"")
</RetrievalCode>
</Data>
<Data name="_Unique">
<RetrievalCode> s {_Unique}=$s($d(^oddDEF({L1},"i",{L3},31))#2:^(31),1:0)
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.IndexDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSindex)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.LegacyQuery">
<Description>
This class contains SQL queries to replace old queries in %Library.ClassDefinition et al. classes.</Description>
<Abstract>1</Abstract>
<System>4</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>61592,42801.890775</TimeCreated>

<Query name="CompiledPropertyInfo">
<Description>
This query is to supersede query %Library.CompiledProperty:PropertyInfo</Description>
<Type>%SQLQuery</Type>
<FormalSpec>pClassName:%String</FormalSpec>
<SqlName>CompiledPropertyInfo</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery><![CDATA[SELECT CompiledProperty.Name AS PropertyName,
	CASE WHEN TypeClass.ClassType = 'datatype' THEN 1 ELSE 0 END AS Datatype,
	CompiledProperty.Type,
	CompiledProperty.Collection,
	coalesce(%Dictionary.GetParameterValue(CompiledProperty.Parameters,'CAPTION'),CompiledProperty.Name) AS Caption,
	CASE WHEN TypeClass.ClassType = 'serial' THEN 1 ELSE 0 END AS Serial,
	CASE WHEN CompiledProperty.Calculated = 0 THEN 1 WHEN ( SetMethod.Runnable <> 0 OR SetMethod.Stub IS NOT NULL ) THEN 1 ELSE 0 END AS Editable,
	%Dictionary.GetParameterValue(CompiledProperty.Parameters,'MAXLEN') AS MaxLen,
	CompiledProperty.Required,
	CASE WHEN TypeClass.ClassType = 'stream' THEN TypeClass.ClientDataType ELSE NULL END AS Stream
FROM %Dictionary.CompiledProperty AS CompiledProperty
	LEFT OUTER JOIN %Dictionary.CompiledMethod AS SetMethod ON CompiledProperty.Parent = SetMethod.Parent AND SetMethod.Name = ( CompiledProperty.Name || 'Set' )
	LEFT OUTER JOIN %Dictionary.CompiledClass AS TypeClass ON CompiledProperty.Type = TypeClass.Name
WHERE CompiledProperty.parent = :pClassName
	AND CompiledProperty.Private = 0]]></SqlQuery>
</Query>

<Query name="CompiledQueryInfo">
<Description>
This query is to supersede query %Library.CompiledQuery:QueryInfo</Description>
<Type>%SQLQuery</Type>
<FormalSpec>pClassName:%String</FormalSpec>
<SqlName>CompiledQueryInfo</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT Name AS Name,
	%Dictionary.GetParameterValue(Parameters,'CONTAINID') AS ContainId
FROM %Dictionary.CompiledQuery WHERE parent = :pClassName</SqlQuery>
<Parameter name="ROWSPEC" value="Name:%String:QueryName,ContainId:%String"/>
</Query>

<Query name="CompiledIndexInfo">
<Description>
This query is to supersede query %Library.CompiledClass:IndexInfo</Description>
<Type>%SQLQuery</Type>
<FormalSpec>pClassName:%String</FormalSpec>
<SqlName>CompiledIndexInfo</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT Name,
	Properties AS Attributes,
	CASE WHEN IdKey = 1 THEN 'idkey' WHEN Extent = 1 THEN 'extent' ELSE Type END AS Type,
	PrimaryKey,
	_Unique
FROM %Dictionary.CompiledIndex WHERE parent = :pClassName</SqlQuery>
<Parameter name="ROWSPEC" value="Name:%String,Attributes:%String,Type:%String,PrimaryKey:%Integer,Unique:%Integer"/>
</Query>
</Class>


<Class name="%Dictionary.MethodDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.MethodDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.622609</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Methods</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Specifies that this is an abstract method. An abstract method has no implementation and has no executable code generated for it. Abstract methods exist solely for the purpose of defining a method signature or interface that can be overridden and implemented within one or more subclasses. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ClassMethod">
<Description>
Specifies that the method is a class method.  Instance methods can only be invoked via an instantiated object while class methods can be directly invoked without an object instance. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ClientMethod">
<Description>
If true this method is only available on the server, and is to be projected as a client method.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: as a routine call, lines of code to be compiled, an expression, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
<InitialExpression>"code"</InitialExpression>
</Property>

<Property name="Deprecated">
<Description>
True if this method is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExternalProcName">
<Description>
Specifies the SQL procedure name in the foreign database.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the implementation of the method.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ForceGenerate">
<Description>
When true we always regenerate this method into each subclass even if normal rules would allow us to call the superclass implementation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="GenerateAfter">
<Description>
In the case of a method generator method, specifies that the generator should be invoked after the listed methods are generated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Hash">
<Description>
Hash</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Implementation">
<Description>
The code that is executed when the method is invoked. In the case of an expression method, this is an expression. In the case of a call method, this is the name of a Cache routine to call.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Language">
<Description>
The language used to implement this method.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the method.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoContext">
<Description><![CDATA[
If true and in a datatype method, this prevents the * Set %val=..prop Set $this=&quot;&quot; * that is added to the property method so you can override things like the Get/Set methods.]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NotForProperty">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this method is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="PlaceAfter">
<Description>
Specifies that the class compiler should place this method after the listed methods in the routine it creates for the class.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Private">
<Description>
Specifies that the method is private. Private methods can only be invoked by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ProcedureBlock">
<Description>
Specifies that this method uses procedure block for method code.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PublicList">
<Description>
Specifies the public list.  This keyword is used only if the ProcedureBlock keyword is set to true.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ReturnResultsets">
<Description>
If true this method may return zero, one, or more Resultsets in the %sqlcontext.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ReturnType">
<Description>
Specifies the data type of the value returned by a call to the method. Setting ReturnType to an empty string specifies that there is no return value.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="ReturnTypeParams">
<Description>
A comma separated list of any parameters on the ReturnType keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a method will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapAction">
<Description>
Lets you specify the HTTP SOAP action that must be used when invoking this web service method as a web method. For SOAP 1.1, the SOAP action is obtained from the SOAPAction HTTP header. For SOAP 1.2, it is obtained from the Content-Type HTTP header.</Description>
<Type>%CacheString</Type>
<InitialExpression>"[default]"</InitialExpression>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapMessageName">
<Description>
Specifies the name of the child element of the body of the response message for a web service method.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
Overrides the SOAPNAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapRequestMessage">
<Description>
 This keyword will reflects the expected element name for top element of the SOAP body in the SOAP request.  This element is needed to distinguish between multiple requests which have the same SoapAction but different top level body elements.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapTypeNameSpace">
<Description>
Overrides the SOAPTYPENAMESPACE class parameter for this web service or web service client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this method is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the method can be invoked as an SQL stored procedure. Only class methods can be called as SQL stored procedures.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlRoutine">
<Description><![CDATA[
If &#39;procedure&#39; then this is equivalent to SqlProc keyword and means class method can be called as an SQL procedure. If &#39;function&#39; then this class method can be called as an SQL function.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="WebMethod">
<Description>
Specifies that a method can be invoked as a web method using the SOAP protocol.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ZenMethod">
<Description>
Specifies that the method should be projected to the web client for use in the Zen framework.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="CodeModeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="call" q $$$OK
 i val="code" q $$$OK
 i val="expression" q $$$OK
 i val="generator" q $$$OK
 i val="objectgenerator" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:CodeMode",val)
]]></Implementation>
</Method>

<Method name="ProcedureBlockIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="0" q $$$OK
 i val="1" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:ProcedureBlock",val)
]]></Implementation>
</Method>

<Method name="ServerOnlyIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="0" q $$$OK
 i val="1" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:ServerOnly",val)
]]></Implementation>
</Method>

<Method name="SoapBindingStyleIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="document" q $$$OK
 i val="rpc" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:SoapBindingStyle",val)
]]></Implementation>
</Method>

<Method name="SoapBodyUseIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="literal" q $$$OK
 i val="encoded" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:SoapBodyUse",val)
]]></Implementation>
</Method>

<Method name="SqlRoutineIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="procedure" q $$$OK
 i val="function" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.MethodDefinition:SqlRoutine",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSmethod,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSmethod,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Abstract=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHabstract)
 . s i%ClassMethod=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod)
 . s i%ClientMethod=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod)
 . s i%ClientName=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHclientname)
 . s i%CodeMode=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHcodemode)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHdescription)
 . s i%ExternalProcName=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHfinal)
 . s i%ForceGenerate=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate)
 . s i%FormalSpec=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHformalspec)
 . s i%GenerateAfter=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter)
 . s i%Hash=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHhash)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHinternal)
 . s i%Language=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHlanguage)
 . s i%NoContext=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHnocontext)
 . s i%NotForProperty=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty)
 . s i%NotInheritable=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable)
 . s i%PlaceAfter=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter)
 . s i%Private=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHprivate)
 . s i%ProcedureBlock=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock)
 . s i%PublicList=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist)
 . s i%ReturnResultsets=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets)
 . s i%ReturnType=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntype)
 . s i%ReturnTypeParams=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber)
 . s i%ServerOnly=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHserveronly)
 . s i%SoapAction=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction)
 . s i%SoapBindingStyle=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle)
 . s i%SoapBodyUse=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse)
 . s i%SoapMessageName=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename)
 . s i%SoapNameSpace=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace)
 . s i%SoapRequestMessage=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage)
 . s i%SoapTypeNameSpace=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace)
 . s i%SqlName=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlname)
 . s i%SqlProc=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc)
 . s i%SqlRoutine=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine)
 . s i%WebMethod=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod)
 . s i%ZenMethod=$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod)
 . s i%Implementation=""
 . f ptr=1:1:$$$defMemberKeyGet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation) d
 . . d ..Implementation.WriteLine($$$defMemberArrayGet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,ptr))
 . d ..Implementation.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSmethod,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSmethod,name2,"")
 . i i%Abstract=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHabstract) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHabstract,i%Abstract) }
 . i i%ClassMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod,i%ClassMethod) }
 . i i%ClientMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod,i%ClientMethod) }
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclientname,i%ClientName) }
 . i i%CodeMode="code" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHcodemode) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHcodemode,i%CodeMode) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHdescription,i%Description) }
 . i i%ExternalProcName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname,i%ExternalProcName) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHfinal,i%Final) }
 . i i%ForceGenerate=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate,i%ForceGenerate) }
 . i i%FormalSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHformalspec) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHformalspec,i%FormalSpec) }
 . i i%GenerateAfter="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter,i%GenerateAfter) }
 . i i%Hash="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHhash) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHhash,i%Hash) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHinternal,i%Internal) }
 . i i%Language="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHlanguage) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHlanguage,i%Language) }
 . i i%NoContext=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnocontext) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnocontext,i%NoContext) }
 . i i%NotForProperty=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty,i%NotForProperty) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable,i%NotInheritable) }
 . i i%PlaceAfter="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter,i%PlaceAfter) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHprivate,i%Private) }
 . i i%ProcedureBlock="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock,i%ProcedureBlock) }
 . i i%PublicList="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist,i%PublicList) }
 . i i%ReturnResultsets=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets,i%ReturnResultsets) }
 . i i%ReturnType="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturntype) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntype,i%ReturnType) }
 . i i%ReturnTypeParams="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams,i%ReturnTypeParams) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber,i%SequenceNumber) }
 . i i%ServerOnly="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHserveronly) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHserveronly,i%ServerOnly) }
 . i i%SoapAction="[default]" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction,i%SoapAction) }
 . i i%SoapBindingStyle="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle,i%SoapBindingStyle) }
 . i i%SoapBodyUse="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse,i%SoapBodyUse) }
 . i i%SoapMessageName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename,i%SoapMessageName) }
 . i i%SoapNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace,i%SoapNameSpace) }
 . i i%SoapRequestMessage="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage,i%SoapRequestMessage) }
 . i i%SoapTypeNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace,i%SoapTypeNameSpace) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlname,i%SqlName) }
 . i i%SqlProc=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc,i%SqlProc) }
 . i i%SqlRoutine="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine,i%SqlRoutine) }
 . i i%WebMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod,i%WebMethod) }
 . i i%ZenMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod,i%ZenMethod) }
 . $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation)
 . d ..Implementation.Rewind() s ..Implementation.LineTerminator=$c(10)
 . f line=1:1 q:..Implementation.AtEnd  d
 . . s linetext=..Implementation.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,line-1)
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSmethod,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.MethodDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSmethod,name2,"")
 . i i%Abstract=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHabstract) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHabstract,i%Abstract) }
 . i i%ClassMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclassmethod,i%ClassMethod) }
 . i i%ClientMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclientmethod,i%ClientMethod) }
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHclientname,i%ClientName) }
 . i i%CodeMode="code" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHcodemode) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHcodemode,i%CodeMode) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHdescription,i%Description) }
 . i i%ExternalProcName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHexternalprocname,i%ExternalProcName) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHfinal,i%Final) }
 . i i%ForceGenerate=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHforcegenerate,i%ForceGenerate) }
 . i i%FormalSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHformalspec) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHformalspec,i%FormalSpec) }
 . i i%GenerateAfter="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHgenerateafter,i%GenerateAfter) }
 . i i%Hash="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHhash) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHhash,i%Hash) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHinternal,i%Internal) }
 . i i%Language="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHlanguage) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHlanguage,i%Language) }
 . i i%NoContext=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnocontext) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnocontext,i%NoContext) }
 . i i%NotForProperty=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnotforproperty,i%NotForProperty) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHnotinheritable,i%NotInheritable) }
 . i i%PlaceAfter="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHplaceafter,i%PlaceAfter) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHprivate,i%Private) }
 . i i%ProcedureBlock="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHprocedureblock,i%ProcedureBlock) }
 . i i%PublicList="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHpubliclist,i%PublicList) }
 . i i%ReturnResultsets=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturnresultsets,i%ReturnResultsets) }
 . i i%ReturnType="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturntype) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntype,i%ReturnType) }
 . i i%ReturnTypeParams="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHreturntypeparams,i%ReturnTypeParams) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsequencenumber,i%SequenceNumber) }
 . i i%ServerOnly="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHserveronly) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHserveronly,i%ServerOnly) }
 . i i%SoapAction="[default]" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapaction,i%SoapAction) }
 . i i%SoapBindingStyle="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbindingstyle,i%SoapBindingStyle) }
 . i i%SoapBodyUse="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapbodyuse,i%SoapBodyUse) }
 . i i%SoapMessageName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapmessagename,i%SoapMessageName) }
 . i i%SoapNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoapnamespace,i%SoapNameSpace) }
 . i i%SoapRequestMessage="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaprequestmessage,i%SoapRequestMessage) }
 . i i%SoapTypeNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsoaptypenamespace,i%SoapTypeNameSpace) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlname,i%SqlName) }
 . i i%SqlProc=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlproc,i%SqlProc) }
 . i i%SqlRoutine="" { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHsqlroutine,i%SqlRoutine) }
 . i i%WebMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHwebmethod,i%WebMethod) }
 . i i%ZenMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHzenmethod,i%ZenMethod) }
 . d ..Implementation.Rewind() s ..Implementation.LineTerminator=$c(10)
 . f line=1:1 q:..Implementation.AtEnd  d
 . . s linetext=..Implementation.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSmethod,name2,$$$cMETHimplementation,line-1)
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSmethod,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSmethod,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.MethodDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"m"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.MethodDefinition.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddDEF({L1},"m",{L3},21))#2:^(21),1:0)
</RetrievalCode>
</Data>
<Data name="ClassMethod">
<RetrievalCode> s {ClassMethod}=$s($d(^oddDEF({L1},"m",{L3},23))#2:^(23),1:0)
</RetrievalCode>
</Data>
<Data name="ClientMethod">
<RetrievalCode> s {ClientMethod}=$s($d(^oddDEF({L1},"m",{L3},70))#2:^(70),1:0)
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddDEF({L1},"m",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddDEF({L1},"m",{L3},25))#2:^(25),1:"code")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"m",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"m",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="ExternalProcName">
<RetrievalCode> s {ExternalProcName}=$s($d(^oddDEF({L1},"m",{L3},63))#2:^(63),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"m",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="ForceGenerate">
<RetrievalCode> s {ForceGenerate}=$s($d(^oddDEF({L1},"m",{L3},71))#2:^(71),1:0)
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddDEF({L1},"m",{L3},27))#2:^(27),1:"")
</RetrievalCode>
</Data>
<Data name="GenerateAfter">
<RetrievalCode> s {GenerateAfter}=$s($d(^oddDEF({L1},"m",{L3},29))#2:^(29),1:"")
</RetrievalCode>
</Data>
<Data name="Hash">
<RetrievalCode> s {Hash}=$s($d(^oddDEF({L1},"m",{L3},66))#2:^(66),1:"")
</RetrievalCode>
</Data>
<Data name="Implementation">
<RetrievalCode> s {Implementation}=""
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"m",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="NoContext">
<RetrievalCode> s {NoContext}=$s($d(^oddDEF({L1},"m",{L3},33))#2:^(33),1:0)
</RetrievalCode>
</Data>
<Data name="NotForProperty">
<RetrievalCode> s {NotForProperty}=$s($d(^oddDEF({L1},"m",{L3},34))#2:^(34),1:0)
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddDEF({L1},"m",{L3},9))#2:^(9),1:0)
</RetrievalCode>
</Data>
<Data name="PlaceAfter">
<RetrievalCode> s {PlaceAfter}=$s($d(^oddDEF({L1},"m",{L3},38))#2:^(38),1:"")
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddDEF({L1},"m",{L3},39))#2:^(39),1:0)
</RetrievalCode>
</Data>
<Data name="ProcedureBlock">
<RetrievalCode> s {ProcedureBlock}=$s($d(^oddDEF({L1},"m",{L3},40))#2:^(40),1:"")
</RetrievalCode>
</Data>
<Data name="PublicList">
<RetrievalCode> s {PublicList}=$s($d(^oddDEF({L1},"m",{L3},41))#2:^(41),1:"")
</RetrievalCode>
</Data>
<Data name="ReturnResultsets">
<RetrievalCode> s {ReturnResultsets}=$s($d(^oddDEF({L1},"m",{L3},64))#2:^(64),1:0)
</RetrievalCode>
</Data>
<Data name="ReturnType">
<RetrievalCode> s {ReturnType}=$s($d(^oddDEF({L1},"m",{L3},42))#2:^(42),1:"")
</RetrievalCode>
</Data>
<Data name="ReturnTypeParams">
<RetrievalCode> s {ReturnTypeParams}=$s($d(^oddDEF({L1},"m",{L3},62))#2:^(62),1:"")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"m",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddDEF({L1},"m",{L3},59))#2:^(59),1:"")
</RetrievalCode>
</Data>
<Data name="SoapAction">
<RetrievalCode> s {SoapAction}=$s($d(^oddDEF({L1},"m",{L3},67))#2:^(67),1:"[default]")
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddDEF({L1},"m",{L3},53))#2:^(53),1:"")
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddDEF({L1},"m",{L3},54))#2:^(54),1:"")
</RetrievalCode>
</Data>
<Data name="SoapMessageName">
<RetrievalCode> s {SoapMessageName}=$s($d(^oddDEF({L1},"m",{L3},68))#2:^(68),1:"")
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddDEF({L1},"m",{L3},61))#2:^(61),1:"")
</RetrievalCode>
</Data>
<Data name="SoapRequestMessage">
<RetrievalCode> s {SoapRequestMessage}=$s($d(^oddDEF({L1},"m",{L3},73))#2:^(73),1:"")
</RetrievalCode>
</Data>
<Data name="SoapTypeNameSpace">
<RetrievalCode> s {SoapTypeNameSpace}=$s($d(^oddDEF({L1},"m",{L3},65))#2:^(65),1:"")
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddDEF({L1},"m",{L3},45))#2:^(45),1:"")
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddDEF({L1},"m",{L3},46))#2:^(46),1:0)
</RetrievalCode>
</Data>
<Data name="SqlRoutine">
<RetrievalCode> s {SqlRoutine}=$s($d(^oddDEF({L1},"m",{L3},74))#2:^(74),1:"")
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddDEF({L1},"m",{L3},51))#2:^(51),1:0)
</RetrievalCode>
</Data>
<Data name="ZenMethod">
<RetrievalCode> s {ZenMethod}=$s($d(^oddDEF({L1},"m",{L3},52))#2:^(52),1:0)
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddDEF({L1},"m",{L3},32))#2:^(32),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.MethodDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSmethod)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.PackageDefinition">
<Description><![CDATA[
This class represents a specific <i>package</i> description contained within the 
<i>Cach&eacute; Dictionary.</i>]]></Description>
<ProcedureBlock>0</ProcedureBlock>
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.PackageDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Name">
<Description>
A string containing the name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientName">
<Description>
A string containing the client name for the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Description">
<Description>
A string containing the description of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="GlobalPrefix">
<Description>
A string containing the global prefix of the package, used for data, id, and index locations.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OwnerName">
<Description>
A string containing the Owner's name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RtnPrefix">
<Description>
A string containing the routine prefix of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SQLName">
<Description>
A string containing the SQL name of the package.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="list">
<Type>%ListOfDataTypes</Type>
<Transient>1</Transient>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s i%Name=$g(initvalue)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define LOADVSTRING(%ivar,%global) s %ivar=$g(%global)
	i '$d($$$PACKAGE(id)) q $$$ERROR($$$LoadObjectNotFound)
	New name
	If $isobject($get(%SourceControl)) New rc,tmp Do  If $$$ISERR(rc) Quit rc
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnBeforeLoad(id_".PKG")
	s i%Name=id
	$$$LOADVSTRING(name,$$$PACKAGEname(i%Name)) i name'="" s i%Name=name
	$$$LOADVSTRING(i%ClientName,$$$PACKAGEclientname(i%Name))
	$$$LOADVSTRING(i%Description,$$$PACKAGEdescription(i%Name))
	$$$LOADVSTRING(i%GlobalPrefix,$$$PACKAGEglobalprefix(i%Name))
	$$$LOADVSTRING(i%OwnerName,$$$PACKAGEownername(i%Name))
	$$$LOADVSTRING(i%RtnPrefix,$$$PACKAGErtnprefix(i%Name))
	$$$LOADVSTRING(i%SQLName,$$$PACKAGEsqlname(i%Name))
	If $isobject($get(%SourceControl)) Do  If $$$ISERR(rc) Quit rc
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnAfterLoad(id_".PKG",$this)
	q $$$OK
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define SAVEOPTIONAL(%global,%ivar) s %global=%ivar k:%ivar="" %global
	i i%Name="" q $$$ERROR($$$PackageNameRequired)
	i id="" n sc s sc=..%IdSet(i%Name) i $$$ISERR(sc) q sc
	If $isobject($get(%SourceControl)) New rc,tmp Do  If $$$ISERR(rc) Quit rc
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnBeforeSave(i%Name_".PKG",$name(^oddPKG(i%Name)),$this)
	$$$SAVEOPTIONAL($$$PACKAGEname(i%Name),i%Name)
	$$$SAVEOPTIONAL($$$PACKAGEclientname(i%Name),i%ClientName)
	$$$SAVEOPTIONAL($$$PACKAGEdescription(i%Name),i%Description)
	$$$SAVEOPTIONAL($$$PACKAGEglobalprefix(i%Name),i%GlobalPrefix)
	$$$SAVEOPTIONAL($$$PACKAGEownername(i%Name),i%OwnerName)
	$$$SAVEOPTIONAL($$$PACKAGErtnprefix(i%Name),i%RtnPrefix)
	$$$SAVEOPTIONAL($$$PACKAGEsqlname(i%Name),i%SQLName)
	#; the top node is for system code to query
	s $$$PACKAGE(i%Name)=i%RtnPrefix
	If $isobject($get(%SourceControl)) Do  If $$$ISERR(rc) Quit rc
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnAfterSave(i%Name_".PKG",$this)
	q $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	i id="" q $$$ERROR($$$PackageNameRequired)
	If $isobject($get(%SourceControl)) New rc,tmp Do  If $$$ISERR(rc) Quit rc
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnBeforeDelete(id_".PKG")
	Set sc=$$DeletePackageDefinition^%apiOBJ(id,"-d")
	If $isobject($get(%SourceControl)) New rc,tmp Do  If $$$ISERR(rc) Set sc=$$$ADDSC(sc,rc)
	. Set tmp=%SourceControl New %SourceControl Set rc=tmp.OnAfterDelete(id_".PKG")
	Quit sc
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i i%Name="" q $$$ERROR($$$PackageNameRequired)
 i $l(i%GlobalPrefix)>31 q $$$ERROR($$$PackageGlobalPrefixTooLong)
 q $$$OK
]]></Implementation>
</Method>

<Method name="GetPackageList">
<ClassMethod>1</ClassMethod>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
 n package,packagelist,data
 s tList=##class(%ListOfDataTypes).%New()
 If $Get(^rINDEXCLASS)="" Do RebuildIndex^%R()
 s class="" 
 f  s class=$o(^rINDEXCLASS(class)) q:class=""  s package=$$$ClassPackageName(class) s:package'="" packagelist(package)=""
 s package="" 
 f  s package=$$$PACKAGEnext(package) q:package=""  s packagelist($zcvt(package,"u"))=""
 s package="" 
 f  s package=$o(packagelist(package)) q:package=""  d tList.Insert(package)
 q tList
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Diction.PackageDefinitionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
</Storage>
</Class>


<Class name="%Dictionary.PackageDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="SubPackage">
<Description><![CDATA[
The <b>SubPackage</b> query provides a list of sub-package names.
This query works in a hierarchical way, 
it returns only one level of sub-package under a specified <var>SuperPackage</var> name.]]></Description>
<Type>%Query</Type>
<FormalSpec>SuperPackage:%String=""</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SubPackageExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,SuperPackage:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set QHandle=$lb($g(SuperPackage),$zcvt($g(SuperPackage),"u"))
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubPackageFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..SubPackageFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="SubPackageFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set supername=$list(QHandle,1)
	Set superlength=$l(supername)
	Set subpiece=$s(supername="":1,1:$l(supername,".")+1)
	If '$get(FetchCount) Set FetchCount=10000
	If $get(AtEnd) Set QHandle="" Quit $$$OK
	Set AtEnd=0,RowSet="",ReturnCount=0
	Set class=$list(QHandle,2)
	For  {
		Set class=$o(^rINDEXCLASS(class))
		If class="" Set AtEnd=1 Quit
		Set package=$$$ClassPackageName($li(^rINDEXCLASS(class),2))
		If $e(package,1,superlength)'=supername Set AtEnd=1 Quit
		If superlength,$l(package)>superlength,$e(package,superlength+1)'="." Set AtEnd=1 Quit
		Set subpackage=$p(package,".",subpiece)
		If subpackage'="" {
			Set RowSet=RowSet_$lb(subpackage)
			Set ReturnCount=ReturnCount+1
			Set header=$p($li(^rINDEXCLASS(class),2),".",1,subpiece)
			Set class=$piece(class,".",1,subpiece)_"/"
			If ReturnCount'<FetchCount Quit
			If $length(RowSet)>20000 Quit
		}
	}
	Set QHandle=$lb(supername,class)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubPackageClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="FlatPackage">
<Description><![CDATA[
The <b>FlatPackage</b> query provides a list of flattened out package names.
Starting with ones beginning with <var>Prefix</var>]]></Description>
<Type>%Query</Type>
<FormalSpec>Prefix:%String=""</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="FlatPackageExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,Prefix:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set QHandle=$lb($zcvt($g(Prefix),"U"),$zcvt($g(Prefix),"U"),"")
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="FlatPackageFetch">
<Description><![CDATA[
<b>Fetch</b> returns the next row in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..FlatPackageFetchRows(.QHandle,1,.Row,,.AtEnd)
]]></Implementation>
</Method>

<Method name="FlatPackageFetchRows">
<Description><![CDATA[
<b>RoutineListFetchRows</b> returns the next <var>FetchCount</var> rows in the query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set prefix=$list(QHandle,1)
	Set prefixlength=$l(prefix)
	Set lastpackage=$list(QHandle,2)
	If '$get(FetchCount) Set FetchCount=10000
	If $get(AtEnd) Set QHandle="" Quit $$$OK
	Set AtEnd=0,RowSet="",ReturnCount=0
	Set class=$list(QHandle,2)
	For  {
		Set class=$o(^rINDEXCLASS(class))
		
		// Check for the end
		If class="" Set AtEnd=1 Quit
		
		// Grab the package name
		Set pkg=$$$ClassPackageName($li(^rINDEXCLASS(class),2))
		Set package=$ZCVT(pkg,"U")_"."

		// Check for a prefix match, ending if the prefix differs
		If $e(package,1,prefixlength)'=prefix Set AtEnd=1 Quit

		If $E(lastpackage,1,$L(package))'=package {
			// Add this to the results
			Set RowSet=RowSet_$lb(pkg)
			Set ReturnCount=ReturnCount+1
			Set lastpackage=package

			If ReturnCount'<FetchCount Quit
			If $length(RowSet)>20000 Quit
		}
	}
	// We need to remember where we were
	Set QHandle=$lb(prefix,package,lastpackage)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FlatPackageClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set QHandle=""
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.ParameterDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.ParameterDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.647594</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Parameters</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Abstract">
<Description>
Abstract</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Constraint">
<Description>
Specifies a constraint value is used by Cache Studio to provide input validation for the parameter. Its value is not used nor enforced by the Class Compiler.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Constraint</SqlFieldName>
</Property>

<Property name="Default">
<Description>
Specifies a default value for the parameter assuming the Expression keyword is blank.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Default</SqlFieldName>
</Property>

<Property name="Deprecated">
<Description>
True if this parameter is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Encoded">
<Description>
If true then the parameter value is base64 encoded.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Expression">
<Description>
An expression to seed parameter with evaluated at compile time, if specified this takes precedence over the Default keyword.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the parameter.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Flags">
<Description>
Specifies any additional modifier flags for the parameter type.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the parameter.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Description>
Specifies a type for the parameter. The type is used by Cache Studio to provide input validation for the parameter.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSparameter,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSparameter,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Abstract=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMabstract)
 . s i%Constraint=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint)
 . s i%Default=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMdefault)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMdescription)
 . s i%Encoded=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMencoded)
 . s i%Expression=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMexpression)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMfinal)
 . s i%Flags=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMflags)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMinternal)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSparameter,name2,$$$cPARAMtype)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSparameter,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSparameter,name2,"")
 . i i%Abstract=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMabstract) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMabstract,i%Abstract) }
 . i i%Constraint="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint,i%Constraint) }
 . i i%Default="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdefault) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdefault,i%Default) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdescription,i%Description) }
 . i i%Encoded=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMencoded) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMencoded,i%Encoded) }
 . i i%Expression="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMexpression,i%Expression) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMfinal,i%Final) }
 . i i%Flags="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMflags) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMflags,i%Flags) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMinternal,i%Internal) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber,i%SequenceNumber) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMtype) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMtype,i%Type) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSparameter,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.ParameterDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSparameter,name2,"")
 . i i%Abstract=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMabstract) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMabstract,i%Abstract) }
 . i i%Constraint="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMconstraint,i%Constraint) }
 . i i%Default="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdefault) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdefault,i%Default) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMdescription,i%Description) }
 . i i%Encoded=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMencoded) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMencoded,i%Encoded) }
 . i i%Expression="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMexpression,i%Expression) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMfinal,i%Final) }
 . i i%Flags="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMflags) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMflags,i%Flags) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMinternal,i%Internal) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMsequencenumber,i%SequenceNumber) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSparameter,name2,$$$cPARAMtype) } else { $$$defMemberKeySet(name1,$$$cCLASSparameter,name2,$$$cPARAMtype,i%Type) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSparameter,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSparameter,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.ParameterDeC43FS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"p"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.ParameterDefinition.Name}</Expression>
</Subscript>
<Data name="Abstract">
<RetrievalCode> s {Abstract}=$s($d(^oddDEF({L1},"p",{L3},24))#2:^(24),1:0)
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"p",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"p",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Encoded">
<RetrievalCode> s {Encoded}=$s($d(^oddDEF({L1},"p",{L3},27))#2:^(27),1:0)
</RetrievalCode>
</Data>
<Data name="Expression">
<RetrievalCode> s {Expression}=$s($d(^oddDEF({L1},"p",{L3},25))#2:^(25),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"p",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="Flags">
<RetrievalCode> s {Flags}=$s($d(^oddDEF({L1},"p",{L3},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"p",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"p",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"p",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
<Data name="_Constraint">
<RetrievalCode> s {_Constraint}=$s($d(^oddDEF({L1},"p",{L3},21))#2:^(21),1:"")
</RetrievalCode>
</Data>
<Data name="_Default">
<RetrievalCode> s {_Default}=$s($d(^oddDEF({L1},"p",{L3},22))#2:^(22),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.ParameterDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSparameter)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.ProjectionDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.ProjectionDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.812628</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Projections</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Deprecated">
<Description>
True if this projection is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the projection.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the projection.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
Specifies that this projection is not inherited in subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Description>
Specifies the name of the class associated with the projection.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSprojection,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSprojection,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJdescription)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJinternal)
 . s i%NotInheritable=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSprojection,name2,$$$cPROJtype)
 . s sub="" f  s sub=$$$defSubMemberNext(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$defMemberArrayGet(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSprojection,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSprojection,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJinternal,i%Internal) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable,i%NotInheritable) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber,i%SequenceNumber) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJtype) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJtype,i%Type) }
 . $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub,..Parameters.GetAt(sub))
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSprojection,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.ProjectionDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSprojection,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJinternal,i%Internal) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJnotinheritable,i%NotInheritable) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJsequencenumber,i%SequenceNumber) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJtype) } else { $$$defMemberKeySet(name1,$$$cCLASSprojection,name2,$$$cPROJtype,i%Type) }
 . $$$defMemberKeyKill(name1,$$$cCLASSprojection,name2,$$$cPROJparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSprojection,name2,$$$cPROJparameter,sub,..Parameters.GetAt(sub))
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSprojection,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSprojection,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.ProjectionD882AS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"j"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.ProjectionDefinition.Name}</Expression>
</Subscript>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"j",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"j",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"j",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddDEF({L1},"j",{L3},9))#2:^(9),1:0)
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddDEF({L1},"j",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$g(^oddDEF({L1},"j",{L3},"P",sub))))
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"j",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"j",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.ProjectionDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSprojection)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.PropertyDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.PropertyDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.679243</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Properties</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Aliases">
<Description>
List of aliases for this property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Calculated">
<Description>
Specifies that the property has no in-memory storage allocated for it when the object containing it is instantiated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Cardinality">
<Description>
Specifies the cardinality of a relationship property. The Cardinality keyword is required for relationship properties. It is ignored by non-relationship properties. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Collection">
<Description>
Specifies that a property is a collection property as well as what type of collection it is.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this property is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the property.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of this property.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Identity">
<Description>
Specifies that this property is the identity for this class. Identity properties can be set in new objects only and the default is set by incrementing a counter.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<SqlFieldName>_Identity</SqlFieldName>
</Property>

<Property name="InitialExpression">
<Description>
Specifies an initial value for the property.</Description>
<Type>%CacheString</Type>
<InitialExpression>""""""</InitialExpression>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Inverse">
<Description>
Specifies the name of the inverse side of a relationship. That is, the name of the corresponding relationship property in the related class. The inverse property must exist in the related class and have the correct Cardinality value. The Inverse keyword is required for relationship properties. It is ignored by non-relationship properties.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="MultiDimensional">
<Description>
Specifies that an attribute has the characteristics of a multidimensional array.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the property.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NoModBit">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NotInheritable">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="OnDelete">
<Description>
Specifies what referential action to take when the key value is deleted from the foreign table.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Private">
<Description>
Specifies that the property is private. Private properties can only be used by instance methods of this class or its subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ReadOnly">
<Description>
Specifies that the property is readonly.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Relationship">
<Description>
Specifies that a property is a relationship property. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Required">
<Description>
In the case of a persistent class, specifies that the value of the property must be given a value before it can be stored to disk.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ServerOnly">
<Description>
Specifies that a property will not be projected to a Java or C++ client.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlCollation">
<Description>
Deprecated.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlColumnNumber">
<Description>
Explicitly sets the SQL Column number for this property. This is provided for legacy application support.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputeCode">
<Description>
Specifies Cache ObjectScript code that evaluates to a computed field value. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlComputed">
<Description>
Specifies that this property is an SQL computed field.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlComputeOnChange">
<Description>
Specifies one or more properties whose modification triggers the recalculation of this computed field within SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlFieldName">
<Description>
In the case of a persistent class, specifies the column name used to identify the property in its SQL projection. By default, the SQL column name is the same as the property name.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlListDelimiter">
<Description>
Specifies the delimiter character used within SQL for lists. This is provided for legacy application support.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlListType">
<Description>
specifies the representation to be used for a list.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Transient">
<Description>
In the case of a persistent class, specifies that the property is not stored in the database.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Description>
Specifies the name of the class associated with the property, which can be a data type class, a persistent class, or an embeddable serial class.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="UDLTexts">
<Description>
UDLText</Description>
<Type>%Dictionary.PropertyUDLTextDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="CardinalityIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="one" q $$$OK
 i val="many" q $$$OK
 i val="parent" q $$$OK
 i val="children" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:Cardinality",val)
]]></Implementation>
</Method>

<Method name="CollectionIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="array" q $$$OK
 i val="list" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:Collection",val)
]]></Implementation>
</Method>

<Method name="OnDeleteIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="cascade" q $$$OK
 i val="noaction" q $$$OK
 i val="setdefault" q $$$OK
 i val="setnull" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:OnDelete",val)
]]></Implementation>
</Method>

<Method name="ServerOnlyIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="0" q $$$OK
 i val="1" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:ServerOnly",val)
]]></Implementation>
</Method>

<Method name="SqlCollationIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="ALPHAUP" q $$$OK
 i val="PLUS" q $$$OK
 i val="MINUS" q $$$OK
 i val="SPACE" q $$$OK
 i val="EXACT" q $$$OK
 i val="UPPER" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:SqlCollation",val)
]]></Implementation>
</Method>

<Method name="SqlListTypeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="DELIMITED" q $$$OK
 i val="LIST" q $$$OK
 i val="SUBNODE" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyDefinition:SqlListType",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSproperty,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSproperty,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Aliases=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPaliases)
 . s i%Calculated=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPcalculated)
 . s i%Cardinality=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPcardinality)
 . s i%ClientName=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPclientname)
 . s i%Collection=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPcollection)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPdescription)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPfinal)
 . s i%Identity=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPidentity)
 . s i%InitialExpression=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPinternal)
 . s i%Inverse=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPinverse)
 . s i%MultiDimensional=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional)
 . s i%NoModBit=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit)
 . s i%NotInheritable=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable)
 . s i%OnDelete=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPondelete)
 . s i%Private=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPprivate)
 . s i%ReadOnly=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPreadonly)
 . s i%Relationship=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPrelationship)
 . s i%Required=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPrequired)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber)
 . s i%ServerOnly=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPserveronly)
 . s i%SqlCollation=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation)
 . s i%SqlColumnNumber=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber)
 . s i%SqlComputeCode=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode)
 . s i%SqlComputed=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed)
 . s i%SqlComputeOnChange=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange)
 . s i%SqlFieldName=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname)
 . s i%SqlListDelimiter=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter)
 . s i%SqlListType=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype)
 . s i%Transient=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPtransient)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPtype)
 . s sub="" f  s sub=$$$defSubMemberNext(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$defMemberArrayGet(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSproperty,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSproperty,name2,"")
 . i i%Aliases="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPaliases) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPaliases,i%Aliases) }
 . i i%Calculated=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcalculated) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcalculated,i%Calculated) }
 . i i%Cardinality="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcardinality) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcardinality,i%Cardinality) }
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPclientname,i%ClientName) }
 . i i%Collection="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcollection) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcollection,i%Collection) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPdescription,i%Description) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPfinal,i%Final) }
 . i i%Identity=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPidentity) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPidentity,i%Identity) }
 . i i%InitialExpression="""""" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression,i%InitialExpression) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinternal,i%Internal) }
 . i i%Inverse="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinverse) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinverse,i%Inverse) }
 . i i%MultiDimensional=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional,i%MultiDimensional) }
 . i i%NoModBit=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit,i%NoModBit) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable,i%NotInheritable) }
 . i i%OnDelete="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPondelete) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPondelete,i%OnDelete) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPprivate,i%Private) }
 . i i%ReadOnly=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPreadonly) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPreadonly,i%ReadOnly) }
 . i i%Relationship=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPrelationship) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPrelationship,i%Relationship) }
 . i i%Required=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPrequired) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPrequired,i%Required) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber,i%SequenceNumber) }
 . i i%ServerOnly="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPserveronly) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPserveronly,i%ServerOnly) }
 . i i%SqlCollation="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation,i%SqlCollation) }
 . i i%SqlColumnNumber="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber,i%SqlColumnNumber) }
 . i i%SqlComputeCode="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode,i%SqlComputeCode) }
 . i i%SqlComputed=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed,i%SqlComputed) }
 . i i%SqlComputeOnChange="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange,i%SqlComputeOnChange) }
 . i i%SqlFieldName="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname,i%SqlFieldName) }
 . i i%SqlListDelimiter="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter,i%SqlListDelimiter) }
 . i i%SqlListType="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype,i%SqlListType) }
 . i i%Transient=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPtransient) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPtransient,i%Transient) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPtype) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPtype,i%Type) }
 . $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub,..Parameters.GetAt(sub))
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSproperty,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.PropertyDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSproperty,name2,"")
 . i i%Aliases="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPaliases) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPaliases,i%Aliases) }
 . i i%Calculated=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcalculated) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcalculated,i%Calculated) }
 . i i%Cardinality="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcardinality) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcardinality,i%Cardinality) }
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPclientname,i%ClientName) }
 . i i%Collection="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPcollection) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPcollection,i%Collection) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPdescription,i%Description) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPfinal,i%Final) }
 . i i%Identity=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPidentity) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPidentity,i%Identity) }
 . i i%InitialExpression="""""" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinitialexpression,i%InitialExpression) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinternal,i%Internal) }
 . i i%Inverse="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPinverse) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPinverse,i%Inverse) }
 . i i%MultiDimensional=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPmultidimensional,i%MultiDimensional) }
 . i i%NoModBit=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPnomodbit,i%NoModBit) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPnotinheritable,i%NotInheritable) }
 . i i%OnDelete="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPondelete) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPondelete,i%OnDelete) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPprivate,i%Private) }
 . i i%ReadOnly=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPreadonly) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPreadonly,i%ReadOnly) }
 . i i%Relationship=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPrelationship) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPrelationship,i%Relationship) }
 . i i%Required=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPrequired) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPrequired,i%Required) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsequencenumber,i%SequenceNumber) }
 . i i%ServerOnly="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPserveronly) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPserveronly,i%ServerOnly) }
 . i i%SqlCollation="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcollation,i%SqlCollation) }
 . i i%SqlColumnNumber="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcolumnnumber,i%SqlColumnNumber) }
 . i i%SqlComputeCode="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputecode,i%SqlComputeCode) }
 . i i%SqlComputed=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputed,i%SqlComputed) }
 . i i%SqlComputeOnChange="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlcomputeonchange,i%SqlComputeOnChange) }
 . i i%SqlFieldName="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqlfieldname,i%SqlFieldName) }
 . i i%SqlListDelimiter="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllistdelimiter,i%SqlListDelimiter) }
 . i i%SqlListType="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPsqllisttype,i%SqlListType) }
 . i i%Transient=0 { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPtransient) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPtransient,i%Transient) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPtype) } else { $$$defMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPtype,i%Type) }
 . $$$defMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSproperty,name2,$$$cPROPparameter,sub,..Parameters.GetAt(sub))
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSproperty,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSproperty,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.PropertyDef88F9S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"a"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.PropertyDefinition.Name}</Expression>
</Subscript>
<Data name="Aliases">
<RetrievalCode> s {Aliases}=$s($d(^oddDEF({L1},"a",{L3},58))#2:^(58),1:"")
</RetrievalCode>
</Data>
<Data name="Calculated">
<RetrievalCode> s {Calculated}=$s($d(^oddDEF({L1},"a",{L3},23))#2:^(23),1:0)
</RetrievalCode>
</Data>
<Data name="Cardinality">
<RetrievalCode> s {Cardinality}=$s($d(^oddDEF({L1},"a",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddDEF({L1},"a",{L3},26))#2:^(26),1:"")
</RetrievalCode>
</Data>
<Data name="Collection">
<RetrievalCode> s {Collection}=$s($d(^oddDEF({L1},"a",{L3},27))#2:^(27),1:"")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"a",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"a",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"a",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="InitialExpression">
<RetrievalCode> s {InitialExpression}=$s($d(^oddDEF({L1},"a",{L3},31))#2:^(31),1:"""""")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"a",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="Inverse">
<RetrievalCode> s {Inverse}=$s($d(^oddDEF({L1},"a",{L3},32))#2:^(32),1:"")
</RetrievalCode>
</Data>
<Data name="MultiDimensional">
<RetrievalCode> s {MultiDimensional}=$s($d(^oddDEF({L1},"a",{L3},33))#2:^(33),1:0)
</RetrievalCode>
</Data>
<Data name="NoModBit">
<RetrievalCode> s {NoModBit}=$s($d(^oddDEF({L1},"a",{L3},53))#2:^(53),1:0)
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddDEF({L1},"a",{L3},9))#2:^(9),1:0)
</RetrievalCode>
</Data>
<Data name="OnDelete">
<RetrievalCode> s {OnDelete}=$s($d(^oddDEF({L1},"a",{L3},59))#2:^(59),1:"")
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddDEF({L1},"a",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$g(^oddDEF({L1},"a",{L3},"P",sub))))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddDEF({L1},"a",{L3},35))#2:^(35),1:0)
</RetrievalCode>
</Data>
<Data name="ReadOnly">
<RetrievalCode> s {ReadOnly}=$s($d(^oddDEF({L1},"a",{L3},52))#2:^(52),1:0)
</RetrievalCode>
</Data>
<Data name="Relationship">
<RetrievalCode> s {Relationship}=$s($d(^oddDEF({L1},"a",{L3},36))#2:^(36),1:0)
</RetrievalCode>
</Data>
<Data name="Required">
<RetrievalCode> s {Required}=$s($d(^oddDEF({L1},"a",{L3},37))#2:^(37),1:0)
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"a",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="ServerOnly">
<RetrievalCode> s {ServerOnly}=$s($d(^oddDEF({L1},"a",{L3},57))#2:^(57),1:"")
</RetrievalCode>
</Data>
<Data name="SqlCollation">
<RetrievalCode> s {SqlCollation}=$s($d(^oddDEF({L1},"a",{L3},42))#2:^(42),1:"")
</RetrievalCode>
</Data>
<Data name="SqlColumnNumber">
<RetrievalCode> s {SqlColumnNumber}=$s($d(^oddDEF({L1},"a",{L3},43))#2:^(43),1:"")
</RetrievalCode>
</Data>
<Data name="SqlComputeCode">
<RetrievalCode> s {SqlComputeCode}=$s($d(^oddDEF({L1},"a",{L3},44))#2:^(44),1:"")
</RetrievalCode>
</Data>
<Data name="SqlComputeOnChange">
<RetrievalCode> s {SqlComputeOnChange}=$s($d(^oddDEF({L1},"a",{L3},46))#2:^(46),1:"")
</RetrievalCode>
</Data>
<Data name="SqlComputed">
<RetrievalCode> s {SqlComputed}=$s($d(^oddDEF({L1},"a",{L3},45))#2:^(45),1:0)
</RetrievalCode>
</Data>
<Data name="SqlFieldName">
<RetrievalCode> s {SqlFieldName}=$s($d(^oddDEF({L1},"a",{L3},47))#2:^(47),1:"")
</RetrievalCode>
</Data>
<Data name="SqlListDelimiter">
<RetrievalCode> s {SqlListDelimiter}=$s($d(^oddDEF({L1},"a",{L3},48))#2:^(48),1:"")
</RetrievalCode>
</Data>
<Data name="SqlListType">
<RetrievalCode> s {SqlListType}=$s($d(^oddDEF({L1},"a",{L3},49))#2:^(49),1:"")
</RetrievalCode>
</Data>
<Data name="Transient">
<RetrievalCode> s {Transient}=$s($d(^oddDEF({L1},"a",{L3},51))#2:^(51),1:0)
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"a",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
<Data name="_Identity">
<RetrievalCode> s {_Identity}=$s($d(^oddDEF({L1},"a",{L3},56))#2:^(56),1:0)
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.PropertyDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSproperty)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.PropertyUDLTextDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.117977</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.PropertyDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>UDLTexts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Category">
<Description>
Category</Description>
<Type>%CacheString</Type>
<InitialExpression>"comment"</InitialExpression>
</Property>

<Property name="Content">
<Description>
Holds the content of the UDL text.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="Name">
<Description>
Speficies the COS name of the UDL text.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Position">
<Description>
Position</Description>
<Type>%CacheString</Type>
<InitialExpression>"body"</InitialExpression>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="TextType">
<Description>
TextType</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="CategoryIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="comment" q $$$OK
 i val="error" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyUDLTextDefinition:Category",val)
]]></Implementation>
</Method>

<Method name="PositionIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="body" q $$$OK
 i val="header" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.PropertyUDLTextDefinition:Position",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)
 s i%Name=$p(name,":",3)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$defSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Category=$$$defSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory)
 . s i%Position=$$$defSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition)
 . s i%SequenceNumber=$$$defSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber)
 . s i%TextType=$$$defSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype)
 . s i%Content=""
 . f ptr=1:1:$$$defSubMemberKeyGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent) d
 . . d ..Content.WriteLine($$$defSubMemberArrayGet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,ptr))
 . d ..Content.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.PropertyDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i '($$$defSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defSubMemberSet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,"")
 . i i%Category="comment" { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory,i%Category) }
 . i i%Position="body" { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition,i%Position) }
 . i i%SequenceNumber=0 { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber,i%SequenceNumber) }
 . i i%TextType=0 { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype,i%TextType) }
 . $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent)
 . d ..Content.Rewind() s ..Content.LineTerminator=$c(10)
 . f line=1:1 q:..Content.AtEnd  d
 . . s linetext=..Content.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defSubMemberArraySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,line,linetext)
 . $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,line-1)
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.PropertyUDLTextDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defSubMemberSet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,"")
 . i i%Category="comment" { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcategory,i%Category) }
 . i i%Position="body" { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTposition,i%Position) }
 . i i%SequenceNumber=0 { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTsequencenumber,i%SequenceNumber) }
 . i i%TextType=0 { $$$defSubMemberKeyKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype) } else { $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTtexttype,i%TextType) }
 . d ..Content.Rewind() s ..Content.LineTerminator=$c(10)
 . f line=1:1 q:..Content.AtEnd  d
 . . s linetext=..Content.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defSubMemberArraySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,line,linetext)
 . $$$defSubMemberKeySet(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3,$$$cUDLTEXTcontent,line-1)
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defSubMemberDefined(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defSubMemberKill(name1,$$$cCLASSproperty,name2,$$$cPROPudltext,name3) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.PropertyUDL2866S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"a"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.PropertyDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"u"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.PropertyUDLTextDefinition.Name}</Expression>
</Subscript>
<Data name="Category">
<RetrievalCode> s {Category}=$s($d(^oddDEF({L1},"a",{L3},"u",{L5},23))#2:^(23),1:"comment")
</RetrievalCode>
</Data>
<Data name="Content">
<RetrievalCode> s {Content}=""
</RetrievalCode>
</Data>
<Data name="Position">
<RetrievalCode> s {Position}=$s($d(^oddDEF({L1},"a",{L3},"u",{L5},24))#2:^(24),1:"body")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"a",{L3},"u",{L5},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="TextType">
<RetrievalCode> s {TextType}=$s($d(^oddDEF({L1},"a",{L3},"u",{L5},22))#2:^(22),1:0)
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.QueryDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.QueryDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.686029</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Queries</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ClientName">
<Description>
ClientName</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this query is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the query.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="FormalSpec">
<Description><![CDATA[
Specifies the list of arguments passed to the Execute method. Each argument is of the format [&amp;|*]&lt;name&gt;[:&lt;type&gt;][=&lt;default&gt;] where &amp; means pass-by-reference and * means output-only.]]></Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the query.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NotInheritable">
<Description>
Deprecated</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Parameters">
<Description>
Parameter</Description>
<Type>%CacheString</Type>
<Collection>array</Collection>
</Property>

<Property name="Private">
<Description>
Deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SoapBindingStyle">
<Description>
Specifies what type of SOAP invocation is used for a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapBodyUse">
<Description>
Specifies what kind of SOAP encoding is used for the inputs and outputs of a web method. This keyword is ignored for non-web methods.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SoapNameSpace">
<Description>
SoapNameSpace</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlName">
<Description>
If this query is projected as an SQL stored procedure, then this name is used as the name of the stored procedure.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlProc">
<Description>
Specifies that the query can be invoked as an SQL stored procedure.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlQuery">
<Description>
Specifies an SQL statement to be used for an SQL-based query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlView">
<Description>
Specifies whether to project this query as an SQL View.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlViewName">
<Description>
Specifies an SQL alias for the view projected from this query.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Specifies the Query class used to provide the implementation of the query interface.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="WebMethod">
<Description>
description=Specifies that this query can be invoked using the SOAP protocol. </Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="SoapBindingStyleIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="document" q $$$OK
 i val="rpc" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.QueryDefinition:SoapBindingStyle",val)
]]></Implementation>
</Method>

<Method name="SoapBodyUseIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="literal" q $$$OK
 i val="encoded" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.QueryDefinition:SoapBodyUse",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSquery,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSquery,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%ClientName=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYclientname)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYdescription)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYfinal)
 . s i%FormalSpec=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYformalspec)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYinternal)
 . s i%NotInheritable=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable)
 . s i%Private=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYprivate)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber)
 . s i%SoapBindingStyle=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle)
 . s i%SoapBodyUse=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse)
 . s i%SoapNameSpace=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace)
 . s i%SqlName=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlname)
 . s i%SqlProc=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc)
 . s i%SqlQuery=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery)
 . s i%SqlView=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlview)
 . s i%SqlViewName=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYtype)
 . s i%WebMethod=$$$defMemberKeyGet(name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod)
 . s sub="" f  s sub=$$$defSubMemberNext(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub) q:sub=""  d
 . . d ..Parameters.SetAt($$$defMemberArrayGet(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub),sub)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSquery,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSquery,name2,"")
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYclientname,i%ClientName) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYdescription,i%Description) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYfinal,i%Final) }
 . i i%FormalSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYformalspec) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYformalspec,i%FormalSpec) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYinternal,i%Internal) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable,i%NotInheritable) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYprivate,i%Private) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber,i%SequenceNumber) }
 . i i%SoapBindingStyle="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle,i%SoapBindingStyle) }
 . i i%SoapBodyUse="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse,i%SoapBodyUse) }
 . i i%SoapNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace,i%SoapNameSpace) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlname,i%SqlName) }
 . i i%SqlProc=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc,i%SqlProc) }
 . i i%SqlQuery="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery,i%SqlQuery) }
 . i i%SqlView=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlview) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlview,i%SqlView) }
 . i i%SqlViewName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname,i%SqlViewName) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYtype) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYtype,i%Type) }
 . i i%WebMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod,i%WebMethod) }
 . $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub,..Parameters.GetAt(sub))
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSquery,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.QueryDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSquery,name2,"")
 . i i%ClientName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYclientname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYclientname,i%ClientName) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYdescription,i%Description) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYfinal,i%Final) }
 . i i%FormalSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYformalspec) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYformalspec,i%FormalSpec) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYinternal,i%Internal) }
 . i i%NotInheritable=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYnotinheritable,i%NotInheritable) }
 . i i%Private=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYprivate) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYprivate,i%Private) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsequencenumber,i%SequenceNumber) }
 . i i%SoapBindingStyle="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbindingstyle,i%SoapBindingStyle) }
 . i i%SoapBodyUse="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapbodyuse,i%SoapBodyUse) }
 . i i%SoapNameSpace="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsoapnamespace,i%SoapNameSpace) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlname,i%SqlName) }
 . i i%SqlProc=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlproc,i%SqlProc) }
 . i i%SqlQuery="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlquery,i%SqlQuery) }
 . i i%SqlView=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlview) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlview,i%SqlView) }
 . i i%SqlViewName="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYsqlviewname,i%SqlViewName) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYtype) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYtype,i%Type) }
 . i i%WebMethod=0 { $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod) } else { $$$defMemberKeySet(name1,$$$cCLASSquery,name2,$$$cQUERYwebmethod,i%WebMethod) }
 . $$$defMemberKeyKill(name1,$$$cCLASSquery,name2,$$$cQUERYparameter)
 . s sub="" f  s sub=..Parameters.Next(sub) q:sub=""  d
 . . $$$defSubMemberSet(name1,$$$cCLASSquery,name2,$$$cQUERYparameter,sub,..Parameters.GetAt(sub))
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSquery,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSquery,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.QueryDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"q"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.QueryDefinition.Name}</Expression>
</Subscript>
<Data name="ClientName">
<RetrievalCode> s {ClientName}=$s($d(^oddDEF({L1},"q",{L3},41))#2:^(41),1:"")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"q",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"q",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"q",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="FormalSpec">
<RetrievalCode> s {FormalSpec}=$s($d(^oddDEF({L1},"q",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"q",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="NotInheritable">
<RetrievalCode> s {NotInheritable}=$s($d(^oddDEF({L1},"q",{L3},9))#2:^(9),1:0)
</RetrievalCode>
</Data>
<Data name="Parameters">
<RetrievalCode> n sub s {Parameters}="",sub="" f  s sub=$o(^oddDEF({L1},"q",{L3},"P",sub)) q:sub=""  s {Parameters}={Parameters}_$lb($lb(sub,$g(^oddDEF({L1},"q",{L3},"P",sub))))
</RetrievalCode>
</Data>
<Data name="Private">
<RetrievalCode> s {Private}=$s($d(^oddDEF({L1},"q",{L3},26))#2:^(26),1:0)
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"q",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="SoapBindingStyle">
<RetrievalCode> s {SoapBindingStyle}=$s($d(^oddDEF({L1},"q",{L3},35))#2:^(35),1:"")
</RetrievalCode>
</Data>
<Data name="SoapBodyUse">
<RetrievalCode> s {SoapBodyUse}=$s($d(^oddDEF({L1},"q",{L3},36))#2:^(36),1:"")
</RetrievalCode>
</Data>
<Data name="SoapNameSpace">
<RetrievalCode> s {SoapNameSpace}=$s($d(^oddDEF({L1},"q",{L3},37))#2:^(37),1:"")
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddDEF({L1},"q",{L3},27))#2:^(27),1:"")
</RetrievalCode>
</Data>
<Data name="SqlProc">
<RetrievalCode> s {SqlProc}=$s($d(^oddDEF({L1},"q",{L3},28))#2:^(28),1:0)
</RetrievalCode>
</Data>
<Data name="SqlQuery">
<RetrievalCode> s {SqlQuery}=$s($d(^oddDEF({L1},"q",{L3},29))#2:^(29),1:"")
</RetrievalCode>
</Data>
<Data name="SqlView">
<RetrievalCode> s {SqlView}=$s($d(^oddDEF({L1},"q",{L3},30))#2:^(30),1:0)
</RetrievalCode>
</Data>
<Data name="SqlViewName">
<RetrievalCode> s {SqlViewName}=$s($d(^oddDEF({L1},"q",{L3},31))#2:^(31),1:"")
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"q",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
<Data name="WebMethod">
<RetrievalCode> s {WebMethod}=$s($d(^oddDEF({L1},"q",{L3},33))#2:^(33),1:0)
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.QueryDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41413</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSquery)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.RoseLinkUtility">
<IncludeCode>%occInclude</IncludeCode>
<Super>%RegisteredObject</Super>
<System>3</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59395,63779.720713</TimeCreated>

<Property name="XmlStream">
<Type>%GlobalCharacterStream</Type>
</Property>

<Property name="MemberListStream">
<Type>%GlobalCharacterStream</Type>
</Property>

<Property name="NewClassname">
<Type>%String</Type>
<Parameter name="MAXLEN" value="32768"/>
</Property>

<Method name="LoadToXmlStream">
<FormalSpec>tClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStream=##class(%FileCharacterStream).%New()
	Do tStream.Write("")
	Set tSC = $system.OBJ.Export(tClassname_".cls",tStream.Filename,"") Quit:$$$ISERR(tSC) tSC
	Set tSC = ..XmlStream.CopyFrom(tStream) Quit:$$$ISERR(tSC) tSC
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SaveFromXmlStream">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStream=##class(%FileCharacterStream).%New()
 	If ..NewClassname="" {
 		Set tSC = tStream.CopyFrom(..XmlStream) Quit:$$$ISERR(tSC) tSC
 	} Else {
 		Set tLine=..XmlStream.Read(10000)
 		Set f=$f(tLine,"<Class name=""")
 		Set g=$f(tLine,"""",f)
 		If f,g Set $e(tLine,f,g-2)=..NewClassname
 		Do tStream.Write(tLine)
 		For  Quit:..XmlStream.AtEnd  Do tStream.Write(..XmlStream.Read(10000))
 	}
	Do tStream.SaveStream()
	Set tSC = $system.OBJ.Load(tStream.Filename,"-c",,.loaded) Quit:$$$ISERR(tSC) tSC
	Do ##class(%File).Delete(tStream.Filename)
	; get classname
	If loaded["," Quit $$$OK
	If $e(loaded,$l(loaded)-3,$l(loaded))'=".cls" Quit $$$OK
	Set classname=$e(loaded,1,$l(loaded)-4)
	; purge members
	For  Set line=..MemberListStream.ReadLine() Quit:line=""  Set existing(line)=""
	Set class=##class(%Dictionary.ClassDefinition).%OpenId(classname)
	If class=$$$NULLOREF Quit $$$OK
	For i=class.Properties.Count():-1:1 If $data(existing("a:"_class.Properties.GetAt(i).Name))=0 Do class.Properties.RemoveAt(i)
	For i=class.Methods.Count():-1:1 If $data(existing("m:"_class.Methods.GetAt(i).Name))=0 Do class.Methods.RemoveAt(i)
	Do class.%Save()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SupportFeature">
<ClassMethod>1</ClassMethod>
<FormalSpec>feature=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	i feature="Security" q 1
	q 0
]]></Implementation>
</Method>

<Method name="HasSecurityPermission">
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit $System.Security.Check("%Development","USE")
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.SQLIdentifier">
<Super>%DataType</Super>
<System>2</System>
<TimeChanged>66186,77919</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Method name="IsValid">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$select($system.SQL.IsValidRegularIdentifier(%val):$$$OK,1:$$$ERROR($$$DatatypeValidationError,"%Dictionary.SQLIdentifier",%val))
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.SQLProcedure">
<Abstract>1</Abstract>
<System>4</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>62854,45131.955242</TimeCreated>

<Method name="GetParameterValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>parameters,param</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlName>GetParameterValue</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set value=""
	for i=1:1:$ll(parameters) {
		if $li($li(parameters,i),1)=param set value=$li($li(parameters,i),2) quit
	}
	quit value
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.StorageDataDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.126684</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Data</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Attribute">
<Description>
Attribute</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Specifies the name of the StorageData definition. This name must be a valid storage member name and must not conflict with any other StorageData names.</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="Structure">
<Description>
Specifies how the data is stored into a global node.</Description>
<Type>%CacheString</Type>
<InitialExpression>"listnode"</InitialExpression>
</Property>

<Property name="Subscript">
<Description>
Subscript</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Values">
<Description>
Value</Description>
<Type>%Dictionary.StorageDataValueDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="StructureIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="node" q $$$OK
 i val="listnode" q $$$OK
 i val="subnode" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.StorageDataDefinition:Structure",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)
 s i%Name=$p(name,":",3)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Attribute=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute)
 . s i%Structure=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure)
 . s i%Subscript=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,"")
 . i i%Attribute="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute,i%Attribute) }
 . i i%Structure="listnode" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure,i%Structure) }
 . i i%Subscript="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript,i%Subscript) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageDataDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,"")
 . i i%Attribute="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAattribute,i%Attribute) }
 . i i%Structure="listnode" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAstructure,i%Structure) }
 . i i%Subscript="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAsubscript,i%Subscript) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageData1004S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"D"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageDataDefinition.Name}</Expression>
</Subscript>
<Data name="Attribute">
<RetrievalCode> s {Attribute}=$g(^oddDEF({L1},"s",{L3},"D",{L5},21),$g(^%qCacheObjectKey(1,"D",21)))
</RetrievalCode>
</Data>
<Data name="Structure">
<RetrievalCode> s {Structure}=$g(^oddDEF({L1},"s",{L3},"D",{L5},22),$g(^%qCacheObjectKey(1,"D",22)))
</RetrievalCode>
</Data>
<Data name="Subscript">
<RetrievalCode> s {Subscript}=$g(^oddDEF({L1},"s",{L3},"D",{L5},23),$g(^%qCacheObjectKey(1,"D",23)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageDataValueDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.253767</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageDataDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Values</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Name">
<Description>
Specifies the name of the StorageDataValue. This name must be a valid storage member name and must not conflict with any other StorageDataValue names.</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Value">
<Description>
Value</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)
 s i%Name=$p(name,":",4)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%Value=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageDataDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,"")
 . i i%Value="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue,i%Value) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageDataValueDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,"")
 . i i%Value="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4,$$$cSDEFDATAVALvalue,i%Value) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdata,name3,$$$cSDEFDATAvalue,name4) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageData71C3S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"D"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageDataDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"V"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageDataValueDefinition.Name}</Expression>
</Subscript>
<Data name="Value">
<RetrievalCode> s {Value}=$g(^oddDEF({L1},"s",{L3},"D",{L5},"V",{L7},21),$g(^%qCacheObjectKey(1,"V",21)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.StorageDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.700728</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Storages</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CounterLocation">
<Description>
Specifies the base location of counters for properties with type is %Library.Counter. Normally this would be a global reference such as ^User.PersonC. The global reference can also include one or more leading subscripts.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Data</Description>
<Type>%Dictionary.StorageDataDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="DataLocation">
<Description>
Specifies expression that is the location where data is stored for this class. Normally this would be a global reference such as ^User.PersonD. The global reference can also include one or more leading subscripts.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="DefaultData">
<Description>
Specifies the name of the DATA definition that the Class Compiler Data Structure Generator uses to place any previously unstored properties. A property is unstored if it is storable, but is not listed in any DATA definition. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this storage is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the storage definition. This description is displayed by the online class reference.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExtentLocation">
<Description>
Specifies the base location of globals used by the extent of this class. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="ExtentSize">
<Description>
ExtentSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that the storage definition cannot be modified by subclasses.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="IdExpression">
<Description>
IdExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IdFunction">
<Description>
Specifies the system function used to allocate new id values.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="IdLocation">
<Description>
Specifies location of the ID Counter.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Indices">
<Description>
Index</Description>
<Type>%Dictionary.StorageIndexDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="IndexLocation">
<Description>
Specifies the global used for indices for this class. If not specified, the index location is ^MyApp.MyClassI, where MyApp.MyClass is the classname. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Name">
<Description>
Specifies the name of the Storage definition. This name must be a valid class member name and must not conflict with any other class member names.</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="Properties">
<Description>
Property</Description>
<Type>%Dictionary.StoragePropertyDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlChildSub">
<Description>
SqlChildSub</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlIdExpression">
<Description>
SqlIdExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SQLMaps">
<Description>
SQLMap</Description>
<Type>%Dictionary.StorageSQLMapDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="SqlRowIdName">
<Description>
Specifies the name of the Row ID column projected to SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlRowIdProperty">
<Description>
Specifies the SQL RowId property. This keyword is only used by classes that have been migrated from earlier InterSystems products.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SqlTableNumber">
<Description>
Specifies the internal SQL Table Number. This keyword is only used by classes that have been migrated from earlier InterSystems products.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="State">
<Description>
For a serial embedded class, this keyword specifies which Data definition is used to define the serialized state of the object. This is also the default DATA definition that unstored properties will be added to by the default structure generator.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StreamLocation">
<Description>
Specifies the default global used to store any stream properties within this class. If not specified, the index location is ^MyApp.MyClassS, where MyApp.MyClass is the classname. </Description>
<Type>%CacheString</Type>
</Property>

<Property name="Type">
<Description>
Specifies the Storage Class used to provide persistence for this class.</Description>
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="VersionLocation">
<Description>
Specifies location of the %Version Counter.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="IdFunctionIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="increment" q $$$OK
 i val="sequence" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.StorageDefinition:IdFunction",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSstorage,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSstorage,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%CounterLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation)
 . s i%DataLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation)
 . s i%DefaultData=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFdescription)
 . s i%ExtentLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation)
 . s i%ExtentSize=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFfinal)
 . s i%IdExpression=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression)
 . s i%IdFunction=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction)
 . s i%IdLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation)
 . s i%IndexLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFinternal)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber)
 . s i%SqlChildSub=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub)
 . s i%SqlIdExpression=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression)
 . s i%SqlRowIdName=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname)
 . s i%SqlRowIdProperty=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty)
 . s i%SqlTableNumber=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber)
 . s i%State=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFstate)
 . s i%StreamLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation)
 . s i%Type=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFtype)
 . s i%VersionLocation=$$$defMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSstorage,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSstorage,name2,"")
 . i i%CounterLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation,i%CounterLocation) }
 . i i%DataLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation,i%DataLocation) }
 . i i%DefaultData="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata,i%DefaultData) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdescription,i%Description) }
 . i i%ExtentLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation,i%ExtentLocation) }
 . i i%ExtentSize="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize,i%ExtentSize) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFfinal,i%Final) }
 . i i%IdExpression="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression,i%IdExpression) }
 . i i%IdFunction="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction,i%IdFunction) }
 . i i%IdLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation,i%IdLocation) }
 . i i%IndexLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation,i%IndexLocation) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFinternal,i%Internal) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber,i%SequenceNumber) }
 . i i%SqlChildSub="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub,i%SqlChildSub) }
 . i i%SqlIdExpression="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression,i%SqlIdExpression) }
 . i i%SqlRowIdName="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname,i%SqlRowIdName) }
 . i i%SqlRowIdProperty="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty,i%SqlRowIdProperty) }
 . i i%SqlTableNumber="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber,i%SqlTableNumber) }
 . i i%State="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFstate) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFstate,i%State) }
 . i i%StreamLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation,i%StreamLocation) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFtype) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFtype,i%Type) }
 . i i%VersionLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation,i%VersionLocation) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSstorage,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSstorage,name2,"")
 . i i%CounterLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFcounterlocation,i%CounterLocation) }
 . i i%DataLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdatalocation,i%DataLocation) }
 . i i%DefaultData="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdefaultdata,i%DefaultData) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFdescription,i%Description) }
 . i i%ExtentLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentlocation,i%ExtentLocation) }
 . i i%ExtentSize="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFextentsize,i%ExtentSize) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFfinal) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFfinal,i%Final) }
 . i i%IdExpression="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidexpression,i%IdExpression) }
 . i i%IdFunction="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidfunction,i%IdFunction) }
 . i i%IdLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFidlocation,i%IdLocation) }
 . i i%IndexLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFindexlocation,i%IndexLocation) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFinternal,i%Internal) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsequencenumber,i%SequenceNumber) }
 . i i%SqlChildSub="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlchildsub,i%SqlChildSub) }
 . i i%SqlIdExpression="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlidexpression,i%SqlIdExpression) }
 . i i%SqlRowIdName="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidname,i%SqlRowIdName) }
 . i i%SqlRowIdProperty="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlrowidproperty,i%SqlRowIdProperty) }
 . i i%SqlTableNumber="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqltablenumber,i%SqlTableNumber) }
 . i i%State="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFstate) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFstate,i%State) }
 . i i%StreamLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFstreamlocation,i%StreamLocation) }
 . i i%Type="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFtype) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFtype,i%Type) }
 . i i%VersionLocation="" { $$$defMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation) } else { $$$defMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFversionlocation,i%VersionLocation) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSstorage,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSstorage,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Data name="CounterLocation">
<RetrievalCode> s {CounterLocation}=$s($d(^oddDEF({L1},"s",{L3},36))#2:^(36),1:"")
</RetrievalCode>
</Data>
<Data name="DataLocation">
<RetrievalCode> s {DataLocation}=$s($d(^oddDEF({L1},"s",{L3},21))#2:^(21),1:"")
</RetrievalCode>
</Data>
<Data name="DefaultData">
<RetrievalCode> s {DefaultData}=$s($d(^oddDEF({L1},"s",{L3},22))#2:^(22),1:"")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"s",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"s",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="ExtentLocation">
<RetrievalCode> s {ExtentLocation}=$s($d(^oddDEF({L1},"s",{L3},38))#2:^(38),1:"")
</RetrievalCode>
</Data>
<Data name="ExtentSize">
<RetrievalCode> s {ExtentSize}=$s($d(^oddDEF({L1},"s",{L3},34))#2:^(34),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"s",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="IdExpression">
<RetrievalCode> s {IdExpression}=$s($d(^oddDEF({L1},"s",{L3},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
<Data name="IdFunction">
<RetrievalCode> s {IdFunction}=$s($d(^oddDEF({L1},"s",{L3},37))#2:^(37),1:"")
</RetrievalCode>
</Data>
<Data name="IdLocation">
<RetrievalCode> s {IdLocation}=$s($d(^oddDEF({L1},"s",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="IndexLocation">
<RetrievalCode> s {IndexLocation}=$s($d(^oddDEF({L1},"s",{L3},25))#2:^(25),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"s",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"s",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="SqlChildSub">
<RetrievalCode> s {SqlChildSub}=$s($d(^oddDEF({L1},"s",{L3},27))#2:^(27),1:"")
</RetrievalCode>
</Data>
<Data name="SqlIdExpression">
<RetrievalCode> s {SqlIdExpression}=$s($d(^oddDEF({L1},"s",{L3},28))#2:^(28),1:"")
</RetrievalCode>
</Data>
<Data name="SqlRowIdName">
<RetrievalCode> s {SqlRowIdName}=$s($d(^oddDEF({L1},"s",{L3},29))#2:^(29),1:"")
</RetrievalCode>
</Data>
<Data name="SqlRowIdProperty">
<RetrievalCode> s {SqlRowIdProperty}=$s($d(^oddDEF({L1},"s",{L3},30))#2:^(30),1:"")
</RetrievalCode>
</Data>
<Data name="SqlTableNumber">
<RetrievalCode> s {SqlTableNumber}=$s($d(^oddDEF({L1},"s",{L3},31))#2:^(31),1:"")
</RetrievalCode>
</Data>
<Data name="State">
<RetrievalCode> s {State}=$s($d(^oddDEF({L1},"s",{L3},32))#2:^(32),1:"")
</RetrievalCode>
</Data>
<Data name="StreamLocation">
<RetrievalCode> s {StreamLocation}=$s($d(^oddDEF({L1},"s",{L3},33))#2:^(33),1:"")
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$s($d(^oddDEF({L1},"s",{L3},5))#2:^(5),1:"")
</RetrievalCode>
</Data>
<Data name="VersionLocation">
<RetrievalCode> s {VersionLocation}=$s($d(^oddDEF({L1},"s",{L3},35))#2:^(35),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41414</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSstorage)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.StorageIndexDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.14238</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Indices</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Location">
<Description>
Location</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)
 s i%Name=$p(name,":",3)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%Location=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,"")
 . i i%Location="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation,i%Location) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageIndexDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,"")
 . i i%Location="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3,$$$cSDEFIDXlocation,i%Location) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFindex,name3) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageIndeBD25S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"X"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageIndexDefinition.Name}</Expression>
</Subscript>
<Data name="Location">
<RetrievalCode> s {Location}=$g(^oddDEF({L1},"s",{L3},"X",{L5},21),$g(^%qCacheObjectKey(1,"X",21)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StoragePropertyDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.153593</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Properties</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="AverageFieldSize">
<Description>
AverageFieldSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="BiasQueriesAsOutlier">
<Description>
BiasQueriesAsOutlier</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ChildBlockCount">
<Description>
ChildBlockCount</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ChildExtentSize">
<Description>
ChildExtentSize</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="OutlierSelectivity">
<Description>
OutlierSelectivity</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Selectivity">
<Description>
Selectivity</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StreamLocation">
<Description>
StreamLocation</Description>
<Type>%CacheString</Type>
</Property>

<Method name="BiasQueriesAsOutlierIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="0" q $$$OK
 i val="1" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.StoragePropertyDefinition:BiasQueriesAsOutlier",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)
 s i%Name=$p(name,":",3)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%AverageFieldSize=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize)
 . s i%BiasQueriesAsOutlier=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier)
 . s i%ChildBlockCount=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount)
 . s i%ChildExtentSize=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize)
 . s i%OutlierSelectivity=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity)
 . s i%Selectivity=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity)
 . s i%StreamLocation=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,"")
 . i i%AverageFieldSize="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize,i%AverageFieldSize) }
 . i i%BiasQueriesAsOutlier="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier,i%BiasQueriesAsOutlier) }
 . i i%ChildBlockCount="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount,i%ChildBlockCount) }
 . i i%ChildExtentSize="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize,i%ChildExtentSize) }
 . i i%OutlierSelectivity="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity,i%OutlierSelectivity) }
 . i i%Selectivity="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity,i%Selectivity) }
 . i i%StreamLocation="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation,i%StreamLocation) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StoragePropertyDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,"")
 . i i%AverageFieldSize="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYaveragefieldsize,i%AverageFieldSize) }
 . i i%BiasQueriesAsOutlier="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYbiasqueriesasoutlier,i%BiasQueriesAsOutlier) }
 . i i%ChildBlockCount="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildblockcount,i%ChildBlockCount) }
 . i i%ChildExtentSize="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYchildextentsize,i%ChildExtentSize) }
 . i i%OutlierSelectivity="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYoutlierselectivity,i%OutlierSelectivity) }
 . i i%Selectivity="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYselectivity,i%Selectivity) }
 . i i%StreamLocation="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3,$$$cSTORAGEPROPERTYstreamlocation,i%StreamLocation) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFproperty,name3) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StoragePropB37CS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"M"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StoragePropertyDefinition.Name}</Expression>
</Subscript>
<Data name="AverageFieldSize">
<RetrievalCode> s {AverageFieldSize}=$g(^oddDEF({L1},"s",{L3},"M",{L5},26),$g(^%qCacheObjectKey(1,"M",26)))
</RetrievalCode>
</Data>
<Data name="BiasQueriesAsOutlier">
<RetrievalCode> s {BiasQueriesAsOutlier}=$g(^oddDEF({L1},"s",{L3},"M",{L5},25),$g(^%qCacheObjectKey(1,"M",25)))
</RetrievalCode>
</Data>
<Data name="ChildBlockCount">
<RetrievalCode> s {ChildBlockCount}=$g(^oddDEF({L1},"s",{L3},"M",{L5},27),$g(^%qCacheObjectKey(1,"M",27)))
</RetrievalCode>
</Data>
<Data name="ChildExtentSize">
<RetrievalCode> s {ChildExtentSize}=$g(^oddDEF({L1},"s",{L3},"M",{L5},23),$g(^%qCacheObjectKey(1,"M",23)))
</RetrievalCode>
</Data>
<Data name="OutlierSelectivity">
<RetrievalCode> s {OutlierSelectivity}=$g(^oddDEF({L1},"s",{L3},"M",{L5},24),$g(^%qCacheObjectKey(1,"M",24)))
</RetrievalCode>
</Data>
<Data name="Selectivity">
<RetrievalCode> s {Selectivity}=$g(^oddDEF({L1},"s",{L3},"M",{L5},21),$g(^%qCacheObjectKey(1,"M",21)))
</RetrievalCode>
</Data>
<Data name="StreamLocation">
<RetrievalCode> s {StreamLocation}=$g(^oddDEF({L1},"s",{L3},"M",{L5},22),$g(^%qCacheObjectKey(1,"M",22)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapDataDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.261214</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageSQLMapDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Data</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Delimiter">
<Description>
Delimiter</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="Node">
<Description>
Node</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Piece">
<Description>
Piece</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RetrievalCode">
<Description>
RetrievalCode</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)
 s i%Name=$p(name,":",4)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%Delimiter=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter)
 . s i%Node=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode)
 . s i%Piece=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece)
 . s i%RetrievalCode=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageSQLMapDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,"")
 . i i%Delimiter="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter,i%Delimiter) }
 . i i%Node="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode,i%Node) }
 . i i%Piece="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece,i%Piece) }
 . i i%RetrievalCode="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode,i%RetrievalCode) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapDataDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,"")
 . i i%Delimiter="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAdelimiter,i%Delimiter) }
 . i i%Node="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAnode,i%Node) }
 . i i%Piece="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATApiece,i%Piece) }
 . i i%RetrievalCode="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4,$$$cSDEFSQLMAPDATAretrievalcode,i%RetrievalCode) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPdata,name4) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLM88B8S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"T"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageSQLMapDataDefinition.Name}</Expression>
</Subscript>
<Data name="Delimiter">
<RetrievalCode> s {Delimiter}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"T",{L7},21),$g(^%qCacheObjectKey(1,"T",21)))
</RetrievalCode>
</Data>
<Data name="Node">
<RetrievalCode> s {Node}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"T",{L7},22),$g(^%qCacheObjectKey(1,"T",22)))
</RetrievalCode>
</Data>
<Data name="Piece">
<RetrievalCode> s {Piece}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"T",{L7},23),$g(^%qCacheObjectKey(1,"T",23)))
</RetrievalCode>
</Data>
<Data name="RetrievalCode">
<RetrievalCode> s {RetrievalCode}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"T",{L7},24),$g(^%qCacheObjectKey(1,"T",24)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.158308</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>SQLMaps</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="BlockCount">
<Description>
BlockCount</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Condition">
<Description>
Condition</Description>
<Type>%CacheString</Type>
</Property>

<Property name="ConditionalWithHostVars">
<Description>
ConditionalWithHostVars</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ConditionFields">
<Description>
ConditionFields</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Data">
<Description>
Data</Description>
<Type>%Dictionary.StorageSQLMapDataDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Global">
<Description>
Global</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Global</SqlFieldName>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%CacheString</Type>
<Required>1</Required>
</Property>

<Property name="PopulationPct">
<Description>
PopulationPct</Description>
<Type>%CacheString</Type>
</Property>

<Property name="PopulationType">
<Description>
PopulationType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="RowIdSpecs">
<Description>
RowIdSpec</Description>
<Type>%Dictionary.StorageSQLMapRowIdSpecDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="RowReference">
<Description>
RowReference</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Structure">
<Description>
Structure</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Subscripts">
<Description>
Subscript</Description>
<Type>%Dictionary.StorageSQLMapSubDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Type">
<Description>
Specifies what kind of a map this is.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="TypeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="data" q $$$OK
 i val="index" q $$$OK
 i val="bitmap" q $$$OK
 i val="bitmapextent" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.StorageSQLMapDefinition:Type",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)
 s i%Name=$p(name,":",3)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 i (name1="")||(name2="")||(name3="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||('$$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,2)
 . s i%Name=name3
 . s i%BlockCount=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount)
 . s i%Condition=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition)
 . s i%ConditionalWithHostVars=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars)
 . s i%ConditionFields=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields)
 . s i%Global=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal)
 . s i%PopulationPct=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct)
 . s i%PopulationType=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype)
 . s i%RowReference=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference)
 . s i%Structure=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure)
 . s i%Type=$$$defStorageSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,"")
 . i i%BlockCount=0 { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount,i%BlockCount) }
 . i i%Condition="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition,i%Condition) }
 . i i%ConditionalWithHostVars=0 { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars,i%ConditionalWithHostVars) }
 . i i%ConditionFields="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields,i%ConditionFields) }
 . i i%Global="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal,i%Global) }
 . i i%PopulationPct="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct,i%PopulationPct) }
 . i i%PopulationType="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype,i%PopulationType) }
 . i i%RowReference="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference,i%RowReference) }
 . i i%Structure="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure,i%Structure) }
 . i i%Type="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype,i%Type) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,2):1,i%Name'=$p(id,"||",3):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,"")
 . i i%BlockCount=0 { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPblockcount,i%BlockCount) }
 . i i%Condition="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPcondition,i%Condition) }
 . i i%ConditionalWithHostVars=0 { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionalwithhostvars,i%ConditionalWithHostVars) }
 . i i%ConditionFields="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPconditionfields,i%ConditionFields) }
 . i i%Global="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPglobal,i%Global) }
 . i i%PopulationPct="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationpct,i%PopulationPct) }
 . i i%PopulationType="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPpopulationtype,i%PopulationType) }
 . i i%RowReference="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwreference,i%RowReference) }
 . i i%Structure="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPstructure,i%Structure) }
 . i i%Type="" { $$$defStorageSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype) } else { $$$defStorageSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPtype,i%Type) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLMa80ES</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Data name="BlockCount">
<RetrievalCode> s {BlockCount}=$g(^oddDEF({L1},"s",{L3},"S",{L5},29),$g(^%qCacheObjectKey(1,"S",29)))
</RetrievalCode>
</Data>
<Data name="Condition">
<RetrievalCode> s {Condition}=$g(^oddDEF({L1},"s",{L3},"S",{L5},21),$g(^%qCacheObjectKey(1,"S",21)))
</RetrievalCode>
</Data>
<Data name="ConditionFields">
<RetrievalCode> s {ConditionFields}=$g(^oddDEF({L1},"s",{L3},"S",{L5},23),$g(^%qCacheObjectKey(1,"S",23)))
</RetrievalCode>
</Data>
<Data name="ConditionalWithHostVars">
<RetrievalCode> s {ConditionalWithHostVars}=$g(^oddDEF({L1},"s",{L3},"S",{L5},22),$g(^%qCacheObjectKey(1,"S",22)))
</RetrievalCode>
</Data>
<Data name="PopulationPct">
<RetrievalCode> s {PopulationPct}=$g(^oddDEF({L1},"s",{L3},"S",{L5},25),$g(^%qCacheObjectKey(1,"S",25)))
</RetrievalCode>
</Data>
<Data name="PopulationType">
<RetrievalCode> s {PopulationType}=$g(^oddDEF({L1},"s",{L3},"S",{L5},26),$g(^%qCacheObjectKey(1,"S",26)))
</RetrievalCode>
</Data>
<Data name="RowReference">
<RetrievalCode> s {RowReference}=$g(^oddDEF({L1},"s",{L3},"S",{L5},27),$g(^%qCacheObjectKey(1,"S",27)))
</RetrievalCode>
</Data>
<Data name="Structure">
<RetrievalCode> s {Structure}=$g(^oddDEF({L1},"s",{L3},"S",{L5},28),$g(^%qCacheObjectKey(1,"S",28)))
</RetrievalCode>
</Data>
<Data name="Type">
<RetrievalCode> s {Type}=$g(^oddDEF({L1},"s",{L3},"S",{L5},5),$g(^%qCacheObjectKey(1,"S",5)))
</RetrievalCode>
</Data>
<Data name="_Global">
<RetrievalCode> s {_Global}=$g(^oddDEF({L1},"s",{L3},"S",{L5},24),$g(^%qCacheObjectKey(1,"S",24)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapRowIdSpecDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.286573</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageSQLMapDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>RowIdSpecs</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Field">
<Description>
Field</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)
 s i%Name=$p(name,":",4)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%Expression=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression)
 . s i%Field=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageSQLMapDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,"")
 . i i%Expression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression,i%Expression) }
 . i i%Field="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield,i%Field) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapRowIdSpecDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,"")
 . i i%Expression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECexpression,i%Expression) }
 . i i%Field="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4,$$$cSDEFSQLMAPROWIDSPECfield,i%Field) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAProwidspec,name4) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLM480CS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"R"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageSQLMapRowIdSpecDefinition.Name}</Expression>
</Subscript>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"R",{L7},21),$g(^%qCacheObjectKey(1,"R",21)))
</RetrievalCode>
</Data>
<Data name="Field">
<RetrievalCode> s {Field}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"R",{L7},22),$g(^%qCacheObjectKey(1,"R",22)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapSubAccessvarDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.36219</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageSQLMapSubDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Accessvars</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Code">
<Description>
Code</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Variable">
<Description>
Variable</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)_"||"_$p(name,":",4)
 s i%Name=$p(name,":",5)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="")||('$$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,4)
 . s i%Name=name5
 . s i%Code=$$$defStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode)
 . s i%Variable=$$$defStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageSQLMapSubDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,4):1,i%Name'=$p(id,"||",5):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 . i '($$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,"")
 . i i%Code="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode,i%Code) }
 . i i%Variable="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable,i%Variable) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,4):1,i%Name'=$p(id,"||",5):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapSubAccessvarDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,"")
 . i i%Code="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARcode,i%Code) }
 . i i%Variable="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5,$$$cSDEFSQLMAPSUBACCESSVARvariable,i%Variable) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccessvar,name5) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLMABF4S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageSQLMapSubDefinition.Name}</Expression>
</Subscript>
<Subscript name="8">
<Expression>"A"</Expression>
</Subscript>
<Subscript name="9">
<Expression>{%Dictionary.StorageSQLMapSubAccessvarDefinition.Name}</Expression>
</Subscript>
<Data name="Code">
<RetrievalCode> s {Code}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},21),$g(^%qCacheObjectKey(1,"A",21)))
</RetrievalCode>
</Data>
<Data name="Variable">
<RetrievalCode> s {Variable}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},"A",{L9},22),$g(^%qCacheObjectKey(1,"A",22)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapSubDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.281555</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageSQLMapDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Subscripts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="AccessType">
<Description>
AccessType</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Accessvars">
<Description>
Accessvar</Description>
<Type>%Dictionary.StorageSQLMapSubAccessvarDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="DataAccess">
<Description>
DataAccess</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Delimiter">
<Description>
Delimiter</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Invalidconditions">
<Description>
Invalidcondition</Description>
<Type>%Dictionary.StorageSQLMapSubInvalidconditionDefinition</Type>
<Cardinality>children</Cardinality>
<Inverse>parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="LoopInitValue">
<Description>
LoopInitValue</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="NextCode">
<Description>
NextCode</Description>
<Type>%CacheString</Type>
</Property>

<Property name="NullMarker">
<Description>
NullMarker</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StartValue">
<Description>
StartValue</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StopExpression">
<Description>
StopExpression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="StopValue">
<Description>
StopValue</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)
 s i%Name=$p(name,":",4)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 i (name1="")||(name2="")||(name3="")||(name4="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||('$$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,3)
 . s i%Name=name4
 . s i%AccessType=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype)
 . s i%DataAccess=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess)
 . s i%Delimiter=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter)
 . s i%Expression=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression)
 . s i%LoopInitValue=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue)
 . s i%NextCode=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode)
 . s i%NullMarker=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker)
 . s i%StartValue=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue)
 . s i%StopExpression=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression)
 . s i%StopValue=$$$defStorageSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageSQLMapDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,"")
 . i i%AccessType="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype,i%AccessType) }
 . i i%DataAccess="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess,i%DataAccess) }
 . i i%Delimiter="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter,i%Delimiter) }
 . i i%Expression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression,i%Expression) }
 . i i%LoopInitValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue,i%LoopInitValue) }
 . i i%NextCode="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode,i%NextCode) }
 . i i%NullMarker="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker,i%NullMarker) }
 . i i%StartValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue,i%StartValue) }
 . i i%StopExpression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression,i%StopExpression) }
 . i i%StopValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue,i%StopValue) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,3):1,i%Name'=$p(id,"||",4):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapSubDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,"")
 . i i%AccessType="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBaccesstype,i%AccessType) }
 . i i%DataAccess="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdataaccess,i%DataAccess) }
 . i i%Delimiter="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBdelimiter,i%Delimiter) }
 . i i%Expression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBexpression,i%Expression) }
 . i i%LoopInitValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBloopinitvalue,i%LoopInitValue) }
 . i i%NextCode="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnextcode,i%NextCode) }
 . i i%NullMarker="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBnullmarker,i%NullMarker) }
 . i i%StartValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstartvalue,i%StartValue) }
 . i i%StopExpression="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopexpression,i%StopExpression) }
 . i i%StopValue="" { $$$defStorageSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue) } else { $$$defStorageSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBstopvalue,i%StopValue) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLM551BS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageSQLMapSubDefinition.Name}</Expression>
</Subscript>
<Data name="AccessType">
<RetrievalCode> s {AccessType}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},21),$g(^%qCacheObjectKey(1,"B",21)))
</RetrievalCode>
</Data>
<Data name="DataAccess">
<RetrievalCode> s {DataAccess}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},22),$g(^%qCacheObjectKey(1,"B",22)))
</RetrievalCode>
</Data>
<Data name="Delimiter">
<RetrievalCode> s {Delimiter}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},23),$g(^%qCacheObjectKey(1,"B",23)))
</RetrievalCode>
</Data>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},24),$g(^%qCacheObjectKey(1,"B",24)))
</RetrievalCode>
</Data>
<Data name="LoopInitValue">
<RetrievalCode> s {LoopInitValue}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},25),$g(^%qCacheObjectKey(1,"B",25)))
</RetrievalCode>
</Data>
<Data name="NextCode">
<RetrievalCode> s {NextCode}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},26),$g(^%qCacheObjectKey(1,"B",26)))
</RetrievalCode>
</Data>
<Data name="NullMarker">
<RetrievalCode> s {NullMarker}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},27),$g(^%qCacheObjectKey(1,"B",27)))
</RetrievalCode>
</Data>
<Data name="StartValue">
<RetrievalCode> s {StartValue}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},28),$g(^%qCacheObjectKey(1,"B",28)))
</RetrievalCode>
</Data>
<Data name="StopExpression">
<RetrievalCode> s {StopExpression}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},29),$g(^%qCacheObjectKey(1,"B",29)))
</RetrievalCode>
</Data>
<Data name="StopValue">
<RetrievalCode> s {StopValue}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},30),$g(^%qCacheObjectKey(1,"B",30)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.StorageSQLMapSubInvalidconditionDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent</Super>
<System>2</System>
<TimeChanged>66186,80421.37261</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.StorageSQLMapSubDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Invalidconditions</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Expression">
<Description>
Expression</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Name">
<Description>
Name</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))_"||"_$p(name,":",2)_"||"_$p(name,":",3)_"||"_$p(name,":",4)
 s i%Name=$p(name,":",5)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||(name3="")||(name4="")||(name5="")||('$$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,4)
 . s i%Name=name5
 . s i%Expression=$$$defStorageSubSubSubMemberKeyGet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.StorageSQLMapSubDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,4):1,i%Name'=$p(id,"||",5):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 . i '($$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defStorageSubSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,"")
 . i i%Expression="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression,i%Expression) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,4):1,i%Name'=$p(id,"||",5):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.StorageSQLMapSubInvalidconditionDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defStorageSubSubSubMemberSet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,"")
 . i i%Expression="" { $$$defStorageSubSubSubMemberKeyKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression) } else { $$$defStorageSubSubSubMemberKeySet(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5,$$$cSDEFSQLMAPSUBINVCONDexpression,i%Expression) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2),name3=$p(id,"||",3),name4=$p(id,"||",4),name5=$p(id,"||",5)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defStorageSubSubSubMemberDefined(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defStorageSubSubSubMemberKill(name1,$$$cCLASSstorage,name2,$$$cSDEFsqlmap,name3,$$$cSDEFSQLMAPsubscript,name4,$$$cSDEFSQLMAPSUBinvalidcondition,name5) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.StorageSQLM5FA0S</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"s"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.StorageDefinition.Name}</Expression>
</Subscript>
<Subscript name="4">
<Expression>"S"</Expression>
</Subscript>
<Subscript name="5">
<Expression>{%Dictionary.StorageSQLMapDefinition.Name}</Expression>
</Subscript>
<Subscript name="6">
<Expression>"B"</Expression>
</Subscript>
<Subscript name="7">
<Expression>{%Dictionary.StorageSQLMapSubDefinition.Name}</Expression>
</Subscript>
<Subscript name="8">
<Expression>"N"</Expression>
</Subscript>
<Subscript name="9">
<Expression>{%Dictionary.StorageSQLMapSubInvalidconditionDefinition.Name}</Expression>
</Subscript>
<Data name="Expression">
<RetrievalCode> s {Expression}=$g(^oddDEF({L1},"s",{L3},"S",{L5},"B",{L7},"N",{L9},21),$g(^%qCacheObjectKey(1,"N",21)))
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.TriggerDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.TriggerDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.726632</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>Triggers</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Code">
<Description>
The code that is executed when the trigger is fired.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="CodeMode">
<Description>
Specifies how a given method is implemented: lines of code to be compiled, or a method that will generate the resulting method or object.</Description>
<Type>%CacheString</Type>
<InitialExpression>"code"</InitialExpression>
</Property>

<Property name="Deprecated">
<Description>
True if this trigger is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the SQL trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Event">
<Description>
Specifies the SQL event that will fire the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Final">
<Description>
Specifies that subclasses cannot override the definition of the SQL trigger.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Foreach">
<Description>
Indicates if the trigger will be invoked for each row, for rows and objects, or for each statement</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Language">
<Description>
The language used to implement this trigger.</Description>
<Type>%CacheString</Type>
<SqlFieldName>_Language</SqlFieldName>
</Property>

<Property name="Name">
<Description>
The name of the SQL trigger.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="NewTable">
<Description>
The name of the SQL table that holds old values for the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="OldTable">
<Description>
The name of the SQL table that holds old values for the trigger.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Order">
<Description>
In the case of multiple triggers for the same EVENT and TIME, specifies the order in which the triggers should be fired.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SqlName">
<Description>
Specifies an alternate name when this trigger is used by SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Time">
<Description>
Specifies whether the trigger is fired before or after the EVENT.</Description>
<Type>%CacheString</Type>
<InitialExpression>"BEFORE"</InitialExpression>
<SqlFieldName>_Time</SqlFieldName>
</Property>

<Property name="UpdateColumnList">
<Description>
Specifies one or more columns whose modification causes the trigger to be pulled by SQL.</Description>
<Type>%CacheString</Type>
</Property>

<Method name="CodeModeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="code" q $$$OK
 i val="generator" q $$$OK
 i val="objectgenerator" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.TriggerDefinition:CodeMode",val)
]]></Implementation>
</Method>

<Method name="EventIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="INSERT" q $$$OK
 i val="UPDATE" q $$$OK
 i val="DELETE" q $$$OK
 i val="INSERT/UPDATE" q $$$OK
 i val="INSERT/DELETE" q $$$OK
 i val="UPDATE/DELETE" q $$$OK
 i val="INSERT/UPDATE/DELETE" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.TriggerDefinition:Event",val)
]]></Implementation>
</Method>

<Method name="ForeachIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="row" q $$$OK
 i val="row/object" q $$$OK
 i val="statement" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.TriggerDefinition:Foreach",val)
]]></Implementation>
</Method>

<Method name="LanguageIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="" q $$$OK
 i val="cache" q $$$OK
 i val="tsql" q $$$OK
 i val="ispl" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.TriggerDefinition:Language",val)
]]></Implementation>
</Method>

<Method name="TimeIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="BEFORE" q $$$OK
 i val="AFTER" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.TriggerDefinition:Time",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASStrigger,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASStrigger,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Code=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode)
 . s i%CodeMode=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode)
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription)
 . s i%Event=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent)
 . s i%Final=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal)
 . s i%Foreach=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal)
 . s i%Language=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage)
 . s i%NewTable=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable)
 . s i%OldTable=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable)
 . s i%Order=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber)
 . s i%SqlName=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname)
 . s i%Time=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime)
 . s i%UpdateColumnList=$$$defMemberKeyGet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist)
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASStrigger,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASStrigger,name2,"")
 . i i%Code="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode,i%Code) }
 . i i%CodeMode="code" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode,i%CodeMode) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription,i%Description) }
 . i i%Event="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent,i%Event) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal,i%Final) }
 . i i%Foreach="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach,i%Foreach) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal,i%Internal) }
 . i i%Language="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage,i%Language) }
 . i i%NewTable="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable,i%NewTable) }
 . i i%OldTable="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable,i%OldTable) }
 . i i%Order=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder,i%Order) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname,i%SqlName) }
 . i i%Time="BEFORE" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime,i%Time) }
 . i i%UpdateColumnList="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist,i%UpdateColumnList) }
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASStrigger,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.TriggerDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASStrigger,name2,"")
 . i i%Code="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcode,i%Code) }
 . i i%CodeMode="code" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERcodemode,i%CodeMode) }
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERdescription,i%Description) }
 . i i%Event="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERevent,i%Event) }
 . i i%Final=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERfinal,i%Final) }
 . i i%Foreach="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERforeach,i%Foreach) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERinternal,i%Internal) }
 . i i%Language="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERlanguage,i%Language) }
 . i i%NewTable="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERnewtable,i%NewTable) }
 . i i%OldTable="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERoldtable,i%OldTable) }
 . i i%Order=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERorder,i%Order) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsequencenumber,i%SequenceNumber) }
 . i i%SqlName="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERsqlname,i%SqlName) }
 . i i%Time="BEFORE" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERtime,i%Time) }
 . i i%UpdateColumnList="" { $$$defMemberKeyKill(name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist) } else { $$$defMemberKeySet(name1,$$$cCLASStrigger,name2,$$$cTRIGGERupdatecolumnlist,i%UpdateColumnList) }
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASStrigger,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASStrigger,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.TriggerDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"t"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.TriggerDefinition.Name}</Expression>
</Subscript>
<Data name="Code">
<RetrievalCode> s {Code}=$s($d(^oddDEF({L1},"t",{L3},21))#2:^(21),1:"")
</RetrievalCode>
</Data>
<Data name="CodeMode">
<RetrievalCode> s {CodeMode}=$s($d(^oddDEF({L1},"t",{L3},31))#2:^(31),1:"code")
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"t",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"t",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Event">
<RetrievalCode> s {Event}=$s($d(^oddDEF({L1},"t",{L3},22))#2:^(22),1:"")
</RetrievalCode>
</Data>
<Data name="Final">
<RetrievalCode> s {Final}=$s($d(^oddDEF({L1},"t",{L3},7))#2:^(7),1:0)
</RetrievalCode>
</Data>
<Data name="Foreach">
<RetrievalCode> s {Foreach}=$s($d(^oddDEF({L1},"t",{L3},26))#2:^(26),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"t",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="NewTable">
<RetrievalCode> s {NewTable}=$s($d(^oddDEF({L1},"t",{L3},29))#2:^(29),1:"")
</RetrievalCode>
</Data>
<Data name="OldTable">
<RetrievalCode> s {OldTable}=$s($d(^oddDEF({L1},"t",{L3},30))#2:^(30),1:"")
</RetrievalCode>
</Data>
<Data name="Order">
<RetrievalCode> s {Order}=$s($d(^oddDEF({L1},"t",{L3},23))#2:^(23),1:0)
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"t",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="SqlName">
<RetrievalCode> s {SqlName}=$s($d(^oddDEF({L1},"t",{L3},24))#2:^(24),1:"")
</RetrievalCode>
</Data>
<Data name="UpdateColumnList">
<RetrievalCode> s {UpdateColumnList}=$s($d(^oddDEF({L1},"t",{L3},28))#2:^(28),1:"")
</RetrievalCode>
</Data>
<Data name="_Language">
<RetrievalCode> s {_Language}=$s($d(^oddDEF({L1},"t",{L3},27))#2:^(27),1:"")
</RetrievalCode>
</Data>
<Data name="_Time">
<RetrievalCode> s {_Time}=$s($d(^oddDEF({L1},"t",{L3},25))#2:^(25),1:"BEFORE")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.TriggerDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41414</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASStrigger)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.UDLTextDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.UDLTextDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.724421</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>UDLTexts</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Category">
<Description>
Category</Description>
<Type>%CacheString</Type>
<InitialExpression>"comment"</InitialExpression>
</Property>

<Property name="Content">
<Description>
Holds the content of the UDL text.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="Name">
<Description>
Speficies the COS name of the UDL text.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="Position">
<Description>
Position</Description>
<Type>%CacheString</Type>
<InitialExpression>"body"</InitialExpression>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="TextType">
<Description>
TextType</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="CategoryIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="comment" q $$$OK
 i val="error" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.UDLTextDefinition:Category",val)
]]></Implementation>
</Method>

<Method name="PositionIsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i val="body" q $$$OK
 i val="header" q $$$OK
 q $$$ERROR($$$DatatypeValidationFailed,"%Dictionary.UDLTextDefinition:Position",val)
]]></Implementation>
</Method>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSudltext,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSudltext,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Category=$$$defMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory)
 . s i%Position=$$$defMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber)
 . s i%TextType=$$$defMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype)
 . s i%Content=""
 . f ptr=1:1:$$$defMemberKeyGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent) d
 . . d ..Content.WriteLine($$$defMemberArrayGet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,ptr))
 . d ..Content.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSudltext,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSudltext,name2,"")
 . i i%Category="comment" { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory,i%Category) }
 . i i%Position="body" { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition,i%Position) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber,i%SequenceNumber) }
 . i i%TextType=0 { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype,i%TextType) }
 . $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent)
 . d ..Content.Rewind() s ..Content.LineTerminator=$c(10)
 . f line=1:1 q:..Content.AtEnd  d
 . . s linetext=..Content.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,line-1)
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSudltext,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.UDLTextDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSudltext,name2,"")
 . i i%Category="comment" { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcategory,i%Category) }
 . i i%Position="body" { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTposition,i%Position) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTsequencenumber,i%SequenceNumber) }
 . i i%TextType=0 { $$$defMemberKeyKill(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype) } else { $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTtexttype,i%TextType) }
 . d ..Content.Rewind() s ..Content.LineTerminator=$c(10)
 . f line=1:1 q:..Content.AtEnd  d
 . . s linetext=..Content.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSudltext,name2,$$$cUDLTEXTcontent,line-1)
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSudltext,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSudltext,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.UDLTextDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"u"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.UDLTextDefinition.Name}</Expression>
</Subscript>
<Data name="Category">
<RetrievalCode> s {Category}=$s($d(^oddDEF({L1},"u",{L3},23))#2:^(23),1:"comment")
</RetrievalCode>
</Data>
<Data name="Content">
<RetrievalCode> s {Content}=""
</RetrievalCode>
</Data>
<Data name="Position">
<RetrievalCode> s {Position}=$s($d(^oddDEF({L1},"u",{L3},24))#2:^(24),1:"body")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"u",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="TextType">
<RetrievalCode> s {TextType}=$s($d(^oddDEF({L1},"u",{L3},22))#2:^(22),1:0)
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.UDLTextDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41414</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSudltext)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>


<Class name="%Dictionary.XDataDefinition">
<StorageStrategy>custom</StorageStrategy>
<Super>%Persistent,%Dictionary.XDataDefinitionQuery</Super>
<System>2</System>
<TimeChanged>66186,80420.753089</TimeChanged>
<TimeCreated>66186,77919</TimeCreated>

<Property name="parent">
<Description>
Pointer to the containing parent object</Description>
<Type>%Dictionary.ClassDefinition</Type>
<Cardinality>parent</Cardinality>
<Inverse>XDatas</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Data">
<Description>
The data stream.</Description>
<Type>%Stream.TmpCharacter</Type>
</Property>

<Property name="Deprecated">
<Description>
True if this XDATA is deprecated.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Description">
<Description>
Specifies a description of the XData.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="Internal">
<Description>
If true, then do not display this item in automatic documentation.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="MimeType">
<Description>
Mime type of XData block.</Description>
<Type>%CacheString</Type>
<InitialExpression>"text/xml"</InitialExpression>
</Property>

<Property name="Name">
<Description>
The name of the xData block.</Description>
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="SchemaSpec">
<Description>
The schema definition of the data.</Description>
<Type>%CacheString</Type>
</Property>

<Property name="SequenceNumber">
<Description>
SequenceNumber</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="XMLNamespace">
<Description>
The default XML NameSpace for the XDATA.</Description>
<Type>%CacheString</Type>
</Property>

<Index name="IDKEY">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Parameter name="SQLENABLED">
<Default>1</Default>
</Parameter>

<Trigger name="OnInsertUpdate">
<Code> set %ok=0
 set %msg="Insert/Update operations not supported on this table."
</Code>
<Event>INSERT/UPDATE</Event>
<Time>BEFORE</Time>
</Trigger>

<Trigger name="OnDelete">
<Code> $$$defClassKeySet($p({parent},"||",1),$$$cCLASStimechanged,$zutil(188))
 do RebuildItemIndex^%R($p({parent},"||",1),"CLS")
</Code>
<Event>DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Method name="%OnNew">
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 i $g(name)="" q $$$OK
 s i%parent=$$$NormalizeClassname($p(name,":",1))
 s i%Name=$p(name,":",2)
 q $$$OK
]]></Implementation>
</Method>

<Property name="Object">
<Description>
The object representation of this XData block after correlating the XML and importing it</Description>
<Type>%RegisteredObject</Type>
<Calculated>1</Calculated>
</Property>

<Method name="ObjectGet">
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[ q ##class(%Studio.SASchemaUtil).returnCorrelated($this)
]]></Implementation>
</Method>

<Method name="%LockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,timeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$LockClassRef^%occLock(name1,shared,.timeout)
]]></Implementation>
</Method>

<Method name="%UnlockId">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,shared:%Boolean=0,immediate:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 QUIT $$UnlockClassRef^%occLock(name1,shared,immediate)
]]></Implementation>
</Method>

<Method name="%Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s $zt="TrapExists"
 s id=$$$oidPrimary(oid) QUIT:id="" $$$ERROR($$$NullId)
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 i (name1="")||(name2="") QUIT 0
 i '$$$defClassDefined(name1)||($$$defClassKeyGet(name1,$$$cCLASSdeployed)=2) QUIT 0
 i $$$defMemberDefined(name1,$$$cCLASSxdata,name2) QUIT 1
 QUIT 0
TrapExists s $zt=""
 QUIT 0
]]></Implementation>
</Method>

<Method name="%LoadData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 s sc=$$$OK
 s $zt="trap"
 i i%%Concurrency>0 s sc=..%LockId(id,i%%Concurrency'=4) If $$$ISERR(sc) Quit sc
 i (name1="")||(name2="")||('$$$defMemberDefined(name1,$$$cCLASSxdata,name2)) s sc=$$$ERROR($$$LoadObjectNotFound,$classname(),id)
 i $$$ISOK(sc),$$$defClassKeyGet(name1,$$$cCLASSdeployed)=2 s sc=$$$ERROR($$$ClassIsStub,name1)
 i $$$ISOK(sc),$$$defClassVersionGet(name1)'=$$$CLASSDEFINITIONVERSION s sc=$$$ERROR($$$OneClassDictionaryVersionMismatch,name1)
 i $$$ISOK(sc) d
 . s i%parent=$p(id,"||",1,1)
 . s i%Name=name2
 . s i%Deprecated=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated)
 . s i%Description=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdescription)
 . s i%Internal=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAinternal)
 . s i%MimeType=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype)
 . s i%SchemaSpec=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec)
 . s i%SequenceNumber=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber)
 . s i%XMLNamespace=$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace)
 . s i%Data=""
 . f ptr=1:1:$$$defMemberKeyGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata) d
 . . d ..Data.WriteLine($$$defMemberArrayGet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,ptr))
 . d ..Data.Rewind()
exit i i%%Concurrency=2||(i%%Concurrency=1) d ..%UnlockId(id,1,1)
 q sc
trap s $zt=""
 s sc=$$$ERROR($$$CacheError,$ze)
 g exit
]]></Implementation>
</Method>

<Method name="%SaveData">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$IsClassDefVersionMatched(ismatched) i ismatched=0 q $$$ERROR($$$ClassDictionaryVersionMismatch)
 s sc=$$$OK,id=$$$idCurrent i id'="" s insert=0,idassigned=1
 e  s insert=1,idassigned=0
 s lock=0
 i i%parent'="",'##class(%Dictionary.ClassDefinition).%ExistsId(i%parent) q $$$ERROR($$$ReferencedObjectDoesNotExist,"ClassName")
 i 'insert DO
 . i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i '($$$defMemberDefined(name1,$$$cCLASSxdata,name2)) s insert=1 q
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . $$$defMemberSet(name1,$$$cCLASSxdata,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAinternal,i%Internal) }
 . i i%MimeType="text/xml" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype,i%MimeType) }
 . i i%SchemaSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec,i%SchemaSpec) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber,i%SequenceNumber) }
 . i i%XMLNamespace="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace,i%XMLNamespace) }
 . $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAdata)
 . d ..Data.Rewind() s ..Data.LineTerminator=$c(10)
 . f line=1:1 q:..Data.AtEnd  d
 . . s linetext=..Data.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,line-1)
 i insert DO
 . i 'idassigned s id=i%parent_"||"_i%Name i 1
 . e  i $s(i%parent'=$p(id,"||",1,1):1,i%Name'=$p(id,"||",2):1,1:0) s sc=$$$ERROR($$$OidPreviouslyAssigned,$classname(),id) q
 . s name1=$p(id,"||",1),name2=$p(id,"||",2)
 . i i%%Concurrency s sc=..%LockId(id) s lock=$$$ISOK(sc) i 'lock q
 . i $$$defMemberDefined(name1,$$$cCLASSxdata,name2) s sc=$$$ERROR($$$IDKeyNotUnique,"%Dictionary.XDataDefinition",$zreference,"") q
 . i 'idassigned s sc=..%IdSet(id) q:$$$ISERR(sc)  s:$$$txON $$$txOIDASSIGNED($this)=""
 . $$$defMemberSet(name1,$$$cCLASSxdata,name2,"")
 . i i%Deprecated=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdeprecated,i%Deprecated) }
 . i i%Description="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAdescription) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdescription,i%Description) }
 . i i%Internal=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAinternal) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAinternal,i%Internal) }
 . i i%MimeType="text/xml" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAmimetype,i%MimeType) }
 . i i%SchemaSpec="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAschemaspec,i%SchemaSpec) }
 . i i%SequenceNumber=0 { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAsequencenumber,i%SequenceNumber) }
 . i i%XMLNamespace="" { $$$defMemberKeyKill(name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace) } else { $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAxmlnamespace,i%XMLNamespace) }
 . d ..Data.Rewind() s ..Data.LineTerminator=$c(10)
 . f line=1:1 q:..Data.AtEnd  d
 . . s linetext=..Data.ReadLine($$$MaxLocalLength) i $e(linetext,*)=$c(13) s linetext=$e(linetext,1,*-1)
 . . $$$defMemberArraySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,line,linetext)
 . $$$defMemberKeySet(name1,$$$cCLASSxdata,name2,$$$cXDATAdata,line-1)
 . i i%%Concurrency=3 s sc=..%LockId(id,1)
 . s:i%%Concurrency=4 lock=0
 i $$$ISERR(sc) d:lock ..%UnlockId(id) QUIT sc
 d:lock ..%UnlockId(id)
 If $$$ISOK(sc) Set %objTX(9,"Do UpdClsDef^%occLibrary("""_name1_""")")=""
 QUIT sc
]]></Implementation>
</Method>

<Method name="%DeleteData">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Quit:id="" $$$ERROR($$$NullId)
 Set sc=$$$OK
 s name1=$p(id,"||",1),name2=$p(id,"||",2)
 If concurrency Set sc=..%LockId(id) If $$$ISERR(sc) Quit sc
 If '($$$defMemberDefined(name1,$$$cCLASSxdata,name2)) {
  If '$$$GetddlNo30 Set sc=$$$ERROR($$$DeleteObjectNotFound,$classname(),id)
 } Else {
  $$$defMemberKill(name1,$$$cCLASSxdata,name2) Do UpdClsDef^%occLibrary(name1)
 }
 If concurrency Do ..%UnlockId(id)
 Quit sc
]]></Implementation>
</Method>

<Method name="parentOnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,concurrency:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Quit $$$OK
]]></Implementation>
</Method>

<Storage name="custom">
<Type>%CustomStorage</Type>
<StreamLocation>^%Dictionary.XDataDefinitionS</StreamLocation>
<SQLMap name="Master">
<Type>data</Type>
<Global>^oddDEF</Global>
<Structure>delimited</Structure>
<Subscript name="1">
<Expression>{%Dictionary.ClassDefinition.Name}</Expression>
</Subscript>
<Subscript name="2">
<Expression>"x"</Expression>
</Subscript>
<Subscript name="3">
<Expression>{%Dictionary.XDataDefinition.Name}</Expression>
</Subscript>
<Data name="Data">
<RetrievalCode> s {Data}=""
</RetrievalCode>
</Data>
<Data name="Deprecated">
<RetrievalCode> s {Deprecated}=$s($d(^oddDEF({L1},"x",{L3},17))#2:^(17),1:0)
</RetrievalCode>
</Data>
<Data name="Description">
<RetrievalCode> s {Description}=$s($d(^oddDEF({L1},"x",{L3},4))#2:^(4),1:"")
</RetrievalCode>
</Data>
<Data name="Internal">
<RetrievalCode> s {Internal}=$s($d(^oddDEF({L1},"x",{L3},14))#2:^(14),1:0)
</RetrievalCode>
</Data>
<Data name="MimeType">
<RetrievalCode> s {MimeType}=$s($d(^oddDEF({L1},"x",{L3},24))#2:^(24),1:"text/xml")
</RetrievalCode>
</Data>
<Data name="SchemaSpec">
<RetrievalCode> s {SchemaSpec}=$s($d(^oddDEF({L1},"x",{L3},22))#2:^(22),1:"")
</RetrievalCode>
</Data>
<Data name="SequenceNumber">
<RetrievalCode> s {SequenceNumber}=$s($d(^oddDEF({L1},"x",{L3},11))#2:^(11),1:0)
</RetrievalCode>
</Data>
<Data name="XMLNamespace">
<RetrievalCode> s {XMLNamespace}=$s($d(^oddDEF({L1},"x",{L3},23))#2:^(23),1:"")
</RetrievalCode>
</Data>
</SQLMap>
</Storage>
</Class>


<Class name="%Dictionary.XDataDefinitionQuery">
<Abstract>1</Abstract>
<ProcedureBlock>0</ProcedureBlock>
<System>2</System>
<TimeChanged>66186,77912</TimeChanged>
<TimeCreated>59241,41414</TimeCreated>

<Query name="Summary">
<Type>%Query</Type>
<FormalSpec>classname:%String</FormalSpec>
<Parameter name="ROWSPEC" value="Name"/>
</Query>

<Method name="SummaryExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,classname:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryExecute(.QHandle,classname,$$$cCLASSxdata)
]]></Implementation>
</Method>

<Method name="SummaryFetch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle,.Row,.AtEnd)
]]></Implementation>
</Method>

<Method name="SummaryClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>QHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%Dictionary.ClassDefinitionQuery).MemberSummaryFetch(.QHandle)
]]></Implementation>
</Method>
</Class>
</Export>
