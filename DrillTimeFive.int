DrillTimeFive
; Traverses global structures and maps data to CSV rows based on class metadata.
; Compatible with Caché 2018. Uses %Dictionary.ClassDefinition for property metadata.
;
DrillTimeThree(pGlobal, pClass, pKeyList)
    s $ZERROR=""
    s $ZTRAP=""
    set $ZTRAP="TRAP^DrillTimeFive"

    new keyLength, keyFields, fieldMap, classDef, sc
    new seq, propName, propObj, skip, type, coll, outputProps, i, val, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap
    new fkParentMap, fkSubPropMap, fkTypeMap
    set recCount=0
    do InitAnim
    if pGlobal="",pClass="" {
    . do ExportNamespace(pKeyList)
    . quit
    }
    ; Determine key length from string or count
    set keyLength=1
    if pKeyList'="" {
    . if pKeyList?1N.N {
    . . set keyLength=+pKeyList
    . } else {
    . . set keyLength=$length(pKeyList, ",")
    . . for i=1:1:keyLength set keyFields(i)=$piece(pKeyList,",",i)
    . }
    }

    ; Use ClassDefinition instead of CompiledClass for better compatibility
    set classDef=##class(%Dictionary.ClassDefinition).%OpenId(pClass,.sc)
    if '$isobject(classDef) {
    . write "ERROR: Class not found or could not open: ",pClass,! quit
    }

    ; Loop through all Properties safely using $ORDER
    set i=""
    s totalProps=classDef.Properties.Count()
    i (('$l($g(totalProps)))||(totalProps=0)) w !,"No Properties" q
    for i=1:1:totalProps {  
     quit:i=""
     set propObj=classDef.Properties.GetAt(i)
     if '$isobject(propObj) continue
     set skip=0
     if $property(propObj,"Calculated") set skip=1
     if $property(propObj,"Relationship") set skip=1
     if $property(propObj,"MultiDimensional") set skip=1
     set coll=$property(propObj,"Collection") if coll'="" set skip=1
     set type=$property(propObj,"Type") if type["%Stream" set skip=1
     ;if $property(propObj,"Storable")=0 set skip=1
     if skip=1 continue
     set propName=$property(propObj,"Name")
     set seq=$property(propObj,"SequenceNumber") if seq="" set seq=9999
     set outputProps(seq)=propName
     s storageProps=classDef.Storages.GetAt(i)
     if ($l($g(storageProps))){
     set fieldNodeMap(propName)=$property(storageProps,"Node")
     set fieldPieceMap(propName)=$property(storageProps,"Piece")
     }
     set fieldTypeMap(propName)=type
     ; Attempt to flatten foreign key object references
     if type'?1"%".E {
     . new subClass,subSc set subClass=##class(%Dictionary.ClassDefinition).%OpenId(type,.subSc)
     . if $isobject(subClass) {
     . . new j,subObj,subSkip,subColl,subType,subName,fkSeq
     . . set fkSeq=1
     . . for j=1:1:subClass.Properties.Count() {
     . . . set subObj=subClass.Properties.GetAt(j) quit:'$isobject(subObj)
     . . . set subSkip=0
     . . . if $property(subObj,"Calculated") set subSkip=1
     . . . if $property(subObj,"Relationship") set subSkip=1
     . . . if $property(subObj,"MultiDimensional") set subSkip=1
     . . . set subColl=$property(subObj,"Collection") if subColl'="" set subSkip=1
     . . . set subType=$property(subObj,"Type") if subType["%Stream" set subSkip=1
     . . . if subSkip=1 continue
     . . . set subName=$property(subObj,"Name")
     . . . new colName set colName=propName_"_"_subName
     . . . set outputProps(seq+(fkSeq/1000))=colName
     . . . set fkParentMap(colName)=propName
     . . . set fkSubPropMap(colName)=subName
     . . . set fkTypeMap(colName)=type
     . . . set fkSeq=fkSeq+1
     . . }
     . }
     }
    }

    ; Add CSV header line using proper $ORDER traversal
    new headerLine set headerLine=""
    set i=""
    for {set i=$order(outputProps(i)) quit:i=""
     set propName=outputProps(i)
     i headerLine'="" set headerLine=headerLine_","_"""_propName_"""  i '$l($g(headerLine)) set headerLine=""""_propName_""""
    }
    set ^EXPORT($J,0)=headerLine

    ; Begin recursive traversal from global root
    do Traverse("^"_pGlobal, "", keyLength, pClass, .outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap, .fkParentMap, .fkSubPropMap, .fkTypeMap)
    write !
    do WriteCSV(pClass)
    write !,"Export complete: ",recCount," rows written to CSV.",! quit

TRAP ; Basic error handler
    write "ERROR: ",$zerror,! quit

; Recursive global walker
Traverse(gref, subs, keyLength, className, outputProps, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap, fkParentMap, fkSubPropMap, fkTypeMap)
    new sub set sub=""
    for {
    . set sub=$order(@(gref_sub)) quit:sub=""
    . new newSubs if subs'="" set newSubs=subs_","_$$Q(sub) i '$l($g(sub)) set newSubs=$$Q($g(sub))
    . new fullRef set fullRef=gref_"("_newSubs_")"
    . new subCount set subCount=$length(newSubs, ",")
    . if subCount<keyLength {
    . . do Traverse(gref, newSubs, keyLength, className, outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap, .fkParentMap, .fkSubPropMap, .fkTypeMap)
    . } else {
    . . if $data(@@fullRef)#10 do ProcessNode(fullRef, className, outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap, .fkParentMap, .fkSubPropMap, .fkTypeMap)
    . . do Traverse(gref, newSubs, keyLength+1, className, outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap, .fkParentMap, .fkSubPropMap, .fkTypeMap)
    . }
    } quit

; Parses node data and maps it to correct CSV fields
ProcessNode(ref, className, outputProps, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap, fkParentMap, fkSubPropMap, fkTypeMap)
    new val, line, dataNode, prop, i, dataPiece, dataStr, type, joinedVal, obj, sc
    new parent,fkProp,fkType
    set val=$get(@@ref)
    set line=""
    set i=""
    for {
    . set i=$order(outputProps(i)) quit:i=""
    . set prop=outputProps(i)
    . set dataNode=fieldNodeMap(prop)
    . set dataPiece=fieldPieceMap(prop)
    . set type=fieldTypeMap(prop)
    . if $data(fkParentMap(prop)) {
    . . set parent=fkParentMap(prop)
    . . set fkProp=fkSubPropMap(prop)
    . . set fkType=fkTypeMap(prop)
    . . new parentPiece set parentPiece=fieldPieceMap(parent)
    . . if parentPiece'="" {
    . . . set dataStr=$piece(val,"^",parentPiece)
    . . } else {
    . . . set dataStr=val
    . . }
    . . set obj="" if dataStr'="" set obj=##class(fkType).%OpenId(dataStr,.sc)
    . . set dataStr="" if $isobject(obj) set dataStr=$property(obj,fkProp)
    . } else {
    . . if dataPiece'="" {
    . . . set dataStr=$piece(val,"^",dataPiece)
    . . } else {
    . . . set dataStr=val
    . . }
    . . if type'="" {
    . . . if type'?1"%".E {
    . . . . ; normal scalar, do nothing
    . . . } else {
    . . . . if ##class(%Dictionary.ClassDefinition).%ExistsId(type) {
    . . . . . set joinedVal=dataStr
    . . . . . set obj=##class(type).%OpenId(dataStr,.sc)
    . . . . . if $isobject(obj) {
    . . . . . . if $property(obj,"Name")'="" set joinedVal=$property(obj,"Name")
    . . . . . . if $property(obj,"ID")'="" set joinedVal=$property(obj,"ID")
    . . . . . }
    . . . . . set dataStr=joinedVal
    . . . . }
    . . . }
    . . }
    . }
    . set dataStr=$replace(dataStr,"""","""""")
    . set dataStr=""""_dataStr_""""
    . if line'="" set line=line_","_dataStr  i '$l($g(line)) set line=dataStr
    }
    set recCount=recCount+1
    set ^EXPORT($J,recCount)=line
    do Animate($length(line))
    quit

; Write CSV file from ^EXPORT($J)
WriteCSV(className)
    new file,filePath,line,rec set filePath="C:\\InterSystems\\Cache\\Hackensack\\"_className_".csv"
    set file=##class(%File).%New()
    set file.Name=filePath
    if file.Exists() do file.Delete()
    set sc=file.Open("WNS") if $SYSTEM.Status.IsError(sc) { write "ERROR opening file",! quit }
    for rec=0:1:999999 {
     continue:'$data(^EXPORT($J,rec))
     set line=^EXPORT($J,rec)
     ;k ^EXPORT($J,rec)
     do file.WriteLine(line)
    }
    do file.Close()
    write "CSV file written to ",filePath,!
    quit

; Quote wrapper for string subscripts
Q(x) if x'?1N.N {quit "\""_x_"\""} else {quit x}

; Export all class-mapped globals in current namespace
ExportNamespace(pKeyList)
    new global,class,keyLen,sc,def,idKey
    set global=""
    for {
    . set global=$order(^$GLOBAL(global)) quit:global=""
    . set class=$$ClassFromGlobal(global)
    . if class="" continue
    . set def=##class(%Dictionary.ClassDefinition).%OpenId(class,.sc)
    . quit:'$isobject(def)
    . set keyLen=1
    . set idKey=def.Keys.IdKey
    . if $isobject(idKey) set keyLen=idKey.Properties.Count()
    . do DrillTimeThree(global,class,$select(pKeyList'="":pKeyList,keyLen))
    }
    quit

; Lookup class name for a given data global
ClassFromGlobal(glo)
    new class,sc,def,storage,dataLoc,root
    set class=""
    for {
    . set class=$order(^oddDEF(class)) quit:class=""
    . set def=##class(%Dictionary.ClassDefinition).%OpenId(class,.sc)
    . quit:'$isobject(def)
    . set storage=def.Storages.GetAt(1)
    . set dataLoc=$property(storage,"DataLocation")
    . set root=$piece(dataLoc,"(")
    . if root=glo quit class
    }
    quit ""

; Job spawner stub — can be enhanced for controller logic
RunExportJobs(pGlobal, pClass, pKeyLen)
    new key, count set count=0
    set key=""
    for { set key=$order(@("^"_pGlobal_"("_key_")")) quit:key=""
     ;new jobStr set jobStr="do DrillTimeThree(\""_pGlobal_"\",\""_pClass_"\","_key_")"
     job DrillTimeThree(pGlobal,pClass,key)
     set count=count+1
     write "Launched job for key: ",key,! ; Logging job launches
    }
    write count," jobs launched.",!
    quit

; Initialize animation state
InitAnim
    set ^ANIM($J,"spin")=0
    set ^ANIM($J,"bytes")=0
    quit

; Update spinner/drill animation and display KB processed
Animate(bytes)
    new spinChars,spinIndex,totalBytes,totalKB,drillPos,drill
    set spinChars="|/-\\"
    set spinIndex=$get(^ANIM($J,"spin"))+1 if spinIndex>4 set spinIndex=1
    set ^ANIM($J,"spin")=spinIndex
    set totalBytes=$get(^ANIM($J,"bytes"))+bytes
    set ^ANIM($J,"bytes")=totalBytes
    set totalKB=totalBytes/1024
    set drillPos=($int(totalKB)#20)+1
    set drill=$justify("",drillPos-1," ")_">"
    write $char(13),$extract(spinChars,spinIndex)," ",drill," ",totalKB,"KB drilled"
    quit
