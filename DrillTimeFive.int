DrillTimeFive
; Traverses global structures and maps data to CSV rows based on class metadata.
; Compatible with Caché 2018. Uses %Dictionary.ClassDefinition for property metadata.
;
DrillTimeThree(pGlobal, pClass, pKeyList)
    s $ZERROR=""
    s $ZTRAP=""
    set $ZTRAP="TRAP^DrillTimeFive"
    h 20

    new keyLength, keyFields, fieldMap, classDef, sc
    new seq, propName, propObj, skip, type, coll, outputProps, i, val, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap
    set recCount=0
    s pKeyList="HMO,ID,RIN"
    s pGlobal="^[""MHRREG""]HMOREF"
    s pClass="Referrals.Referral"
    ; Determine key length from string or count
    set keyLength=1
    if pKeyList'="" {
    . if pKeyList?1N.N {
    . . set keyLength=+pKeyList
    . } else {
    . . set keyLength=$length(pKeyList, ",")
    . . for i=1:1:keyLength set keyFields(i)=$piece(pKeyList,",",i)
    . }
    }

    ; Use ClassDefinition instead of CompiledClass for better compatibility
    set classDef=##class(%Dictionary.ClassDefinition).%OpenId(pClass,.sc)
    if '$isobject(classDef) {
    . write "ERROR: Class not found or could not open: ",pClass,! quit
    }

    ; Loop through all Properties safely using $ORDER
    set i=""
    s totalProps=classDef.Properties.Count()
    i (('$l($g(totalProps)))||(totalProps=0)) w !,"No Properties" q
    for i=1:1:totalProps {  
     quit:i=""
     set propObj=classDef.Properties.GetAt(i)
     if '$isobject(propObj) continue
     set skip=0
     if $property(propObj,"Calculated") set skip=1
     if $property(propObj,"Relationship") set skip=1
     if $property(propObj,"MultiDimensional") set skip=1
     set coll=$property(propObj,"Collection") if coll'="" set skip=1
     set type=$property(propObj,"Type") if type["%Stream" set skip=1
     ;if $property(propObj,"Storable")=0 set skip=1
     if skip=1 continue
     set propName=$property(propObj,"Name")
     set seq=$property(propObj,"SequenceNumber") if seq="" set seq=9999
     set outputProps(seq)=propName
     s storageProps=classDef.Storages.GetAt(i)
     if ($l($g(storageProps))){
     set fieldNodeMap(propName)=$property(storageProps,"Node")
     set fieldPieceMap(propName)=$property(storageProps,"Piece")
     }
     set fieldTypeMap(propName)=type
    }

    ; Add CSV header line using proper $ORDER traversal
    new headerLine set headerLine=""
    set i=""
    for {set i=$order(outputProps(i)) quit:i=""
     set propName=outputProps(i)
     i headerLine'="" set headerLine=headerLine_","_"""_propName_"""  i '$l($g(headerLine)) set headerLine=""""_propName_""""
    }
    set ^EXPORT($J,0)=headerLine

    ; Begin recursive traversal from resolved global root
    new gRoot set gRoot=$$ResolveGlobal(pGlobal,pClass)
    do Traverse(gRoot, "", keyLength, pClass, .outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap)
    do WriteCSV(pClass)
    write "Export complete: ",recCount," rows written to CSV.",! quit

TRAP ; Basic error handler
    write "ERROR: ",$zerror,! quit

; Resolve global name from input or class storage map
ResolveGlobal(gName,className)
    new gref,cls,storage,dataLoc
    set gref=gName
    if gref'["^" {
    . set cls=##class(%Dictionary.ClassDefinition).%OpenId(className)
    . if $isobject(cls) {
    . . set storage=$property(cls,"StorageDefault")
    . . if $isobject(storage) set gref=$property(storage,"DataLocation")
    . . if gref="" {
    . . . set storage=cls.Storages.GetAt(1)
    . . . if $isobject(storage) set gref=$property(storage,"DataLocation")
    . . }
    . }
    }
    if gref'["^" set gref="^"_gref
    quit gref

; Recursive global walker
Traverse(gref, subs, keyLength, className, outputProps, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap)
    new sub set sub=""
    for {
    . set sub=$order(@(gref_sub)) quit:sub=""
    . new newSubs if subs'="" set newSubs=subs_","_$$Q(sub) i '$l($g(sub)) set newSubs=$$Q($g(sub))
    . new fullRef set fullRef=gref_"("_newSubs_")"
    . new subCount set subCount=$length(newSubs, ",")
    . if subCount>=keyLength, $data(@@fullRef)#10 do ProcessNode(fullRef, className, outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap)
    . do Traverse(gref, newSubs, keyLength, className, outputProps, .recCount, .fieldNodeMap, .fieldPieceMap, .fieldTypeMap)
    } quit

; Parses node data and maps it to correct CSV fields
ProcessNode(ref, className, outputProps, recCount, fieldNodeMap, fieldPieceMap, fieldTypeMap)
    new val, line, dataNode, prop, i, dataPiece, dataStr, type, joinedVal, obj, sc
    set val=$get(@@ref)
    set line=""
    set i=""
    for {
    . set i=$order(outputProps(i)) quit:i=""
    . set prop=outputProps(i)
    . set dataNode=fieldNodeMap(prop)
    . set dataPiece=fieldPieceMap(prop)
    . set type=fieldTypeMap(prop)
    . if dataPiece'="" {
    . . set dataStr=$piece(val,"^",dataPiece)
    . } else {
    . . set dataStr=val
    . }
    . if type'="" {
    . . if type'?1"%".E {
    . . . ; normal scalar, do nothing
    . . } else {
    . . . if ##class(%Dictionary.ClassDefinition).%ExistsId(type) {
    . . . . set joinedVal=dataStr
    . . . . set obj=##class(type).%OpenId(dataStr,.sc)
    . . . . if $isobject(obj) {
    . . . . . if $property(obj,"Name")'="" set joinedVal=$property(obj,"Name")
    . . . . . if $property(obj,"ID")'="" set joinedVal=$property(obj,"ID")
    . . . . }
    . . . . set dataStr=joinedVal
    . . . }
    . . }
    . }
    . set dataStr=$replace(dataStr,"""","""""")
    . set dataStr=""""_dataStr_""""
    . if line'="" set line=line_","_dataStr  i '$l($g(line)) set line=dataStr
    }
    set recCount=recCount+1
    set ^EXPORT($J,recCount)=line
    write "Row ",recCount," written.",!
    quit

; Write CSV file from ^EXPORT($J)
WriteCSV(className)
    new file,filePath,line,rec set filePath="C:\\InterSystems\\Cache\\Hackensack\\"_className_".csv"
    set file=##class(%File).%New()
    set file.Name=filePath
    if file.Exists() do file.Delete()
    set sc=file.Open("WNS") if $SYSTEM.Status.IsError(sc) { write "ERROR opening file",! quit }
    for rec=0:1:999999 {
     continue:'$data(^EXPORT($J,rec))
     set line=^EXPORT($J,rec)
     ;k ^EXPORT($J,rec)
     do file.WriteLine(line)
    }
    do file.Close()
    write "CSV file written to ",filePath,!
    quit

; Quote wrapper for string subscripts
Q(x) if x'?1N.N {quit "\""_x_"\""} else {quit x}

; Job spawner stub — can be enhanced for controller logic
RunExportJobs(pGlobal, pClass, pKeyLen)
    new key,count,gRoot
    set gRoot=$$ResolveGlobal(pGlobal,pClass)
    set count=0
    set key=""
    for { set key=$order(@(gRoot_"("_key_")")) quit:key="" {
     job DrillTimeThree(pGlobal,pClass,key)
     set count=count+1
     write "Launched job for key: ",key,! ; Logging job launches
    }
    write count," jobs launched.",!
    quit
